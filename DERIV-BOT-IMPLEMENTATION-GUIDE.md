# DERIV API COMPLETE BOT IMPLEMENTATION GUIDE

üìä **Documentation Analysis:**
- Total pages analyzed: 54
- Total content: 206.549 characters
- Scraped: 2025-09-08T18:25:36.895Z

## üîê 1. AUTHENTICATION & SETUP

### Account setup
**URL:** https://developers.deriv.com/docs/account-setup

**Code Examples:**
```text
buy
```

```text
proposal
```

```text
buy
```

```text
proposal
```

```text
https://example.com
```

```text
/verify
```

```text
https://example.com/verify
```

**Key Topics:**
- Create a Deriv account
- üìòNote:
- How to add or select your real trading (CR) account
- Step 1
- Open the account switcher
- Step 2
- Manage your accounts
- Step 3
- Choose your currency
- Register your Deriv application
- First-time app registration
- To create additional apps
- Register a new application
- üìòNote
- To update an existing app
- Create an API token
- ‚ùóÔ∏èImportant
- ‚ùóÔ∏èNot recommended
- ‚ö†Ô∏èImportant

**Content Summary:**
Create a Deriv account
Visit api.deriv.com
Click Sign Up on the top right corner of the page.
Provide your Email Address.
Check your inbox for a verification email and click the link to confirm your account.
After verifying your email, provide your Country of residence, Citizenship, and create a Password.
Your Demo account is now active ‚Äî you can start building and testing your apps right away.
To create a Real account, click Complete my profile.
Choose your Account Currency, fill in your Personal and Address details, and accept the Terms of use to proceed.
Your Real account is now active ‚Äî you‚Äôre eligible to earn markup commissions on your app.
üìò

Note:

If your country of residence is one of the supported countries for Wallets, you will also receive a virtual Wallet (demo) account. Once you complete the real account creation process, a real Wallet account will also be created, based on the currency you select.

Attention Developers ‚Äì Wallet Accounts Can‚Äôt Trade!
If your account type...

---

### Authentication
**URL:** https://developers.deriv.com/docs/authentication

**Code Examples:**
```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID
```

```text
YOUR_APP_ID
```

```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID&affiliate_token=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
FB58247C-6B33-4677-A6AD-168C2D72323C
```

```text
dynamicworks
```

```text
jqd7qq_iBB18zg8lBvFoLmNd7ZgqdRLk
```

```text
myaffiliates
```

```text
t
```

```text
utm_campaign
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://[YOUR_WEBSITE_URL]/redirect/?acct1=cr799393&token1=a1-f7pnteezo4jzhpxclctizt27hyeot&cur1=usd& acct2=vrtc1859315&token2=a1clwe3vfuuus5kraceykdsoqm4snfq&cur2=usd&acct3=CRW1157&token3=a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC&cur3=usd&acct4=VRW1160&token4=a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV&cur3=usd
```

```text
https://[YOUR_WEBSITE_URL]/redirect/?acct1=cr799393&token1=a1-f7pnteezo4jzhpxclctizt27hyeot&cur1=usd& acct2=vrtc1859315&token2=a1clwe3vfuuus5kraceykdsoqm4snfq&cur2=usd&acct3=CRW1157&token3=a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC&cur3=usd&acct4=VRW1160&token4=a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV&cur3=usd
```

```text
const user_accounts = [
  {
    currency: 'usd',
    token: 'a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC',
    account: 'CRW1157'
  },
  {
    account: 'VRW1160',
    token: 'a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV',
    currency: 'usd',
  },
  {
    account: 'cr799393',
    token: 'a1-f7pnteezo4jzhpxclctizt27hyeot',
    currency: 'usd',
  },
  {
    account: 'vrtc1859315',
    token: 'a1clwe3vfuuus5kraceykdsoqm4snfq',
    currency: 'usd',
  },
];
```

```text
const user_accounts = [
  {
    currency: 'usd',
    token: 'a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC',
    account: 'CRW1157'
  },
  {
    account: 'VRW1160',
    token: 'a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV',
    currency: 'usd',
  },
  {
    account: 'cr799393',
    token: 'a1-f7pnteezo4jzhpxclctizt27hyeot',
    currency: 'usd',
  },
  {
    account: 'vrtc1859315',
    token: 'a1clwe3vfuuus5kraceykdsoqm4snfq',
    currency: 'usd',
  },
];
```

```text
{
  "authorize": "a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC"
}
```

```text
{
  "authorize": "a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC"
}
```

```text
{
  "account_list": [
    {
      "account_category": "wallet",
      "account_type": "doughflow",
      "broker": "CRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "linked_to": [],
      "loginid": "CRW1157"
    },
    {
      "account_category": "wallet",
      "account_type": "virtual",
      "broker": "VRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 1,
      "landing_company_name": "virtual",
      "linked_to": [],
      "loginid": "VRW1160"
    },
    {
      "account_type": "trading",
      "created_at": 1647509550,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "CR799393",
      "trading": {}
    },
    {
      "account_type": "trading",
      "created_at": 1664132232,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "VRTC1859315",
      "trading": {}
    },
  ],
  "balance": 0,
  "country": "aq",
  "currency": "USD",
  "email": "ss@deriv.com",
  "fullname": "Ms QA script ssRPPta",
  "is_virtual": 0,
  "landing_company_fullname": "Deriv (SVG) LLC",
  "landing_company_name": "svg",
  "linked_to": [],
  "local_currencies": {
    "AAD": {
      "fractional_digits": 2
    }
  },
  "loginid": "CRW1157",
  "preferred_language": "EN",
  "scopes": [
    "admin",
    "payments",
    "read",
    "trade",
    "trading_information"
  ],
  "upgradeable_landing_companies": [],
  "user_id": 464
}
```

```text
{
  "account_list": [
    {
      "account_category": "wallet",
      "account_type": "doughflow",
      "broker": "CRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "linked_to": [],
      "loginid": "CRW1157"
    },
    {
      "account_category": "wallet",
      "account_type": "virtual",
      "broker": "VRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 1,
      "landing_company_name": "virtual",
      "linked_to": [],
      "loginid": "VRW1160"
    },
    {
      "account_type": "trading",
      "created_at": 1647509550,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "CR799393",
      "trading": {}
    },
    {
      "account_type": "trading",
      "created_at": 1664132232,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "VRTC1859315",
      "trading": {}
    },
  ],
  "balance": 0,
  "country": "aq",
  "currency": "USD",
  "email": "ss@deriv.com",
  "fullname": "Ms QA script ssRPPta",
  "is_virtual": 0,
  "landing_company_fullname": "Deriv (SVG) LLC",
  "landing_company_name": "svg",
  "linked_to": [],
  "local_currencies": {
    "AAD": {
      "fractional_digits": 2
    }
  },
  "loginid": "CRW1157",
  "preferred_language": "EN",
  "scopes": [
    "admin",
    "payments",
    "read",
    "trade",
    "trading_information"
  ],
  "upgradeable_landing_companies": [],
  "user_id": 464
}
```

**Key Topics:**
- Authentication process
- üìòImportant note:
- Authorisation process

**Content Summary:**
To unlock the complete functionality of Deriv APIs, you must first authenticate and then authorize your users.

For Deriv APIs, your users must be authenticated and authorized by our OAuth provider and WebSocket Server.

The OAuth provider handles user logins and grants secure access tokens. The WebSocket server then uses these tokens to verify users and facilitate seamless communication with the Deriv API. Together, these components ensure the security and efficiency of your app.

Authentication process

OAuth, short for Open Authorization, is a protocol that enables a client to access server-hosted resources on behalf of the user without exposing their credentials. For more information, refer to OAuth.

This method enables Deriv account holders to log into third-party apps without generating an API token. Consequently, the third-party app does not access the user‚Äôs password or permanent API token, enhancing security.

To authenticate your user:

Make sure the URL is specified correct...

---

### P2P APIs
**URL:** https://developers.deriv.com/docs/p2p

**Code Examples:**
```text
p2p_order_create
```

**Key Topics:**
- üößP2P APIs are only available for real accounts. Ensure that you have a real account to access P2P services.

**Content Summary:**
P2P APIs are designed to manage and facilitate peer-to-peer (P2P) transactions. They offer functionalities for creating and managing P2P advertisements, registering and updating advertisers, handling orders, and managing communication and disputes between participants.

These APIs are crucial for enabling and operating P2P transactions on the Deriv platform, allowing users to engage in seamless and secure trading.

üöß

P2P APIs are only available for real accounts. Ensure that you have a real account to access P2P services.

#	API Name	Description	Send	Subscribe	Scope
1	P2P: Advert Create	Creates a P2P advertisement. This can only be used by a verified P2P advertiser.	‚úî	‚úò	Payments
2	P2P: Advert Information	Retrieves details about a specific P2P advertisement.	‚úî	‚úî	Payments
3	P2P: Advert List	Returns available P2P advertisements for use with the p2p_order_create function.	‚úî	‚úò	Payments
4	P2P: Advert Update	Updates an existing P2P advertisement. This can only be used by the original advert...

---

### Application APIs
**URL:** https://developers.deriv.com/docs/application-apis

**Code Examples:**
```text
app_id
```

```text
app_markup
```

```text
app_markup
```

**Content Summary:**
Application APIs are designed to manage your applications on Deriv. They provide functionalities for registering, updating, and deleting applications, as well as retrieving detailed information and usage statistics.

These APIs are crucial for managing access and permissions for third-party applications, ensuring secure and controlled integration with external services on the Deriv trading platforms.

#	API Name	Description	Send	Subscribe	Scope
1	Application: Delete	Sends a request to delete an application.	‚úî	‚úò	Admin
2	Application: Get Details	Retrieves the information of the OAuth application specified by app_id.	‚úî	‚úò	Read
3	Application: List	List all of the account's OAuth applications.	‚úî	‚úò	Read
4	Application: Markup Details	Retrieves details of app_markup according to specified criteria.	‚úî	‚úò	Read
5	Application: Markup Statistics	Retrieves statistics of app_markup.	‚úî	‚úò	Read
6	Application: Register	Registers a new OAuth application.	‚úî	‚úò	Admin
7	Application: Update	Updates an existing O...

---

### Account APIs
**URL:** https://developers.deriv.com/docs/account-apis

**Code Examples:**
```text
Maltainvest
```

```text
get_self_exclusion
```

```text
get_account_settings
```

**Content Summary:**
Account APIs are designed to manage user accounts, settings, and security. They provide functionalities for authorising sessions, managing API tokens, retrieving and updating account information, handling KYC (Know Your Customer) processes, and setting trading and self-exclusion limits.

These APIs ensure secure, compliant, and personalised interactions on the Deriv platforms, empowering users to manage their accounts and trading activities effectively.

#	API Name	Description	Send	Subscribe	Scope
1	API Token	This call manages API tokens.	‚úî	‚úò	Admin
2	Authorize	Authorises the current WebSocket session using a token. This must precede requests that require access to the client account, such as purchasing or selling contracts.	‚úî	‚úò	NA
3	Balance	Retrieves the user account balance.	‚úî	‚úî	Read
4	Document Upload	Requests and uploads KYC documents from the client.	‚úî	‚úò	Admin
5	Account Status	Retrieves the current status of the user account.	‚úî	‚úò	Read
6	Login History	Retrieves a summary of the user‚Äô...

---

### Trading APIs
**URL:** https://developers.deriv.com/docs/trading-apis

**Code Examples:**
```text
tokens
```

```text
portfolio
```

```text
buy_contract_for_multiple_accounts
```

**Content Summary:**
Trading APIs focus on trading and managing contracts.

They include functionalities for buying, selling, and updating contracts, as well as managing copy trading activities. The APIs also allow users to retrieve important trading information such as profit tables, portfolio details, and contract durations.

These APIs are essential for users who actively trade on the platform and need to manage their trading accounts effectively.

#	API Name	Description	Send	Subscribe	Scope
1	Buy Contract: Trade	Buys a contract.	‚úî	‚úò	Trade
2	Buy Contract for Multiple Accounts	Buys a contract for multiple accounts specified by the tokens parameter. Note that although this is an authorized call, the contract is not purchased for the authorized account.	‚úî	‚úò	Trade
3	Cancel a Contract	Cancels a contract using its contract ID.	‚úî	‚úò	Trade
4	Update Contract	Updates the conditions of a contract.	‚úî	‚úò	Trade
5	Update Contract History	Retrieves the update history of a contract.	‚úî	‚úò	Read
6	Copy Trading: Start	Starts c...

---

### WebSockets
**URL:** https://developers.deriv.com/docs/websockets

**Code Examples:**
```text
wss://ws.derivws.com/websockets/v3?app_id={app_id}
```

```text
{app_id}
```

```text
api_call_limits
```

```text
{app_id}
```

```text
let socket = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id={app_id}');
```

```text
let socket = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id={app_id}');
```

```text
readyState
```

```text
1
```

```text
readyState
```

```text
socket.onopen = function (e) {
  console.log('[open] Connection established');
  console.log('Sending to server');
  const sendMessage = JSON.stringify({ ping: 1 });
  socket.send(sendMessage);
};
```

```text
socket.onopen = function (e) {
  console.log('[open] Connection established');
  console.log('Sending to server');
  const sendMessage = JSON.stringify({ ping: 1 });
  socket.send(sendMessage);
};
```

```text
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`);
};
```

```text
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`);
};
```

```text
Close()
```

```text
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
  } else {
    // e.g. server process killed or network down
    // event.code is usually 1006 in this case
    console.log('[close] Connection died');
  }
};
```

```text
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
  } else {
    // e.g. server process killed or network down
    // event.code is usually 1006 in this case
    console.log('[close] Connection died');
  }
};
```

```text
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`);
};
```

```text
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`);
};
```

```text
Open()
```

```text
OnOpen
```

```text
Send
```

```text
byte[]
```

```text
Close()
```

```text
const app_id = 'app_id'; // Replace with your app_id.
const socket = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`); // Create a new WebSocket connection using the app_id

// Event handler for when the WebSocket connection is opened
socket.onopen = function (e) {
  console.log('[open] Connection established'); // Log connection establishment
  console.log('Sending to server');

  const sendMessage = JSON.stringify({ ping: 1 }); // Create a ping message in JSON format
  socket.send(sendMessage); // Send the ping message to the server
};

// Event handler for when a message is received from the server
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`); // Log the message received from the server
};

// Event handler for when the WebSocket connection is closed
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`); // Log clean close with code and reason
  } else {
    console.log('[close] Connection died'); // Log an abrupt close
  }
};

// Event handler for when an error occurs with the WebSocket connection
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`); // Log the error that occurred
};

/*
Instructions to run this code:

1. Ensure Node.js is installed on your machine. You can download it from https://nodejs.org/.
2. Install the `ws` WebSocket library by running:
   npm install ws
3. Save this code to a file, e.g., `websocket_client.js`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   node websocket_client.js

Ensure that the `app_id` in the URL is replaced with your own if needed.
*/
```

```text
const app_id = 'app_id'; // Replace with your app_id.
const socket = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`); // Create a new WebSocket connection using the app_id

// Event handler for when the WebSocket connection is opened
socket.onopen = function (e) {
  console.log('[open] Connection established'); // Log connection establishment
  console.log('Sending to server');

  const sendMessage = JSON.stringify({ ping: 1 }); // Create a ping message in JSON format
  socket.send(sendMessage); // Send the ping message to the server
};

// Event handler for when a message is received from the server
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`); // Log the message received from the server
};

// Event handler for when the WebSocket connection is closed
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`); // Log clean close with code and reason
  } else {
    console.log('[close] Connection died'); // Log an abrupt close
  }
};

// Event handler for when an error occurs with the WebSocket connection
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`); // Log the error that occurred
};

/*
Instructions to run this code:

1. Ensure Node.js is installed on your machine. You can download it from https://nodejs.org/.
2. Install the `ws` WebSocket library by running:
   npm install ws
3. Save this code to a file, e.g., `websocket_client.js`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   node websocket_client.js

Ensure that the `app_id` in the URL is replaced with your own if needed.
*/
```

```text
import asyncio
import websockets
import json

async def connect_to_websocket():
    app_id = app_id  # Replace with your app_id
    uri = f"wss://ws.derivws.com/websockets/v3?app_id={app_id}"  # WebSocket URI with the app_id

    try:
        # Establish a connection to the WebSocket server
        async with websockets.connect(uri) as websocket:
            print("[open] Connection established")  # Connection opened
            print("Sending to server")

            # Prepare the message to send (ping message in JSON format)
            send_message = json.dumps({"ping": 1})
            await websocket.send(send_message)  # Send the ping message to the server

            # Wait for a response from the server
            response = await websocket.recv()
            print(f"[message] Data received from server: {response}")  # Log the server's response

    except websockets.ConnectionClosedError as e:
        # Handle the scenario where the connection is closed
        if e.code == 1000:
            print(f"[close] Connection closed cleanly, code={e.code} reason={e.reason}")  # Clean close
        else:
            print("[close] Connection died")  # Abrupt close, likely due to network or server issues

    except Exception as e:
        # Handle any other exceptions that may occur
        print(f"[error] {str(e)}")  # Log any errors that occur

# Run the WebSocket client
# asyncio.get_event_loop().run_until_complete() starts the coroutine connect_to_websocket()
asyncio.get_event_loop().run_until_complete(connect_to_websocket())

'''
Instructions to run this code:

1. Ensure Python 3 is installed on your machine. You can download it from https://www.python.org/.
2. Install the `websockets` library by running:
   pip install websockets
3. Save this code to a file, e.g., `websocket_client.py`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   python websocket_client.py

Replace `app_id` with your own application ID if needed.
'''
```

```text
import asyncio
import websockets
import json

async def connect_to_websocket():
    app_id = app_id  # Replace with your app_id
    uri = f"wss://ws.derivws.com/websockets/v3?app_id={app_id}"  # WebSocket URI with the app_id

    try:
        # Establish a connection to the WebSocket server
        async with websockets.connect(uri) as websocket:
            print("[open] Connection established")  # Connection opened
            print("Sending to server")

            # Prepare the message to send (ping message in JSON format)
            send_message = json.dumps({"ping": 1})
            await websocket.send(send_message)  # Send the ping message to the server

            # Wait for a response from the server
            response = await websocket.recv()
            print(f"[message] Data received from server: {response}")  # Log the server's response

    except websockets.ConnectionClosedError as e:
        # Handle the scenario where the connection is closed
        if e.code == 1000:
            print(f"[close] Connection closed cleanly, code={e.code} reason={e.reason}")  # Clean close
        else:
            print("[close] Connection died")  # Abrupt close, likely due to network or server issues

    except Exception as e:
        # Handle any other exceptions that may occur
        print(f"[error] {str(e)}")  # Log any errors that occur

# Run the WebSocket client
# asyncio.get_event_loop().run_until_complete() starts the coroutine connect_to_websocket()
asyncio.get_event_loop().run_until_complete(connect_to_websocket())

'''
Instructions to run this code:

1. Ensure Python 3 is installed on your machine. You can download it from https://www.python.org/.
2. Install the `websockets` library by running:
   pip install websockets
3. Save this code to a file, e.g., `websocket_client.py`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   python websocket_client.py

Replace `app_id` with your own application ID if needed.
'''
```

```text
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.ByteBuffer;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id.
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {
                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");
                    System.out.println("Sending to server");

                    // Create a ping message in JSON format
                    String sendMessage = "{\"ping\": 1}";
                    this.send(sendMessage); // Send the ping message to the server
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Data received from server: " + message); // Log the received message
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    if (remote) {
                        System.out.println("[close] Connection closed by server, code=" + code + " reason=" + reason); // Remote close
                    } else {
                        System.out.println("[close] Connection closed by client, code=" + code + " reason=" + reason); // Client close
                    }
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage()); // Log any errors
                }
                
                @Override
                public void onMessage(ByteBuffer bytes) {
                    System.out.println("[message] ByteBuffer received from server"); // Handle binary message if necessary
                }
            };

            client.connect(); // Connect to the WebSocket server

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run this code:

1. Add the Java-WebSocket library to your project. You can do this by:
   - Using Maven: Add the following dependency to your `pom.xml`:
     <dependency>
         <groupId>org.java-websocket</groupId>
         <artifactId>Java-WebSocket</artifactId>
         <version>1.5.2</version>
     </dependency>
   - Using Gradle: Add the following to your `build.gradle`:
     implementation 'org.java-websocket:Java-WebSocket:1.5.2'

2. Save this code to a file, e.g., `WebSocketExample.java`.

3. Compile the program:
   javac WebSocketExample.java

4. Run the program:
   java WebSocketExample

Make sure to replace `app_id` with your actual application ID if needed.
*/
```

```text
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.ByteBuffer;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id.
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {
                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");
                    System.out.println("Sending to server");

                    // Create a ping message in JSON format
                    String sendMessage = "{\"ping\": 1}";
                    this.send(sendMessage); // Send the ping message to the server
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Data received from server: " + message); // Log the received message
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    if (remote) {
                        System.out.println("[close] Connection closed by server, code=" + code + " reason=" + reason); // Remote close
                    } else {
                        System.out.println("[close] Connection closed by client, code=" + code + " reason=" + reason); // Client close
                    }
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage()); // Log any errors
                }
                
                @Override
                public void onMessage(ByteBuffer bytes) {
                    System.out.println("[message] ByteBuffer received from server"); // Handle binary message if necessary
                }
            };

            client.connect(); // Connect to the WebSocket server

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run this code:

1. Add the Java-WebSocket library to your project. You can do this by:
   - Using Maven: Add the following dependency to your `pom.xml`:
     <dependency>
         <groupId>org.java-websocket</groupId>
         <artifactId>Java-WebSocket</artifactId>
         <version>1.5.2</version>
     </dependency>
   - Using Gradle: Add the following to your `build.gradle`:
     implementation 'org.java-websocket:Java-WebSocket:1.5.2'

2. Save this code to a file, e.g., `WebSocketExample.java`.

3. Compile the program:
   javac WebSocketExample.java

4. Run the program:
   java WebSocketExample

Make sure to replace `app_id` with your actual application ID if needed.
*/
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use AnyEvent;
use AnyEvent::WebSocket::Client 0.12;
use JSON;
use feature 'say';

# WebSocket URL and app_id
my $app_id = app_id; //Replace with your app_id
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging



# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        # handle error...
        warn $@;
        return;

    }
    say "WebSocket connection established.";


    $connection->send('{ ping => 1 }');
    say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";


    # Handle incoming messages
    $connection->on(each_message => sub {
        my($connection, $message) = @_;

        say "message received";
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use AnyEvent;
use AnyEvent::WebSocket::Client 0.12;
use JSON;
use feature 'say';

# WebSocket URL and app_id
my $app_id = app_id; //Replace with your app_id
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging



# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        # handle error...
        warn $@;
        return;

    }
    say "WebSocket connection established.";


    $connection->send('{ ping => 1 }');
    say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";


    # Handle incoming messages
    $connection->on(each_message => sub {
        my($connection, $message) = @_;

        say "message received";
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
<?php

// Include Composer's autoload file
require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your specific app ID
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] Connection established\n";
    echo "Sending to server\n";

    // Send a ping message
    $client->send(json_encode(["ping" => 1]));
    echo "[debug] Message sent: {\"ping\":1}\n";

    // Receive a response from the server
    $response = $client->receive();
    echo "[message] Received from WebSocket: '$response'\n";

    // Close the connection
    $client->close();
    echo "[close] Connection closed\n";

} catch (\WebSocket\ConnectionException $e) {
    echo "[error] Connection error: " . $e->getMessage() . "\n";
} catch (Exception $e) {
    echo "[error] General error: " . $e->getMessage() . "\n";
}

/*
Instructions to run this code:

1. Ensure PHP is installed on your machine. You can check by running `php -v` in your terminal.
2. Install Composer, the dependency manager for PHP, from https://getcomposer.org/.
3. Initialize a Composer project in the directory where this file is saved:
composer init
4. Install the `textalk/websocket` package by adding it to your `composer.json` file or by running:
composer require textalk/websocket
5. Save the PHP code above to a file, e.g., `websocket_client.php`.
6. Run the code in the terminal:
php websocket_client.php
Note: Replace the `app_id` in the URL with your own application ID if needed.
*/
```

```text
<?php

// Include Composer's autoload file
require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your specific app ID
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] Connection established\n";
    echo "Sending to server\n";

    // Send a ping message
    $client->send(json_encode(["ping" => 1]));
    echo "[debug] Message sent: {\"ping\":1}\n";

    // Receive a response from the server
    $response = $client->receive();
    echo "[message] Received from WebSocket: '$response'\n";

    // Close the connection
    $client->close();
    echo "[close] Connection closed\n";

} catch (\WebSocket\ConnectionException $e) {
    echo "[error] Connection error: " . $e->getMessage() . "\n";
} catch (Exception $e) {
    echo "[error] General error: " . $e->getMessage() . "\n";
}

/*
Instructions to run this code:

1. Ensure PHP is installed on your machine. You can check by running `php -v` in your terminal.
2. Install Composer, the dependency manager for PHP, from https://getcomposer.org/.
3. Initialize a Composer project in the directory where this file is saved:
composer init
4. Install the `textalk/websocket` package by adding it to your `composer.json` file or by running:
composer require textalk/websocket
5. Save the PHP code above to a file, e.g., `websocket_client.php`.
6. Run the code in the terminal:
php websocket_client.php
Note: Replace the `app_id` in the URL with your own application ID if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server
    let (mut socket, _response) = connect_async(url).await.expect("Failed to connect");

    println!("[open] Connection established");

    // Prepare the ping message
    let send_message = r#"{"ping": 1}"#;
    socket.send(Message::Text(send_message.into())).await.expect("Failed to send message");

    println!("Message sent to server");

    // Receive a message from the server
    if let Some(Ok(msg)) = socket.next().await {
        println!("[message] Data received from server: {:?}", msg);
    }

    // Close the connection
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed cleanly");
}

/*
Instructions to run this code:

1. Ensure that Rust and Cargo (Rust's package manager) are installed. You can install them from https://rustup.rs/.
2. Initialize a new Rust project if you haven‚Äôt already:
cargo new websocket_client
cd websocket_client
3. Add the following dependencies to your `Cargo.toml` file under `[dependencies]`:
tokio = { version = ‚Äú1‚Äù, features = [‚Äúfull‚Äù] }
tokio-tungstenite = ‚Äú0.15‚Äù
futures-util = ‚Äú0.3‚Äù
url = ‚Äú2.2‚Äù
4. Replace the contents of `src/main.rs` with the code above.
5. Compile and run the code using:
cargo run
Note: Replace `app_id` in the URL with your own application ID if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server
    let (mut socket, _response) = connect_async(url).await.expect("Failed to connect");

    println!("[open] Connection established");

    // Prepare the ping message
    let send_message = r#"{"ping": 1}"#;
    socket.send(Message::Text(send_message.into())).await.expect("Failed to send message");

    println!("Message sent to server");

    // Receive a message from the server
    if let Some(Ok(msg)) = socket.next().await {
        println!("[message] Data received from server: {:?}", msg);
    }

    // Close the connection
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed cleanly");
}

/*
Instructions to run this code:

1. Ensure that Rust and Cargo (Rust's package manager) are installed. You can install them from https://rustup.rs/.
2. Initialize a new Rust project if you haven‚Äôt already:
cargo new websocket_client
cd websocket_client
3. Add the following dependencies to your `Cargo.toml` file under `[dependencies]`:
tokio = { version = ‚Äú1‚Äù, features = [‚Äúfull‚Äù] }
tokio-tungstenite = ‚Äú0.15‚Äù
futures-util = ‚Äú0.3‚Äù
url = ‚Äú2.2‚Äù
4. Replace the contents of `src/main.rs` with the code above.
5. Compile and run the code using:
cargo run
Note: Replace `app_id` in the URL with your own application ID if needed.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a ping message to the server
    func sendPingMessage() {
        let message = URLSessionWebSocketTask.Message.string("{\"ping\": 1}") // Prepare the ping message in JSON format
        webSocketTask?.send(message) { error in
            if let error = error {
                print("[error] Failed to send message: \(error.localizedDescription)")
            } else {
                print("Sending to server")
            }
        }
    }
    
    // Send the ping message initially
    sendPingMessage()

    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    print("[message] Data received from server: \(text)")
                case .data(let data):
                    print("[message] Data received from server: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }

                // Continue to receive messages
                receiveMessage()

            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }

    // Start receiving messages
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    // Use this function when you need to close the connection
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Call the function to connect to the WebSocket
connectWebSocket()

// Example usage: Call closeWebSocketConnection() to close the connection when needed
// The following line will close the connection after 10 seconds for demonstration purposes
DispatchQueue.main.asyncAfter(deadline: .now() + 10) { closeWebSocketConnection() }

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run this code:

1. Ensure that Xcode is installed on your macOS system, or if you're using another platform, ensure Swift is set up correctly.
2. Create a new Swift file in Xcode or any text editor, and paste the above code into it.
3. In Xcode:
   - Go to `File` -> `New` -> `Project`, and select a macOS Command Line Tool.
   - In the project, create a new Swift file and paste this code.
4. Run the project in Xcode to execute the WebSocket client.
5. Alternatively, save the code to a file named `websocket_client.swift` and run it from the terminal using:
swift websocket_client.swift
Note: Replace `app_id` in the WebSocket URL with your own application ID if needed.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a ping message to the server
    func sendPingMessage() {
        let message = URLSessionWebSocketTask.Message.string("{\"ping\": 1}") // Prepare the ping message in JSON format
        webSocketTask?.send(message) { error in
            if let error = error {
                print("[error] Failed to send message: \(error.localizedDescription)")
            } else {
                print("Sending to server")
            }
        }
    }
    
    // Send the ping message initially
    sendPingMessage()

    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    print("[message] Data received from server: \(text)")
                case .data(let data):
                    print("[message] Data received from server: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }

                // Continue to receive messages
                receiveMessage()

            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }

    // Start receiving messages
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    // Use this function when you need to close the connection
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Call the function to connect to the WebSocket
connectWebSocket()

// Example usage: Call closeWebSocketConnection() to close the connection when needed
// The following line will close the connection after 10 seconds for demonstration purposes
DispatchQueue.main.asyncAfter(deadline: .now() + 10) { closeWebSocketConnection() }

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run this code:

1. Ensure that Xcode is installed on your macOS system, or if you're using another platform, ensure Swift is set up correctly.
2. Create a new Swift file in Xcode or any text editor, and paste the above code into it.
3. In Xcode:
   - Go to `File` -> `New` -> `Project`, and select a macOS Command Line Tool.
   - In the project, create a new Swift file and paste this code.
4. Run the project in Xcode to execute the WebSocket client.
5. Alternatively, save the code to a file named `websocket_client.swift` and run it from the terminal using:
swift websocket_client.swift
Note: Replace `app_id` in the WebSocket URL with your own application ID if needed.
*/
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE: {
        const char *ping_msg = "{\"ping\": 1}";
        unsigned char buf[LWS_PRE + 20];
        memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
        lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
        break;
    }

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE: {
        const char *ping_msg = "{\"ping\": 1}";
        unsigned char buf[LWS_PRE + 20];
        memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
        lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
        break;
    }

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    public static async Task Main(string[] args)
    {
        string app_id = "app_id"; // Replace with your app_id.
        string uri = $"wss://ws.derivws.com/websockets/v3?app_id={app_id}"; // WebSocket URI with the app_id

        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            try
            {
                // Connect to the WebSocket server
                await webSocket.ConnectAsync(new Uri(uri), CancellationToken.None);
                Console.WriteLine("[open] Connection established");

                // Send a ping message to the server
                string sendMessage = "{\"ping\": 1}"; // Prepare the ping message in JSON format
                ArraySegment<byte> bytesToSend = new ArraySegment<byte>(Encoding.UTF8.GetBytes(sendMessage));
                await webSocket.SendAsync(bytesToSend, WebSocketMessageType.Text, true, CancellationToken.None);
                Console.WriteLine("Sending to server");

                // Receive message from the server
                var buffer = new byte[1024];
                WebSocketReceiveResult result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
                string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
                Console.WriteLine("[message] Data received from server: " + response);

                // Close the WebSocket connection cleanly
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Close connection", CancellationToken.None);
                Console.WriteLine("[close] Connection closed cleanly");
            }
            catch (WebSocketException e)
            {
                Console.WriteLine("[error] WebSocket error: " + e.Message);
            }
            catch (Exception e)
            {
                Console.WriteLine("[error] " + e.Message);
            }
        }
    }
}

/*
 * Instructions:
 * 1. Ensure you have the .NET SDK installed on your machine. You can download it from https://dotnet.microsoft.com/download.
 * 2. Save this code in a file, e.g., WebSocketExample.cs.
 * 3. Open a terminal and navigate to the directory where you saved the file.
 * 4. Create a new .NET console project and add the required WebSocket package:
 *      dotnet new console -o WebSocketExampleApp
 *      mv WebSocketExample.cs WebSocketExampleApp/WebSocketExample.cs
 *      cd WebSocketExampleApp
 *      dotnet add package System.Net.WebSockets.Client --version 4.5.3
 * 5. Run the application with:
 *      dotnet run
 *
 * Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
 */
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    public static async Task Main(string[] args)
    {
        string app_id = "app_id"; // Replace with your app_id.
        string uri = $"wss://ws.derivws.com/websockets/v3?app_id={app_id}"; // WebSocket URI with the app_id

        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            try
            {
                // Connect to the WebSocket server
                await webSocket.ConnectAsync(new Uri(uri), CancellationToken.None);
                Console.WriteLine("[open] Connection established");

                // Send a ping message to the server
                string sendMessage = "{\"ping\": 1}"; // Prepare the ping message in JSON format
                ArraySegment<byte> bytesToSend = new ArraySegment<byte>(Encoding.UTF8.GetBytes(sendMessage));
                await webSocket.SendAsync(bytesToSend, WebSocketMessageType.Text, true, CancellationToken.None);
                Console.WriteLine("Sending to server");

                // Receive message from the server
                var buffer = new byte[1024];
                WebSocketReceiveResult result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
                string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
                Console.WriteLine("[message] Data received from server: " + response);

                // Close the WebSocket connection cleanly
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Close connection", CancellationToken.None);
                Console.WriteLine("[close] Connection closed cleanly");
            }
            catch (WebSocketException e)
            {
                Console.WriteLine("[error] WebSocket error: " + e.Message);
            }
            catch (Exception e)
            {
                Console.WriteLine("[error] " + e.Message);
            }
        }
    }
}

/*
 * Instructions:
 * 1. Ensure you have the .NET SDK installed on your machine. You can download it from https://dotnet.microsoft.com/download.
 * 2. Save this code in a file, e.g., WebSocketExample.cs.
 * 3. Open a terminal and navigate to the directory where you saved the file.
 * 4. Create a new .NET console project and add the required WebSocket package:
 *      dotnet new console -o WebSocketExampleApp
 *      mv WebSocketExample.cs WebSocketExampleApp/WebSocketExample.cs
 *      cd WebSocketExampleApp
 *      dotnet add package System.Net.WebSockets.Client --version 4.5.3
 * 5. Run the application with:
 *      dotnet run
 *
 * Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
 */
```

```text
package main

import (
    "fmt"
    "log"
    "net/url"
    "os"
    "os/signal"
    "time"

    "github.com/gorilla/websocket"
)

func main() {
    // Define the WebSocket server URL
    appID := "app_id" // Replace with your app_id.
    serverURL := url.URL{Scheme: "wss", Host: "ws.derivws.com", Path: "/websockets/v3", RawQuery: "app_id=" + appID}
    fmt.Printf("Connecting to %s\n", serverURL.String())

    // Connect to the WebSocket server
    c, _, err := websocket.DefaultDialer.Dial(serverURL.String(), nil)
    if err != nil {
        log.Fatal("Dial error:", err)
    }
    defer c.Close()

    done := make(chan struct{})

    // Goroutine to handle receiving messages from the server
    go func() {
        defer close(done)
        for {
            _, message, err := c.ReadMessage()
            if err != nil {
                log.Println("Read error:", err)
                return
            }
            fmt.Printf("[message] Data received from server: %s\n", message)
        }
    }()

    // Send a ping message to the server
    pingMessage := `{"ping": 1}` // Prepare the ping message in JSON format
    err = c.WriteMessage(websocket.TextMessage, []byte(pingMessage))
    if err != nil {
        log.Println("Write error:", err)
        return
    }
    fmt.Println("Sending to server")

    // Set up signal handling to gracefully close the connection
    interrupt := make(chan os.Signal, 1)
    signal.Notify(interrupt, os.Interrupt)

    // Loop to handle connection closure or interruptions
    for {
        select {
        case <-done:
            return
        case <-interrupt:
            fmt.Println("[close] Interrupt signal received. Closing connection.")
            // Close the WebSocket connection gracefully
            err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
            if err != nil {
                log.Println("Write close error:", err)
                return
            }
            select {
            case <-done:
            case <-time.After(time.Second):
            }
            return
        }
    }
}

/*
Instructions:
1. Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.
2. Install the Gorilla WebSocket package by running:
       go get github.com/gorilla/websocket
3. Save this code to a file, e.g., websocket_client.go.
4. Open a terminal, navigate to the directory where you saved the file, and run:
       go run websocket_client.go

Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
*/
```

```text
package main

import (
    "fmt"
    "log"
    "net/url"
    "os"
    "os/signal"
    "time"

    "github.com/gorilla/websocket"
)

func main() {
    // Define the WebSocket server URL
    appID := "app_id" // Replace with your app_id.
    serverURL := url.URL{Scheme: "wss", Host: "ws.derivws.com", Path: "/websockets/v3", RawQuery: "app_id=" + appID}
    fmt.Printf("Connecting to %s\n", serverURL.String())

    // Connect to the WebSocket server
    c, _, err := websocket.DefaultDialer.Dial(serverURL.String(), nil)
    if err != nil {
        log.Fatal("Dial error:", err)
    }
    defer c.Close()

    done := make(chan struct{})

    // Goroutine to handle receiving messages from the server
    go func() {
        defer close(done)
        for {
            _, message, err := c.ReadMessage()
            if err != nil {
                log.Println("Read error:", err)
                return
            }
            fmt.Printf("[message] Data received from server: %s\n", message)
        }
    }()

    // Send a ping message to the server
    pingMessage := `{"ping": 1}` // Prepare the ping message in JSON format
    err = c.WriteMessage(websocket.TextMessage, []byte(pingMessage))
    if err != nil {
        log.Println("Write error:", err)
        return
    }
    fmt.Println("Sending to server")

    // Set up signal handling to gracefully close the connection
    interrupt := make(chan os.Signal, 1)
    signal.Notify(interrupt, os.Interrupt)

    // Loop to handle connection closure or interruptions
    for {
        select {
        case <-done:
            return
        case <-interrupt:
            fmt.Println("[close] Interrupt signal received. Closing connection.")
            // Close the WebSocket connection gracefully
            err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
            if err != nil {
                log.Println("Write close error:", err)
                return
            }
            select {
            case <-done:
            case <-time.After(time.Second):
            }
            return
        }
    }
}

/*
Instructions:
1. Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.
2. Install the Gorilla WebSocket package by running:
       go get github.com/gorilla/websocket
3. Save this code to a file, e.g., websocket_client.go.
4. Open a terminal, navigate to the directory where you saved the file, and run:
       go run websocket_client.go

Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
*/
```

**Key Topics:**
- General information
- Base endpoint
- Rate limits
- Session validity
- Create WebSocket
- Create a WebSocket instance
- üößWarning:
- üìòImportant: Secure vs. Unsecured Connections
- Events
- OnOpen
- OnMessage
- OnClose
- OnError
- Methods
- Open
- Send
- Close
- üößYou cannot reuse a closed WebSocket instance, you have to create and set up a new one.
- ‚ÑπÔ∏èReferences

**Content Summary:**
General information
Base endpoint

To connect to Deriv's WebSocket APIs, you'll need to use the following base endpoint:

wss://ws.derivws.com/websockets/v3?app_id={app_id}

Make sure to replace {app_id} with the unique ID of the application you registered.

Rate limits

The rate limits for API requests can change over time. To find out the current limit, you can make a server status call and check the api_call_limits field. This ensures you always have the most up-to-date information.

Session validity

Your WebSocket session will time out after 2 minutes of inactivity. If there are no requests or responses during this time, the server will close the connection. To prevent this, send requests periodically to keep the connection alive.

For example, you can send a ping request or another simple call like time at regular intervals.

Create WebSocket

To get started with WebSockets, you must first create a new WebSocket instance. Here‚Äôs how you can do it:

Create a WebSocket instance

Us...

---

### OAuth
**URL:** https://developers.deriv.com/docs/oauth

**Code Examples:**
```text
Website URL
```

```text
https://oauth.deriv.com/oauth2/authorize?app_id=your_app_id
```

```text
your_app_id
```

```text
https://[YOUR_WEBSITE_URL]/redirect/?acct1=cr799393&token1=a1-f7pnteezo4jzhpxclctizt27hyeot&cur1=usd&acct2=vrtc1859315&token2=a1clwe3vfuuus5kraceykdsoqm4snfq&cur2=usd&state=
```

**Key Topics:**
- How to use OAuth authorization

**Content Summary:**
OAuth (Open Authorization) is a protocol that allows a client to access a user‚Äôs resources on a server without requiring the user‚Äôs login credentials. With OAuth, users can log into third-party apps using their Deriv accounts without sharing passwords or API tokens, providing a secure and convenient option.

OAuth2 is a secure method for developers to grant app access to users, although it requires a few more setup steps. It is the best way to ensure security while enabling third-party access.

How to use OAuth authorization

To set up OAuth authorization for your app, follow these steps:

Specify the OAuth redirect URL: Go to the app registration page and enter the URL you want to use as the OAuth Redirect URL in the "Website URL" field.

Add a login button:

Add a login button to your website or app that directs users to:

https://oauth.deriv.com/oauth2/authorize?app_id=your_app_id

Replace your_app_id with your actual app ID.

Handle user redirection: After a user logs in, they will...

---

### Error codes
**URL:** https://developers.deriv.com/docs/error-codes

**Key Topics:**
- General
- MT5
- P2P
- Account
- Application
- Cashier
- Trading
- Deriv X

**Content Summary:**
General
Error Code	Message
AccountShouldBeReal	Only real accounts are allowed to open [_1] real accounts. Demo account cannot open real dxtrader.
AccountTypesMismatch	Transfer between real and virtual accounts is not allowed.
AccountWithDeposit	Change of currency is not allowed for an existing account with previous deposits.
AffiliateNotFound	N/A
AllowCopiersError	Copier can't be a trader.
AlreadyAgeVerified	Your age has already been verified.
AlreadyVerified	This account is already phone number verified.
AmountNotAllowed	The minimum amount for transfers is [_1] [_2] after conversion fees are deducted. Please adjust the amount.
AppGet	Not Found
AppRegister	Not Found
AppUpdate	N/A
AppropriatenessTestFailed	Failed to reach an acceptable trading experience score.
AuthenticateAccount	Please authenticate your [_1] account to proceed with the fund transfer.
AuthenticateAccountCreate	Please verify your [_1] account to proceed with account creation.
AuthorizationRequired	Please log in.
BadSess...

---

### Affiliates
**URL:** https://developers.deriv.com/docs/affiliates

**Code Examples:**
```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID&affiliate_token=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID&affiliate_token=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
YOUR_APP_ID
```

```text
YOUR_TOKEN
```

```text
FB58247C-6B33-4677-A6AD-168C2D72323C
```

```text
dynamicworks
```

```text
jqd7qq_iBB18zg8lBvFoLmNd7ZgqdRLk
```

```text
myaffiliates
```

```text
t
```

```text
utm_campaign
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
new_account_virtual
```

```text
new_account_real
```

```text
new_account_maltainvest
```

**Key Topics:**
- How to Become a Deriv Affiliate
- Affiliate Benefits
- Leveraging Deriv API for Affiliate Earnings
- 1. Signing in Users
- üìòImportant note:
- 2. Creating New Accounts Using APIs

**Content Summary:**
How to Become a Deriv Affiliate

Getting started as a Deriv Affiliate is simple and quick. Follow these steps:

Visit our Partners page and click on "Become a Partner".
Complete the Affiliate application form.
Wait for approval, which typically takes 1‚Äì3 working days.

Pro Tip: The approval process may be faster if your partner account application uses the same email as an existing Deriv account. Don‚Äôt have an account yet? Sign up here.

Affiliate Benefits

As a Deriv Affiliate, you‚Äôll gain access to exclusive advantages, including:

Up to 45% commission on referred clients‚Äô trading activity.

Free educational and marketing resources to support your efforts.

Multilingual support for global reach.

Transparent fee structure with detailed earnings reports.

Dedicated account manager to assist you.

24/7 live chat support for immediate help.

Affiliates can earn commissions when referred clients trade Options on third-party platforms developed using the Deriv API.

Leveraging Deriv API f...

---

### Rise/Fall
**URL:** https://developers.deriv.com/docs/risefall

**Code Examples:**
```text
contract_type
```

```text
contract_type
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
Predict if the market price will rise above or fall below the entry price at the end of the contract.

If you select "Rise", you win the Payout if the Exit spot is strictly higher than the Entry spot.

If you select "Fall", you win the Payout if the Exit spot is strictly lower than the Entry spot.

If you select "Allow equals", you win the Payout if Exit spot is higher than or equal to Entry spot for "Rise". Similarly, you win the Payout if Exit spot is lower than or equal to Entry spot for "Fall".

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Rise/Fall option...

---

### Higher/Lower
**URL:** https://developers.deriv.com/docs/higherlower

**Code Examples:**
```text
contract_type
```

```text
barrier: "+0.37"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
Choose a target price (Barrier) and predict if the market price will be higher or lower than the target at the end of the contract.

If you select "Higher", you win the Payout if the Exit spot is strictly higher than the Barrier.

If you select "Lower", you win the Payout if the Exit spotis strictly lower than the Barrier.

If the Exit spot is equal to the Barrier, you don't win the Payout.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Higher/Lower options:

Use the the contract_type:
For Higher, use: "CALL"
For Lower, use: "PUT"
Set the Barrier. Eg: barrier: ...

---

### Ends Between
**URL:** https://developers.deriv.com/docs/ends-between

**Code Examples:**
```text
contract_type
```

```text
EXPIRYRANGE
```

```text
EXPIRYMISS
```

```text
barrier
```

```text
barrier: "+1.51"
```

```text
barrier2
```

```text
barrier: "-1.51"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow
- üëçAdd +/- to define a barrier offset. For example, +0.005 means a Barrier that's 0.005 higher than the Entry spot.

**Content Summary:**
Choose a price range (upper and lower barriers) and predict if the market price will end between or end outside the range at the end of the contract.

If you select "Ends Between", you win the Payout if the Exit spot is strictly higher than the Low Barrier AND strictly lower than the High Barrier.

If you select "Ends Outside", you win the Payout if the Exit spot is EITHER strictly higher than the High Barrier, OR strictly lower than the Low Barrier.

If the Exit spot is equal to either the Low Barrier or the High Barrier, you don‚Äôt win the Payout.

Trading Flow

Authorize using your token: Call [authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an...

---

### Stays Between
**URL:** https://developers.deriv.com/docs/stays-between

**Code Examples:**
```text
contract_type
```

```text
RANGE
```

```text
UPORDOWN
```

```text
barrier
```

```text
barrier: "+1.51"
```

```text
barrier2
```

```text
barrier: "-1.51"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow
- üëçAdd +/- to define a barrier offset. For example, +0.005 means a Barrier that's 0.005 higher than the Entry spot.

**Content Summary:**
Choose a price range (upper and lower barriers) and predict if the market price will stay between or go outside the range during the contract period.

If you select "Stays Between", you win the Payout if the market stays between (does not touch) either the High Barrier or the Low Barrier at any time during the Contract period.

If you select "Goes Outside", you win the Payout if the market touches either the High Barrier or the Low Barrier at any time during the Contract period.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Stays Between/ Goes Outside options,...

---

### Lookbacks
**URL:** https://developers.deriv.com/docs/lookbacks

**Code Examples:**
```text
contract_type
```

```text
LBFLOATPUT
```

```text
multiplier: 1
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

```text
contract_type
```

```text
LBHIGHLOW
```

```text
multiplier: 1
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

```text
contract_type
```

```text
LBFLOATCALL
```

```text
multiplier: 1
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- High-Close
- Trading Flow
- High-Low
- Trading Flow
- Close-Low
- Trading Flow

**Content Summary:**
Choose an amount you want to earn per point of movement. There are three types of lookbacks:

High-Close: The highest market price during the contract period minus the price at the contract end.
High-Low: The highest market price minus the lowest market price during the contract period.
Close-Low: The market price at the contract end minus the lowest market price during the contract period.
High-Close

By purchasing the "High-Close" contract, you'll win the multiplier times the difference between the High and Close over the duration of the contract.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID ...

---

### Touch/No Touch
**URL:** https://developers.deriv.com/docs/touchno-touch

**Code Examples:**
```text
contract_type
```

```text
ONETOUCH
```

```text
NOTOUCH
```

```text
barrier: "+1.37"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
Choose a target price (Barrier) and predict if the market price will touch or not touch the target during the contract period.

If you select "Touch", you win the Payout if the market touches the Barrier at any time during the contract period.

If you select "No Touch", you win the Payout if the market never touches the Barrier at any time during the contract period.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Touch/No Touch options:

Use the the contract_type:

For Touch, use: "ONETOUCH"
For No Touch, use: "NOTOUCH"

Set the Barrier. Eg: barrier: "+1.37"

B...

---

### Only Ups/Only Downs
**URL:** https://developers.deriv.com/docs/only-upsonly-downs

**Code Examples:**
```text
contract_type
```

```text
RUNHIGH
```

```text
RUNLOW
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
Predict if the market price will go only up or only down during the contract period.

If you select "Only Ups", you win the Payout if consecutive ticks rise successively after the Entry spot. No payout if any tick falls or is equal to any of the previous ticks.

If you select "Only Downs", you win the Payout if consecutive ticks fall successively after the Entry spot. No payout if any tick rises or is equal to any of the previous ticks.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Only Ups/Downs options:

Use the the contract_type:
For Only Ups , use: "RUNHIG...

---

### Highest/Lowest Tick
**URL:** https://developers.deriv.com/docs/highestlowest-tick

**Code Examples:**
```text
contract_type
```

```text
TICKHIGH
```

```text
TICKLOW
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
Predict which of the next 5 ticks will see the highest or lowest market price.

If you select "High Tick", you win the Payout if the selected tick is the highest among the next five ticks.

If you select "Low Tick", you win the Payout if the selected tick is the lowest among the next five ticks.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the High/Low Tick options:

Use the the contract_type:
For High Tick, use: "TICKHIGH"
For Low Tick, use: "TICKLOW"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action re...

---

### Reset Call/Put
**URL:** https://developers.deriv.com/docs/reset-callput

**Code Examples:**
```text
contract_type
```

```text
RESETCALL
```

```text
RESETPUT
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
Predict if the market price will be higher (Call) or lower (Put) than the entry price or the reset price at the end of the contract. A 'reset' is triggered if the market moves against your prediction around the midpoint of the contract, setting the reset price to the market‚Äôs current level.




If you select "Reset-Call", you win the Payout if the Exit spot is strictly higher than either the Entry spot or the spot at Reset time.

If you select "Reset-Put", you win the Payout if the Exit spot is strictly lower than either the Entry spot or the spot at Reset time.

If the Exit spot is equal to the Barrier or the new Barrier (if a reset occurs), you don't win the Payout.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of ...

---

### Asian Up/Down
**URL:** https://developers.deriv.com/docs/asian-updown

**Code Examples:**
```text
contract_type
```

```text
ASIANU
```

```text
ASIAND
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
Asian options settle by comparing the last tick with the average spot over the period.

If you select "Asian Up", you will win the Payout if the last tick is higher than the averageof the ticks.

If you select "Asian Down", you will win the Payout if the last tick is lower than the average of the ticks.

If the last tick is equal to the average of the ticks, you don't win the Payout.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.
Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.
Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Asian Up/Down options, set the the contract_type:
For Up, use: "ASIANU"
For Down, use: "ASIAND"
Buy the Contract: Execute the trade by us...

---

### Digit Matches/Differs
**URL:** https://developers.deriv.com/docs/digit-matchesdiffers

**Code Examples:**
```text
contract_type
```

```text
DIGITMATCH
```

```text
DIGITDIFF
```

```text
barrier
```

```text
barrier: "9"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
If you select "Matches", you will win the payout if the last digit of the last tick is the same as your prediction.

If you select "Differs", you will win the payout if the last digit of the last tick is not the same as your prediction.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Matches/Differs options, use the following:

Set contract_type:

For Matches, use: "DIGITMATCH"
For Differs, use: "DIGITDIFF"

For the Last Digit Prediction: set the barrier between 0-9. Eg: barrier: "9"

Buy the Contract: Execute the trade by using the buy API with the ID from the ...

---

### Digit Even/Odd
**URL:** https://developers.deriv.com/docs/digit-evenodd

**Code Examples:**
```text
contract_type
```

```text
DIGITEVEN
```

```text
DIGITODD
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
If you select "Even", you will win the Payout if the last digit of the last tick is an even number (i.e., 2, 4, 6, 8, or 0).

If you select "Odd", you will win the Payout if the last digit of the last tick is an odd number (i.e., 1, 3, 5, 7, or 9).

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the digit Even/Odd options, use the following the contract_type:

For Even: "DIGITEVEN"
For Odd: "DIGITODD"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action returns a unique contract_id.

Monitor the Contract Statu...

---

### Digit Over/Under
**URL:** https://developers.deriv.com/docs/digit-overunder

**Code Examples:**
```text
contract_type
```

```text
DIGITMATCH
```

```text
DIGITUNDER
```

```text
barrier
```

```text
barrier: "6"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
If you select "Over", you will win the Payout if the last digit of the last tick is greater than your prediction.

If you select "Under", you will win the Payout if the last digit of the last tick is less than your prediction.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Digit Over/Under options, use the following

Set contract_type:

For Over, use: "DIGITMATCH"
For Under, use: "DIGITUNDER"

For the Last Digit Prediction: set the barrier between 0-9. Eg: barrier: "6"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal respo...

---

### Accumulator Options
**URL:** https://developers.deriv.com/docs/accumulator-options

**Code Examples:**
```text
contract_type
```

```text
"ACCU"
```

```text
growth_rate: 0.03
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150 }
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
Amplify potential profits with up to 5% compounding growth per tick with Accumulator Options.

Choose a growth rate (1-5%) within a specified price range and predict if the market price will stay within the range. Your Payout grows at a compounding rate for each tick, and the market price stays in the range.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.
Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.
Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the accumulator options,
Use the contract_type: "ACCU"
Growth Rate: You can choose a growth rate with values of 1%(0.01), 2%(0.02), 3%(0.03), 4%(0.04), and 5%(0.05). Eg: Set growth_rate: 0.03
Take Profit: If you select...

---

### Vanilla Options
**URL:** https://developers.deriv.com/docs/vanilla-options

**Code Examples:**
```text
contract_type
```

```text
"VANILLALONGCALL"
```

```text
"VANILLALONGPUT"
```

```text
barrier: "+0.00"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
Earn a potentially high payout with Vanilla Options if your predictions are right within a timed contract based on market conditions.

Vanilla options allow you to predict an upward (bullish) or downward (bearish) direction of the underlying asset by purchasing a "Call" or a "Put".

If you select "Call", you'll earn a Payout if the Final price is above the Strike price at Expiry. Otherwise, you won't receive a payout.
If you select "Put", you'll earn a Payout if the Final price is below the Strike price at Expiry. Otherwise, you won't receive a payout.

Your Payout is equal to the Payout per point multiplied by the difference between the Final price and the Strike price. You will only earn a profit if your Payout is higher than your initial stake.

You may sell the contract up until 60 seconds before Expiry. If you do, we'll pay you the Contract value.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fet...

---

### Turbo Options
**URL:** https://developers.deriv.com/docs/turbo-options

**Code Examples:**
```text
contract_type
```

```text
"TURBOSLONG"
```

```text
"TURBOSSHORT"
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150 }
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
With Turbo Options, you can earn a payout if your predictions are right and if the spot price does not touch or breach a predetermined barrier.

Turbo options allow you to predict the direction of the underlying asset's movements.

You receive a Payout at Expiry if the spot price never breaches the Barrier during the contract period. If it does, your contract will be terminated early.

If you select "Up", you'll earn a Payout if the spot price never drops below the Barrier.

If you select "Down", you'll earn a Payout if the spot price never rises above the Barrier.

Your payout is equal to the Payout per point multiplied by the distance between the Final price and the Barrier. You will only earn a profit if your Payout is higher than your initial stake.

You may sell the contract up to 15 seconds before expiry. If you do, we'll pay you the Contract value.
If you choose your duration in number of ticks, you won't be able to terminate your contract early.

Trading Flow
Authorize using yo...

---

### Multipliers
**URL:** https://developers.deriv.com/docs/multipliers

**Code Examples:**
```text
contract_type
```

```text
"MULTUP"
```

```text
"MULTDOWN"
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150 }
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150, stop_loss:130 }
```

```text
cancellation: 60m
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Key Topics:**
- Trading Flow

**Content Summary:**
Multiply your potential profit by up to 2,000x if the market moves in your favour. Losses are limited only to your initial capital.

Choose a multiplier (up to 2,000x) and predict if the market price will go up(bullish)or down (bearish) compared to the entry price. Your potential payout grows as the market price moves in your predicted direction, boosted by the multiplier. Losses are limited to the initial amount you put into the contract.

If you select "Up", your total profit/loss will be the percentage increase in the underlying asset price, times the multiplier and stake, minus commissions.
If you select "Down", your total profit/loss will be the percentage decrease in the underlying asset price, times the multiplier and stake, minus commissions.

Your contract will be closed when the Stop out level is reached.

Additional features are available to manage your positions: Take profit, Stop loss and Deal cancellation allow you to adjust your level of risk aversion.

You can close you...

---

### Keep connection live
**URL:** https://developers.deriv.com/docs/keep-connection-live

**Code Examples:**
```text
DerivAPIBasic
```

```text
import DerivAPIBasic from 'https://cdn.skypack.dev/@deriv/deriv-api/dist/DerivAPIBasic';
```

```text
app_id
```

```text
wss://ws.derivws.com/websockets/v3?app_id=${app_id}
```

```text
const connection = new WebSocket(
```

```text
);
```

```text
DerivAPIBasic
```

```text
const api = new DerivAPIBasic({ connection });
```

```text
proposal()
```

```text
const proposal = () => {  
  api.subscribe({  
    proposal: 1,  
    subscribe: 1,  
    amount: 10,  
    basis: 'payout',  
    contract_type: 'CALL',  
    currency: 'USD',  
    duration: 1,  
    duration_unit: 'm',  
    symbol: 'R_100',  
    barrier: '+0.1',  
  });  
};
```

```text
const proposal = () => {  
  api.subscribe({  
    proposal: 1,  
    subscribe: 1,  
    amount: 10,  
    basis: 'payout',  
    contract_type: 'CALL',  
    currency: 'USD',  
    duration: 1,  
    duration_unit: 'm',  
    symbol: 'R_100',  
    barrier: '+0.1',  
  });  
};
```

```text
ping()
```

```text
ping
```

```text
setInterval
```

```text
const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000);
};
```

```text
const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000);
};
```

```text
wsResponse()
```

```text
const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error: %s ', data.error.message);
    connection.removeEventListener('message', wsResponse, false);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details: %s', data.proposal.longcode);
    console.log('Ask Price: %s', data.proposal.display_value);
    console.log('Payout: %f', data.proposal.payout);
    console.log('Spot: %f', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};
```

```text
const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error: %s ', data.error.message);
    connection.removeEventListener('message', wsResponse, false);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details: %s', data.proposal.longcode);
    console.log('Ask Price: %s', data.proposal.display_value);
    console.log('Payout: %f', data.proposal.payout);
    console.log('Spot: %f', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};
```

```text
checkSignal()
```

```text
proposal()
```

```text
ping()
```

```text
connection.addEventListener('message', wsResponse)
```

```text
wsResponse()
```

```text
const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};
```

```text
const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};
```

```text
endCall()
```

```text
unsubscribe()
```

```text
proposal()
```

```text
const endCall = () => {
  connection.removeEventListener('message', wsResponse, false);
  proposal().unsubscribe();
};
```

```text
const endCall = () => {
  connection.removeEventListener('message', wsResponse, false);
  proposal().unsubscribe();
};
```

```text
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

const app_id = app_id; // Replace with your app_id if different.
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
const api = new DerivAPIBasic({ connection });

const proposal = () => {
  api.subscribe({
    proposal: 1,
    subscribe: 1,
    amount: 10,
    basis: 'payout',
    contract_type: 'CALL',
    currency: 'USD',
    duration: 1,
    duration_unit: 'm',
    symbol: 'R_100',
    barrier: '+0.1',
  });
};

const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000); // Sends a ping message every 30 seconds
};

const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error:', data.error.message);
    connection.removeEventListener('message', wsResponse);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details:', data.proposal.longcode);
    console.log('Ask Price:', data.proposal.display_value);
    console.log('Payout:', data.proposal.payout);
    console.log('Spot:', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};

const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};

// Browser-specific functionality
if (typeof document !== 'undefined') {
  const keep_alive_button = document.querySelector('#keep_alive');
  const end_call_button = document.querySelector('#end_call');

  keep_alive_button.addEventListener('click', checkSignal);
  end_call_button.addEventListener('click', () => {
    connection.removeEventListener('message', wsResponse);
    proposal().unsubscribe();
  });
} else {
  // For Node.js environment: start the signal check immediately
  checkSignal();
}

/*
Instructions:

1. **Install Node.js**: Ensure you have Node.js installed from https://nodejs.org/.
2. **Install Deriv API Package**: Use npm to install the Deriv API package by running:
npm install @deriv/deriv-api
3. **Save the Code**: Save the code in a file, e.g., `websocket_example.js`.
4. **Run in Node.js**:
- In your terminal, navigate to the directory where you saved the file.
- Run the script using:
  ```
  node websocket_example.js
  ```
5. **Run in a Browser**:
- Include the script in your HTML page, and ensure there are two buttons with IDs `keep_alive` and `end_call`.
- Use the `keep_alive` button to start the signal check and the `end_call` button to unsubscribe from the proposal and stop receiving messages.

Replace the `app_id` in the URL if you have a different app ID.
*/
```

```text
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

const app_id = app_id; // Replace with your app_id if different.
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
const api = new DerivAPIBasic({ connection });

const proposal = () => {
  api.subscribe({
    proposal: 1,
    subscribe: 1,
    amount: 10,
    basis: 'payout',
    contract_type: 'CALL',
    currency: 'USD',
    duration: 1,
    duration_unit: 'm',
    symbol: 'R_100',
    barrier: '+0.1',
  });
};

const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000); // Sends a ping message every 30 seconds
};

const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error:', data.error.message);
    connection.removeEventListener('message', wsResponse);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details:', data.proposal.longcode);
    console.log('Ask Price:', data.proposal.display_value);
    console.log('Payout:', data.proposal.payout);
    console.log('Spot:', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};

const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};

// Browser-specific functionality
if (typeof document !== 'undefined') {
  const keep_alive_button = document.querySelector('#keep_alive');
  const end_call_button = document.querySelector('#end_call');

  keep_alive_button.addEventListener('click', checkSignal);
  end_call_button.addEventListener('click', () => {
    connection.removeEventListener('message', wsResponse);
    proposal().unsubscribe();
  });
} else {
  // For Node.js environment: start the signal check immediately
  checkSignal();
}

/*
Instructions:

1. **Install Node.js**: Ensure you have Node.js installed from https://nodejs.org/.
2. **Install Deriv API Package**: Use npm to install the Deriv API package by running:
npm install @deriv/deriv-api
3. **Save the Code**: Save the code in a file, e.g., `websocket_example.js`.
4. **Run in Node.js**:
- In your terminal, navigate to the directory where you saved the file.
- Run the script using:
  ```
  node websocket_example.js
  ```
5. **Run in a Browser**:
- Include the script in your HTML page, and ensure there are two buttons with IDs `keep_alive` and `end_call`.
- Use the `keep_alive` button to start the signal check and the `end_call` button to unsubscribe from the proposal and stop receiving messages.

Replace the `app_id` in the URL if you have a different app ID.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a proposal subscription request
    func sendProposalSubscription() {
        let proposalRequest = [
            "proposal": 1,
            "subscribe": 1,
            "amount": 10,
            "basis": "payout",
            "contract_type": "CALL",
            "currency": "USD",
            "duration": 1,
            "duration_unit": "m",
            "symbol": "R_100",
            "barrier": "+0.1"
        ] as [String: Any]
        
        if let proposalData = try? JSONSerialization.data(withJSONObject: proposalRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(proposalData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send proposal subscription: \(error.localizedDescription)")
                } else {
                    print("Proposal subscription sent.")
                }
            }
        }
    }
    
    // Function to send a ping message every 30 seconds
    func startPing() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            let pingMessage = URLSessionWebSocketTask.Message.string("{\"ping\": 1}")
            webSocketTask?.send(pingMessage) { error in
                if let error = error {
                    print("[error] Failed to send ping: \(error.localizedDescription)")
                } else {
                    print("Ping sent to keep connection alive.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the proposal and ping response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "proposal", let proposal = data["proposal"] as? [String: Any] {
            print("Details: \(proposal["longcode"] ?? "")")
            print("Ask Price: \(proposal["display_value"] ?? "")")
            print("Payout: \(proposal["payout"] ?? "")")
            print("Spot: \(proposal["spot"] ?? "")")
        } else if data["msg_type"] as? String == "ping" {
            print("[Ping] Ping response received.")
        }
    }
    
    // Start sending the proposal subscription and pinging the server
    sendProposalSubscription()
    startPing()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
 * Instructions to Run:
 * 1. Ensure Swift is installed on your machine.
 * 2. Save this code in a file, for example, `WebSocketClient.swift`.
 * 3. Open a terminal, navigate to the directory where you saved the file, and run:
 *      swift WebSocketClient.swift
 * 4. The script connects to the WebSocket server, sends a proposal subscription, and sends a ping every 30 seconds to keep the connection alive.
 */
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a proposal subscription request
    func sendProposalSubscription() {
        let proposalRequest = [
            "proposal": 1,
            "subscribe": 1,
            "amount": 10,
            "basis": "payout",
            "contract_type": "CALL",
            "currency": "USD",
            "duration": 1,
            "duration_unit": "m",
            "symbol": "R_100",
            "barrier": "+0.1"
        ] as [String: Any]
        
        if let proposalData = try? JSONSerialization.data(withJSONObject: proposalRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(proposalData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send proposal subscription: \(error.localizedDescription)")
                } else {
                    print("Proposal subscription sent.")
                }
            }
        }
    }
    
    // Function to send a ping message every 30 seconds
    func startPing() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            let pingMessage = URLSessionWebSocketTask.Message.string("{\"ping\": 1}")
            webSocketTask?.send(pingMessage) { error in
                if let error = error {
                    print("[error] Failed to send ping: \(error.localizedDescription)")
                } else {
                    print("Ping sent to keep connection alive.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the proposal and ping response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "proposal", let proposal = data["proposal"] as? [String: Any] {
            print("Details: \(proposal["longcode"] ?? "")")
            print("Ask Price: \(proposal["display_value"] ?? "")")
            print("Payout: \(proposal["payout"] ?? "")")
            print("Spot: \(proposal["spot"] ?? "")")
        } else if data["msg_type"] as? String == "ping" {
            print("[Ping] Ping response received.")
        }
    }
    
    // Start sending the proposal subscription and pinging the server
    sendProposalSubscription()
    startPing()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
 * Instructions to Run:
 * 1. Ensure Swift is installed on your machine.
 * 2. Save this code in a file, for example, `WebSocketClient.swift`.
 * 3. Open a terminal, navigate to the directory where you saved the file, and run:
 *      swift WebSocketClient.swift
 * 4. The script connects to the WebSocket server, sends a proposal subscription, and sends a ping every 30 seconds to keep the connection alive.
 */
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{time::interval, sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[open] Connection established");

    // Proposal request JSON
    let proposal_request = json!({
        "proposal": 1,
        "subscribe": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    });

    // Clone `socket` for the ping task and start pinging every 30 seconds
    let ping_socket = Arc::clone(&socket);
    let ping_task = spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            let mut socket = ping_socket.lock().await;
            if socket.send(Message::Text(json!({ "ping": 1 }).to_string())).await.is_ok() {
                println!("[ping] Ping sent to keep connection alive.");
            }
        }
    });

    // Clone `socket` for sending the proposal
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(proposal_request.to_string())).await.is_ok() {
            println!("Proposal subscription sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if let Some(proposal) = data.get("proposal") {
                        println!("Details: {}", proposal["longcode"]);
                        println!("Ask Price: {}", proposal["display_value"]);
                        println!("Payout: {}", proposal["payout"]);
                        println!("Spot: {}", proposal["spot"]);
                    } else if data.get("msg_type").unwrap_or(&json!("")) == "ping" {
                        println!("[Ping] Ping response received.");
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(ping_task, send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{time::interval, sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[open] Connection established");

    // Proposal request JSON
    let proposal_request = json!({
        "proposal": 1,
        "subscribe": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    });

    // Clone `socket` for the ping task and start pinging every 30 seconds
    let ping_socket = Arc::clone(&socket);
    let ping_task = spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            let mut socket = ping_socket.lock().await;
            if socket.send(Message::Text(json!({ "ping": 1 }).to_string())).await.is_ok() {
                println!("[ping] Ping sent to keep connection alive.");
            }
        }
    });

    // Clone `socket` for sending the proposal
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(proposal_request.to_string())).await.is_ok() {
            println!("Proposal subscription sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if let Some(proposal) = data.get("proposal") {
                        println!("Details: {}", proposal["longcode"]);
                        println!("Ask Price: {}", proposal["display_value"]);
                        println!("Payout: {}", proposal["payout"]);
                        println!("Spot: {}", proposal["spot"]);
                    } else if data.get("msg_type").unwrap_or(&json!("")) == "ping" {
                        println!("[Ping] Ping response received.");
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(ping_task, send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a proposal subscription request
    $proposal_request = json_encode([
        "proposal" => 1,
        "subscribe" => 1,
        "amount" => 10,
        "basis" => "payout",
        "contract_type" => "CALL",
        "currency" => "USD",
        "duration" => 1,
        "duration_unit" => "m",
        "symbol" => "R_100",
        "barrier" => "+0.1"
    ]);
    $client->send($proposal_request);
    echo "[sent] Proposal subscription sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "proposal") {
            $proposal = $data["proposal"];
            echo "[proposal] Details: {$proposal['longcode']}\n";
            echo "[proposal] Ask Price: {$proposal['display_value']}\n";
            echo "[proposal] Payout: {$proposal['payout']}\n";
            echo "[proposal] Spot: {$proposal['spot']}\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `websocket_client.php`.
6. Run the code from the command line:

   php websocket_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a proposal subscription request
    $proposal_request = json_encode([
        "proposal" => 1,
        "subscribe" => 1,
        "amount" => 10,
        "basis" => "payout",
        "contract_type" => "CALL",
        "currency" => "USD",
        "duration" => 1,
        "duration_unit" => "m",
        "symbol" => "R_100",
        "barrier" => "+0.1"
    ]);
    $client->send($proposal_request);
    echo "[sent] Proposal subscription sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "proposal") {
            $proposal = $data["proposal"];
            echo "[proposal] Details: {$proposal['longcode']}\n";
            echo "[proposal] Ask Price: {$proposal['display_value']}\n";
            echo "[proposal] Payout: {$proposal['payout']}\n";
            echo "[proposal] Spot: {$proposal['spot']}\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `websocket_client.php`.
6. Run the code from the command line:

   php websocket_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// Define constants
const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//Replace with your app_id
)

// ProposalRequest defines the structure of the proposal subscription request
type ProposalRequest struct {
	Proposal      int    `json:"proposal"`
	Subscribe     int    `json:"subscribe"`
	Amount        int    `json:"amount"`
	Basis         string `json:"basis"`
	ContractType  string `json:"contract_type"`
	Currency      string `json:"currency"`
	Duration      int    `json:"duration"`
	DurationUnit  string `json:"duration_unit"`
	Symbol        string `json:"symbol"`
	Barrier       string `json:"barrier"`
}

func main() {
	// Set up WebSocket connection context
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish a WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("WebSocket connection established.")

	// Send initial proposal subscription request
	err = sendProposalRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send proposal request: %v", err)
	}

	// Start keep-alive ping
	go keepAlivePing(ctx, conn)

	// Handle incoming messages
	handleResponses(ctx, conn)
}

// sendProposalRequest sends a proposal subscription request to the WebSocket server
func sendProposalRequest(ctx context.Context, conn *websocket.Conn) error {
	// Construct proposal subscription request
	proposal := ProposalRequest{
		Proposal:     1,
		Subscribe:    1,
		Amount:       10,
		Basis:        "payout",
		ContractType: "CALL",
		Currency:     "USD",
		Duration:     1,
		DurationUnit: "m",
		Symbol:       "R_100",
		Barrier:      "+0.1",
	}
	fmt.Println("Sending proposal subscription...")

	return wsjson.Write(ctx, conn, proposal)
}

// keepAlivePing sends a ping message every 30 seconds to keep the connection alive
func keepAlivePing(ctx context.Context, conn *websocket.Conn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Send ping message
			pingMsg := map[string]int{"ping": 1}
			err := wsjson.Write(ctx, conn, pingMsg)
			if err != nil {
				log.Printf("Ping failed: %v", err)
				return
			}
			fmt.Println("Ping sent.")
		case <-ctx.Done():
			return
		}
	}
}

// handleResponses listens for and processes messages received from the WebSocket server
func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}
		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		// Process response messages
		msgType := response["msg_type"]
		switch msgType {
		case "proposal":
			// Print proposal details
			proposal := response["proposal"].(map[string]interface{})
			fmt.Printf("Details: %v\n", proposal["longcode"])
			fmt.Printf("Ask Price: %v\n", proposal["display_value"])
			fmt.Printf("Payout: %v\n", proposal["payout"])
			fmt.Printf("Spot: %v\n", proposal["spot"])
		case "ping":
			fmt.Println("[Ping] Ping response received.")
		default:
			fmt.Printf("Received message: %v\n", response)
		}
	}
}

/*
Instructions to run the code locally:

1. Install Go: Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.

2. Save the code:
   - Save this code into a file named `connect.go`.

3. Initialize a Go module:
   - Open a terminal in the directory containing `connect.go`.
   - Run `go mod init app` to initialize a new Go module.
   - Run `go get nhooyr.io/websocket` to install the WebSocket package dependency.

4. Run the code:
   - Execute the code using the command `go run connect.go`.
   - Alternatively, you can build and run the executable:
     ```
     go build -o connect connect.go
     ./connect
     ```
5. Replace `app_id=1089` with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// Define constants
const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//Replace with your app_id
)

// ProposalRequest defines the structure of the proposal subscription request
type ProposalRequest struct {
	Proposal      int    `json:"proposal"`
	Subscribe     int    `json:"subscribe"`
	Amount        int    `json:"amount"`
	Basis         string `json:"basis"`
	ContractType  string `json:"contract_type"`
	Currency      string `json:"currency"`
	Duration      int    `json:"duration"`
	DurationUnit  string `json:"duration_unit"`
	Symbol        string `json:"symbol"`
	Barrier       string `json:"barrier"`
}

func main() {
	// Set up WebSocket connection context
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish a WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("WebSocket connection established.")

	// Send initial proposal subscription request
	err = sendProposalRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send proposal request: %v", err)
	}

	// Start keep-alive ping
	go keepAlivePing(ctx, conn)

	// Handle incoming messages
	handleResponses(ctx, conn)
}

// sendProposalRequest sends a proposal subscription request to the WebSocket server
func sendProposalRequest(ctx context.Context, conn *websocket.Conn) error {
	// Construct proposal subscription request
	proposal := ProposalRequest{
		Proposal:     1,
		Subscribe:    1,
		Amount:       10,
		Basis:        "payout",
		ContractType: "CALL",
		Currency:     "USD",
		Duration:     1,
		DurationUnit: "m",
		Symbol:       "R_100",
		Barrier:      "+0.1",
	}
	fmt.Println("Sending proposal subscription...")

	return wsjson.Write(ctx, conn, proposal)
}

// keepAlivePing sends a ping message every 30 seconds to keep the connection alive
func keepAlivePing(ctx context.Context, conn *websocket.Conn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Send ping message
			pingMsg := map[string]int{"ping": 1}
			err := wsjson.Write(ctx, conn, pingMsg)
			if err != nil {
				log.Printf("Ping failed: %v", err)
				return
			}
			fmt.Println("Ping sent.")
		case <-ctx.Done():
			return
		}
	}
}

// handleResponses listens for and processes messages received from the WebSocket server
func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}
		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		// Process response messages
		msgType := response["msg_type"]
		switch msgType {
		case "proposal":
			// Print proposal details
			proposal := response["proposal"].(map[string]interface{})
			fmt.Printf("Details: %v\n", proposal["longcode"])
			fmt.Printf("Ask Price: %v\n", proposal["display_value"])
			fmt.Printf("Payout: %v\n", proposal["payout"])
			fmt.Printf("Spot: %v\n", proposal["spot"])
		case "ping":
			fmt.Println("[Ping] Ping response received.")
		default:
			fmt.Printf("Received message: %v\n", response)
		}
	}
}

/*
Instructions to run the code locally:

1. Install Go: Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.

2. Save the code:
   - Save this code into a file named `connect.go`.

3. Initialize a Go module:
   - Open a terminal in the directory containing `connect.go`.
   - Run `go mod init app` to initialize a new Go module.
   - Run `go get nhooyr.io/websocket` to install the WebSocket package dependency.

4. Run the code:
   - Execute the code using the command `go run connect.go`.
   - Alternatively, you can build and run the executable:
     ```
     go build -o connect connect.go
     ./connect
     ```
5. Replace `app_id=1089` with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed
    private static readonly int pingInterval = 30000; // Ping every 30 seconds

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("WebSocket connection established.");

            // Send initial proposal subscription request
            await SendProposalSubscription(webSocket);

            // Start a task to send pings to keep connection alive
            Task keepAlivePingTask = KeepAlivePing(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);

            // Ensure the keep-alive ping task finishes
            await keepAlivePingTask;
        }
    }

    private static async Task SendProposalSubscription(ClientWebSocket webSocket)
    {
        var proposalRequest = new
        {
            proposal = 1,
            subscribe = 1,
            amount = 10,
            basis = "payout",
            contract_type = "CALL",
            currency = "USD",
            duration = 1,
            duration_unit = "m",
            symbol = "R_100",
            barrier = "+0.1"
        };

        string requestJson = JsonSerializer.Serialize(proposalRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("Proposal subscription sent.");
    }

    private static async Task KeepAlivePing(ClientWebSocket webSocket)
    {
        while (webSocket.State == WebSocketState.Open)
        {
            await Task.Delay(pingInterval);

            var pingRequest = new { ping = 1 };
            string pingJson = JsonSerializer.Serialize(pingRequest);
            var pingBytes = Encoding.UTF8.GetBytes(pingJson);
            await webSocket.SendAsync(new ArraySegment<byte>(pingBytes), WebSocketMessageType.Text, true, CancellationToken.None);
            Console.WriteLine("Ping sent to keep connection alive.");
        }
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[1024 * 4];

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        else
        {
            string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
            var data = JsonSerializer.Deserialize<JsonElement>(response);

            if (data.TryGetProperty("error", out var error))
            {
                Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                break;
            }

            if (data.TryGetProperty("msg_type", out var msgType))
            {
                if (msgType.GetString() == "proposal")
                {
                    var proposal = data.GetProperty("proposal");

                    // Extract proposal details with type-checking
                    string longcode = proposal.GetProperty("longcode").GetString();
                    Console.WriteLine($"Details: {longcode}");

                    string displayValue = proposal.GetProperty("display_value").GetRawText();
                    Console.WriteLine($"Ask Price: {displayValue}");

                    string payout = proposal.GetProperty("payout").GetRawText();
                    Console.WriteLine($"Payout: {payout}");

                    string spot = proposal.GetProperty("spot").GetRawText();
                    Console.WriteLine($"Spot: {spot}");
                }
                else if (msgType.GetString() == "ping")
                {
                    Console.WriteLine("[Ping] Ping response received.");
                }
            }
        }
    }
}
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed
    private static readonly int pingInterval = 30000; // Ping every 30 seconds

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("WebSocket connection established.");

            // Send initial proposal subscription request
            await SendProposalSubscription(webSocket);

            // Start a task to send pings to keep connection alive
            Task keepAlivePingTask = KeepAlivePing(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);

            // Ensure the keep-alive ping task finishes
            await keepAlivePingTask;
        }
    }

    private static async Task SendProposalSubscription(ClientWebSocket webSocket)
    {
        var proposalRequest = new
        {
            proposal = 1,
            subscribe = 1,
            amount = 10,
            basis = "payout",
            contract_type = "CALL",
            currency = "USD",
            duration = 1,
            duration_unit = "m",
            symbol = "R_100",
            barrier = "+0.1"
        };

        string requestJson = JsonSerializer.Serialize(proposalRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("Proposal subscription sent.");
    }

    private static async Task KeepAlivePing(ClientWebSocket webSocket)
    {
        while (webSocket.State == WebSocketState.Open)
        {
            await Task.Delay(pingInterval);

            var pingRequest = new { ping = 1 };
            string pingJson = JsonSerializer.Serialize(pingRequest);
            var pingBytes = Encoding.UTF8.GetBytes(pingJson);
            await webSocket.SendAsync(new ArraySegment<byte>(pingBytes), WebSocketMessageType.Text, true, CancellationToken.None);
            Console.WriteLine("Ping sent to keep connection alive.");
        }
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[1024 * 4];

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        else
        {
            string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
            var data = JsonSerializer.Deserialize<JsonElement>(response);

            if (data.TryGetProperty("error", out var error))
            {
                Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                break;
            }

            if (data.TryGetProperty("msg_type", out var msgType))
            {
                if (msgType.GetString() == "proposal")
                {
                    var proposal = data.GetProperty("proposal");

                    // Extract proposal details with type-checking
                    string longcode = proposal.GetProperty("longcode").GetString();
                    Console.WriteLine($"Details: {longcode}");

                    string displayValue = proposal.GetProperty("display_value").GetRawText();
                    Console.WriteLine($"Ask Price: {displayValue}");

                    string payout = proposal.GetProperty("payout").GetRawText();
                    Console.WriteLine($"Payout: {payout}");

                    string spot = proposal.GetProperty("spot").GetRawText();
                    Console.WriteLine($"Spot: {spot}");
                }
                else if (msgType.GetString() == "ping")
                {
                    Console.WriteLine("[Ping] Ping response received.");
                }
            }
        }
    }
}
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>
#include <time.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a proposal subscription message
void send_proposal(struct lws *wsi) {
    const char *proposal_msg = "{\"proposal\": 1, \"subscribe\": 1, \"amount\": 10, \"basis\": \"payout\", \"contract_type\": \"CALL\", \"currency\": \"USD\", \"duration\": 1, \"duration_unit\": \"m\", \"symbol\": \"R_100\", \"barrier\": \"+0.1\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], proposal_msg, strlen(proposal_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(proposal_msg), LWS_WRITE_TEXT);
    lwsl_user("Proposal subscription sent\n");
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_proposal(wsi);  // Send proposal on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>
#include <time.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a proposal subscription message
void send_proposal(struct lws *wsi) {
    const char *proposal_msg = "{\"proposal\": 1, \"subscribe\": 1, \"amount\": 10, \"basis\": \"payout\", \"contract_type\": \"CALL\", \"currency\": \"USD\", \"duration\": 1, \"duration_unit\": \"m\", \"symbol\": \"R_100\", \"barrier\": \"+0.1\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], proposal_msg, strlen(proposal_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(proposal_msg), LWS_WRITE_TEXT);
    lwsl_user("Proposal subscription sent\n");
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_proposal(wsi);  // Send proposal on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
import asyncio
from deriv_api import DerivAPI
from deriv_api.subscription_manager import SubscriptionManager

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    # Initialize the SubscriptionManager
    subscription_manager = SubscriptionManager(api)

    # Define the proposal request
    proposal_request = {
        "proposal": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    }

    # Subscribe to the proposal stream
    try:
        proposal_stream = await subscription_manager.subscribe(proposal_request)
        print("Subscribed to proposal stream")

        # Handle incoming messages and print formatted proposal details
        proposal_stream.subscribe(
            on_next=lambda message: print_proposal_details(message),
            on_error=lambda e: print(f"Error: {e}"),
            on_completed=lambda: print("Subscription completed")
        )

        # Function to send a ping every 30 seconds
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop and proposal subscription concurrently
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print proposal details
def print_proposal_details(message):
    data = message.get("proposal", {})
    if data:
        print(f"Details: {data.get('longcode', 'N/A')}")
        print(f"Ask Price: {data.get('display_value', 'N/A')}")
        print(f"Payout: {data.get('payout', 'N/A')}")
        print(f"Spot: {data.get('spot', 'N/A')}")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

"""
Instructions to run this code:

1. **Install the Required Library**:
   - Ensure that `python-deriv-api` is installed. If not, install it using:
     ```
     pip install python-deriv-api
     ```
2. **Save and Run the Code**:
   - Save this code to a file, e.g., `connect.py`.
   - Run the script using:
     ```
     python connect.py
     ```
3. **Configuration**:
   - Replace the `app_id` variable with your actual Deriv app ID if needed.

This script will connect to the Deriv API WebSocket, subscribe to a proposal stream, print proposal details, and send a ping every 30 seconds to keep the connection active. 
"""
```

```text
import asyncio
from deriv_api import DerivAPI
from deriv_api.subscription_manager import SubscriptionManager

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    # Initialize the SubscriptionManager
    subscription_manager = SubscriptionManager(api)

    # Define the proposal request
    proposal_request = {
        "proposal": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    }

    # Subscribe to the proposal stream
    try:
        proposal_stream = await subscription_manager.subscribe(proposal_request)
        print("Subscribed to proposal stream")

        # Handle incoming messages and print formatted proposal details
        proposal_stream.subscribe(
            on_next=lambda message: print_proposal_details(message),
            on_error=lambda e: print(f"Error: {e}"),
            on_completed=lambda: print("Subscription completed")
        )

        # Function to send a ping every 30 seconds
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop and proposal subscription concurrently
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print proposal details
def print_proposal_details(message):
    data = message.get("proposal", {})
    if data:
        print(f"Details: {data.get('longcode', 'N/A')}")
        print(f"Ask Price: {data.get('display_value', 'N/A')}")
        print(f"Payout: {data.get('payout', 'N/A')}")
        print(f"Spot: {data.get('spot', 'N/A')}")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

"""
Instructions to run this code:

1. **Install the Required Library**:
   - Ensure that `python-deriv-api` is installed. If not, install it using:
     ```
     pip install python-deriv-api
     ```
2. **Save and Run the Code**:
   - Save this code to a file, e.g., `connect.py`.
   - Run the script using:
     ```
     python connect.py
     ```
3. **Configuration**:
   - Replace the `app_id` variable with your actual Deriv app ID if needed.

This script will connect to the Deriv API WebSocket, subscribe to a proposal stream, print proposal details, and send a ping every 30 seconds to keep the connection active. 
"""
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Define a ping interval in seconds
my $ping_interval = 30;

# Function to send a proposal subscription request
sub send_proposal {
    my $connection = shift;
    my $proposal_request = encode_json({
        proposal       => 1,
        subscribe      => 1,
        amount         => 10,
        basis          => 'payout',
        contract_type  => 'CALL',
        currency       => 'USD',
        duration       => 1,
        duration_unit  => 'm',
        symbol         => 'R_100',
        barrier        => '+0.1'
    });
    $connection->send($proposal_request);
    say "Proposal subscription sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "WebSocket connection established.";

    # Set up a repeating timer to send ping every 30 seconds
    my $ping_timer = AnyEvent->timer(
        after    => $ping_interval,
        interval => $ping_interval,
        cb       => sub {
            $connection->send(encode_json({ ping => 1 }));
            say "Ping sent to keep connection alive.";
        }
    );

    # Send the initial proposal subscription
    send_proposal($connection);

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;
        my $data = decode_json($message->body);

        # Handle errors
        if ($data->{error}) {
            say "[Error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle proposal messages
        if ($data->{msg_type} && $data->{msg_type} eq 'proposal') {
            my $proposal = $data->{proposal};
            say "Details: $proposal->{longcode}";
            say "Ask Price: $proposal->{display_value}";
            say "Payout: $proposal->{payout}";
            say "Spot: $proposal->{spot}";
        } elsif ($data->{msg_type} && $data->{msg_type} eq 'ping') {
            say "[Ping] Ping response received.";
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
        $ping_timer = undef;  # Stop the ping timer
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Define a ping interval in seconds
my $ping_interval = 30;

# Function to send a proposal subscription request
sub send_proposal {
    my $connection = shift;
    my $proposal_request = encode_json({
        proposal       => 1,
        subscribe      => 1,
        amount         => 10,
        basis          => 'payout',
        contract_type  => 'CALL',
        currency       => 'USD',
        duration       => 1,
        duration_unit  => 'm',
        symbol         => 'R_100',
        barrier        => '+0.1'
    });
    $connection->send($proposal_request);
    say "Proposal subscription sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "WebSocket connection established.";

    # Set up a repeating timer to send ping every 30 seconds
    my $ping_timer = AnyEvent->timer(
        after    => $ping_interval,
        interval => $ping_interval,
        cb       => sub {
            $connection->send(encode_json({ ping => 1 }));
            say "Ping sent to keep connection alive.";
        }
    );

    # Send the initial proposal subscription
    send_proposal($connection);

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;
        my $data = decode_json($message->body);

        # Handle errors
        if ($data->{error}) {
            say "[Error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle proposal messages
        if ($data->{msg_type} && $data->{msg_type} eq 'proposal') {
            my $proposal = $data->{proposal};
            say "Details: $proposal->{longcode}";
            say "Ask Price: $proposal->{display_value}";
            say "Payout: $proposal->{payout}";
            say "Spot: $proposal->{spot}";
        } elsif ($data->{msg_type} && $data->{msg_type} eq 'ping') {
            say "[Ping] Ping response received.";
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
        $ping_timer = undef;  # Stop the ping timer
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

**Key Topics:**
- Import the Deriv API library
- Establish a WebSocket connection
- Create an API object
- Send a proposal subscription
- Send ping to keep the connection alive
- Handle WebSocket responses
- Start the signal processing
- End the WebSocket subscription

**Content Summary:**
Follow these steps to maintain a live WebSocket connection with the Deriv API:

Import the Deriv API library

Import the DerivAPIBasic library, which provides an interface to interact with the Deriv WebSocket API:

import DerivAPIBasic from 'https://cdn.skypack.dev/@deriv/deriv-api/dist/DerivAPIBasic';

Establish a WebSocket connection

Create a WebSocket connection using your app_id and the API URL:

(wss://ws.derivws.com/websockets/v3?app_id=${app_id}).

This connection will be used to send and receive messages from the Deriv API.

const connection = new WebSocket(wss://ws.derivws.com/websockets/v3?app_id=${app_id});

Create an API object

Create an instance of DerivAPIBasic, passing the WebSocket connection as a parameter.

This object interacts with the API, such as subscribing to proposals and sending pings.

const api = new DerivAPIBasic({ connection });

Send a proposal subscription

The proposal() function subscribes to a proposal and sends details such as the trade amount, cur...

---

### Check website status
**URL:** https://developers.deriv.com/docs/check-website-status

**Code Examples:**
```text
DerivAPIBasic
```

```text
app_id
```

```text
DerivAPIBasic
```

```text
websiteStatusResponse
```

```text
getWebsiteStatus
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication,replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the website status response
const handleWebsiteStatusResponse = async (response) => {
  const data = JSON.parse(response.data);

  // If there's an error in the response, log the error message and disconnect
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'website_status', log the relevant details
  if (data.msg_type === 'website_status') {
    const websiteStatus = data.website_status;
    console.log('Website Status:', websiteStatus.site_status);
    console.log('Available Languages:', websiteStatus.supported_languages);
    console.log('Terms & Conditions Version:', websiteStatus.terms_conditions_version);
    console.log('Broker Codes:', websiteStatus.broker_codes);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleWebsiteStatusResponse);
};

// Function to request website status from the API
const requestWebsiteStatus = async () => {
  connection.addEventListener('message', handleWebsiteStatusResponse); // Add the event listener for response
  await api.websiteStatus(); // Send the website status request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const website_status_button = document.querySelector('#websiteStatus');
  if (website_status_button) {
    website_status_button.addEventListener('click', requestWebsiteStatus);
  }
} else {
  // If running in Node.js, directly call the function
  requestWebsiteStatus();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `connect.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node connect.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="websiteStatus">Check Website Status</button>`
 * - Open the HTML file in a browser, and click the button to check the website status.
 */
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication,replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the website status response
const handleWebsiteStatusResponse = async (response) => {
  const data = JSON.parse(response.data);

  // If there's an error in the response, log the error message and disconnect
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'website_status', log the relevant details
  if (data.msg_type === 'website_status') {
    const websiteStatus = data.website_status;
    console.log('Website Status:', websiteStatus.site_status);
    console.log('Available Languages:', websiteStatus.supported_languages);
    console.log('Terms & Conditions Version:', websiteStatus.terms_conditions_version);
    console.log('Broker Codes:', websiteStatus.broker_codes);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleWebsiteStatusResponse);
};

// Function to request website status from the API
const requestWebsiteStatus = async () => {
  connection.addEventListener('message', handleWebsiteStatusResponse); // Add the event listener for response
  await api.websiteStatus(); // Send the website status request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const website_status_button = document.querySelector('#websiteStatus');
  if (website_status_button) {
    website_status_button.addEventListener('click', requestWebsiteStatus);
  }
} else {
  // If running in Node.js, directly call the function
  requestWebsiteStatus();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `connect.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node connect.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="websiteStatus">Check Website Status</button>`
 * - Open the HTML file in a browser, and click the button to check the website status.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send website status request
                    JsonObject websiteStatusRequest = new JsonObject();
                    websiteStatusRequest.addProperty("website_status", 1);
                    send(websiteStatusRequest.toString());
                    System.out.println("[sent] Website status request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("website_status".equals(data.get("msg_type").getAsString())) {
                        JsonObject websiteStatus = data.getAsJsonObject("website_status");
                        String siteStatus = websiteStatus.get("site_status").getAsString();
                        System.out.println("Website Status: " + siteStatus);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.


 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send website status request
                    JsonObject websiteStatusRequest = new JsonObject();
                    websiteStatusRequest.addProperty("website_status", 1);
                    send(websiteStatusRequest.toString());
                    System.out.println("[sent] Website status request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("website_status".equals(data.get("msg_type").getAsString())) {
                        JsonObject websiteStatus = data.getAsJsonObject("website_status");
                        String siteStatus = websiteStatus.get("site_status").getAsString();
                        System.out.println("Website Status: " + siteStatus);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.


 */
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a website status request
sub send_website_status {
    my $connection = shift;
    my $website_status_request = encode_json({ website_status => 1 });
    $connection->send($website_status_request);
    say "[status] Website status request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send website status request immediately
    send_website_status($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle website status response
        if ($data->{msg_type} && $data->{msg_type} eq 'website_status') {
            my $website_status = $data->{website_status};
            say "Site Status: " . ($website_status->{site_status} // 'Unknown');
            say "Supported Languages: " . join(", ", @{$website_status->{supported_languages}});
            $connection->close; # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, request the website status, and print the response.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a website status request
sub send_website_status {
    my $connection = shift;
    my $website_status_request = encode_json({ website_status => 1 });
    $connection->send($website_status_request);
    say "[status] Website status request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send website status request immediately
    send_website_status($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle website status response
        if ($data->{msg_type} && $data->{msg_type} eq 'website_status') {
            my $website_status = $data->{website_status};
            say "Site Status: " . ($website_status->{site_status} // 'Unknown');
            say "Supported Languages: " . join(", ", @{$website_status->{supported_languages}});
            $connection->close; # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, request the website status, and print the response.
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a website status request
    $website_status_request = json_encode(["website_status" => 1]);
    $client->send($website_status_request);
    echo "[sent] Website status request sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "website_status") {
            $website_status = $data["website_status"];

            // Print important information from the website status
            echo "[status] Website Status:\n";
            echo "  - Site Status: " . ($website_status["site_status"] ?? "N/A") . "\n";
            echo "  - Supported Languages: " . implode(", ", $website_status["supported_languages"] ?? []) . "\n";

            // Extract and print currency information
            echo "  - Currencies Config:\n";
            foreach ($website_status["currencies_config"] ?? [] as $currency => $config) {
                echo "    * {$currency} ({$config['name']}):\n";
                echo "      - Type: " . ($config["type"] ?? "N/A") . "\n";
                echo "      - Fractional Digits: " . ($config["fractional_digits"] ?? "N/A") . "\n";
                echo "      - Deposit Suspended: " . ($config["is_deposit_suspended"] ? "Yes" : "No") . "\n";
                echo "      - Withdrawal Suspended: " . ($config["is_withdrawal_suspended"] ? "Yes" : "No") . "\n";
            }

            echo "[status] End of Website Status Response.\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `website_status_client.php`.
6. Run the code from the command line:

   php website_status_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a website status request
    $website_status_request = json_encode(["website_status" => 1]);
    $client->send($website_status_request);
    echo "[sent] Website status request sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "website_status") {
            $website_status = $data["website_status"];

            // Print important information from the website status
            echo "[status] Website Status:\n";
            echo "  - Site Status: " . ($website_status["site_status"] ?? "N/A") . "\n";
            echo "  - Supported Languages: " . implode(", ", $website_status["supported_languages"] ?? []) . "\n";

            // Extract and print currency information
            echo "  - Currencies Config:\n";
            foreach ($website_status["currencies_config"] ?? [] as $currency => $config) {
                echo "    * {$currency} ({$config['name']}):\n";
                echo "      - Type: " . ($config["type"] ?? "N/A") . "\n";
                echo "      - Fractional Digits: " . ($config["fractional_digits"] ?? "N/A") . "\n";
                echo "      - Deposit Suspended: " . ($config["is_deposit_suspended"] ? "Yes" : "No") . "\n";
                echo "      - Withdrawal Suspended: " . ($config["is_withdrawal_suspended"] ? "Yes" : "No") . "\n";
            }

            echo "[status] End of Website Status Response.\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `website_status_client.php`.
6. Run the code from the command line:

   php website_status_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a website status request
        website_status_request = {"website_status": 1}
        response = await api.send(website_status_request)
        print("Website status request sent")

        # Process the response and print important information
        print_website_status(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print website status details
def print_website_status(response):
    data = response.get("website_status", {})
    if data:
        print("[Website Status]")
        print(f"  - Site Status: {data.get('site_status', 'N/A')}")
        print("  - Supported Languages:", ", ".join(data.get("supported_languages", [])))

        # Display currency configurations
        currencies_config = data.get("currencies_config", {})
        print("  - Currencies Config:")
        for currency, config in currencies_config.items():
            print(f"    * {currency} ({config.get('name', 'N/A')}):")
            print(f"      - Type: {config.get('type', 'N/A')}")
            print(f"      - Fractional Digits: {config.get('fractional_digits', 'N/A')}")
            print(f"      - Deposit Suspended: {'Yes' if config.get('is_deposit_suspended') else 'No'}")
            print(f"      - Withdrawal Suspended: {'Yes' if config.get('is_withdrawal_suspended') else 'No'}")
        print("[End of Website Status Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `website_status_client.py`.
# 4. Run the code from the command line:
#      python website_status_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request the website status, and send pings every 30 seconds to keep the connection alive.
# The response includes important details about the website status and configuration for each currency.
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a website status request
        website_status_request = {"website_status": 1}
        response = await api.send(website_status_request)
        print("Website status request sent")

        # Process the response and print important information
        print_website_status(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print website status details
def print_website_status(response):
    data = response.get("website_status", {})
    if data:
        print("[Website Status]")
        print(f"  - Site Status: {data.get('site_status', 'N/A')}")
        print("  - Supported Languages:", ", ".join(data.get("supported_languages", [])))

        # Display currency configurations
        currencies_config = data.get("currencies_config", {})
        print("  - Currencies Config:")
        for currency, config in currencies_config.items():
            print(f"    * {currency} ({config.get('name', 'N/A')}):")
            print(f"      - Type: {config.get('type', 'N/A')}")
            print(f"      - Fractional Digits: {config.get('fractional_digits', 'N/A')}")
            print(f"      - Deposit Suspended: {'Yes' if config.get('is_deposit_suspended') else 'No'}")
            print(f"      - Withdrawal Suspended: {'Yes' if config.get('is_withdrawal_suspended') else 'No'}")
        print("[End of Website Status Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `website_status_client.py`.
# 4. Run the code from the command line:
#      python website_status_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request the website status, and send pings every 30 seconds to keep the connection alive.
# The response includes important details about the website status and configuration for each currency.
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Website status request JSON
    let website_status_request = json!({
        "website_status": 1
    });

    // Clone `socket` to send the website status request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(website_status_request.to_string())).await.is_ok() {
            println!("[status] Website status request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "website_status" {
                        println!("[Website Status] Site Status: {}", data["website_status"]["site_status"]);
                        let supported_languages: Vec<String> = data["website_status"]["supported_languages"]
                            .as_array()
                            .unwrap_or(&vec![])
                            .iter()
                            .filter_map(|lang| lang.as_str().map(|s| s.to_string()))
                            .collect();
                        println!("Supported Languages: {:?}", supported_languages);
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request the website status, print the website's status, supported languages, and handle any potential errors in the response.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Website status request JSON
    let website_status_request = json!({
        "website_status": 1
    });

    // Clone `socket` to send the website status request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(website_status_request.to_string())).await.is_ok() {
            println!("[status] Website status request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "website_status" {
                        println!("[Website Status] Site Status: {}", data["website_status"]["site_status"]);
                        let supported_languages: Vec<String> = data["website_status"]["supported_languages"]
                            .as_array()
                            .unwrap_or(&vec![])
                            .iter()
                            .filter_map(|lang| lang.as_str().map(|s| s.to_string()))
                            .collect();
                        println!("Supported Languages: {:?}", supported_languages);
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request the website status, print the website's status, supported languages, and handle any potential errors in the response.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run the code:

1. Ensure Swift is installed on your machine. You can use Xcode or install the Swift toolchain from https://swift.org/.
2. Create a new Swift file (e.g., `WebSocketClient.swift`) and paste the code above.
3. Open a terminal and navigate to the directory where the file is saved.
4. Run the code with the following command:

   swift WebSocketClient.swift

5. The program will connect to the Deriv WebSocket API, request the website status, and print the site's operational status and supported languages.
6. To stop the program, press `Ctrl+C` in the terminal.

Note: Replace `app_id` with your actual app_id if required.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run the code:

1. Ensure Swift is installed on your machine. You can use Xcode or install the Swift toolchain from https://swift.org/.
2. Create a new Swift file (e.g., `WebSocketClient.swift`) and paste the code above.
3. Open a terminal and navigate to the directory where the file is saved.
4. Run the code with the following command:

   swift WebSocketClient.swift

5. The program will connect to the Deriv WebSocket API, request the website status, and print the site's operational status and supported languages.
6. To stop the program, press `Ctrl+C` in the terminal.

Note: Replace `app_id` with your actual app_id if required.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send website status request
            await SendWebsiteStatusRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendWebsiteStatusRequest(ClientWebSocket webSocket)
    {
        var websiteStatusRequest = new { website_status = 1 };

        string requestJson = JsonSerializer.Serialize(websiteStatusRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[status] Website status request sent.");
    }

 private static async Task HandleResponses(ClientWebSocket webSocket)
 {
     var buffer = new byte[8192]; // Increased buffer size

     while (webSocket.State == WebSocketState.Open)
     {
         var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

         if (result.MessageType == WebSocketMessageType.Close)
         {
             Console.WriteLine("WebSocket connection closed by server.");
             await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
         }
         else
         {
             // Append received bytes to a string builder
             var response = Encoding.UTF8.GetString(buffer, 0, result.Count);
             var data = JsonDocument.Parse(response).RootElement;

             // Check for "error" in the response
             if (data.TryGetProperty("error", out var error))
             {
                 Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                 await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                 break;
             }

             // Process the "msg_type" property
             if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "website_status")
             {
                 var websiteStatus = data.GetProperty("website_status");
                 Console.WriteLine("Site Status: " + websiteStatus.GetProperty("site_status").GetString());
                 Console.WriteLine("Supported Languages: " + websiteStatus.GetProperty("supported_languages").ToString());
             }
         }
     }
 }
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send website status request
            await SendWebsiteStatusRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendWebsiteStatusRequest(ClientWebSocket webSocket)
    {
        var websiteStatusRequest = new { website_status = 1 };

        string requestJson = JsonSerializer.Serialize(websiteStatusRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[status] Website status request sent.");
    }

 private static async Task HandleResponses(ClientWebSocket webSocket)
 {
     var buffer = new byte[8192]; // Increased buffer size

     while (webSocket.State == WebSocketState.Open)
     {
         var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

         if (result.MessageType == WebSocketMessageType.Close)
         {
             Console.WriteLine("WebSocket connection closed by server.");
             await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
         }
         else
         {
             // Append received bytes to a string builder
             var response = Encoding.UTF8.GetString(buffer, 0, result.Count);
             var data = JsonDocument.Parse(response).RootElement;

             // Check for "error" in the response
             if (data.TryGetProperty("error", out var error))
             {
                 Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                 await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                 break;
             }

             // Process the "msg_type" property
             if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "website_status")
             {
                 var websiteStatus = data.GetProperty("website_status");
                 Console.WriteLine("Site Status: " + websiteStatus.GetProperty("site_status").GetString());
                 Console.WriteLine("Supported Languages: " + websiteStatus.GetProperty("supported_languages").ToString());
             }
         }
     }
 }
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a website status request
void send_website_status_request(struct lws *wsi) {
    const char *website_status_msg = "{\"website_status\": 1}";
    unsigned char buf[LWS_PRE + 128];
    memcpy(&buf[LWS_PRE], website_status_msg, strlen(website_status_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(website_status_msg), LWS_WRITE_TEXT);
    lwsl_user("Website status request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_website_status_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "website_status"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "website_status") == 0) {
        json_t *website_status = json_object_get(root, "website_status");
        if (website_status) {
            const char *site_status = json_string_value(json_object_get(website_status, "site_status"));
            printf("Website Status: %s\n", site_status);
        }
    } else if (msg_type && strcmp(msg_type, "ping") == 0) {
        printf("Ping response received.\n");
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_website_status_request(wsi);  // Send website status request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_website_status_request(wsi);  // Periodically request website status
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_website_status_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a website status request
void send_website_status_request(struct lws *wsi) {
    const char *website_status_msg = "{\"website_status\": 1}";
    unsigned char buf[LWS_PRE + 128];
    memcpy(&buf[LWS_PRE], website_status_msg, strlen(website_status_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(website_status_msg), LWS_WRITE_TEXT);
    lwsl_user("Website status request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_website_status_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "website_status"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "website_status") == 0) {
        json_t *website_status = json_object_get(root, "website_status");
        if (website_status) {
            const char *site_status = json_string_value(json_object_get(website_status, "site_status"));
            printf("Website Status: %s\n", site_status);
        }
    } else if (msg_type && strcmp(msg_type, "ping") == 0) {
        printf("Ping response received.\n");
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_website_status_request(wsi);  // Send website status request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_website_status_request(wsi);  // Periodically request website status
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_website_status_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

**Content Summary:**
Follow these simple steps to look into general settings like call limits, currency information, supported languages and more using the Deriv API:

Import the API module: Load the DerivAPIBasic module to interact with the Deriv API.
Setup WebSocket: Establish a WebSocket connection using the app_id for authentication.
Initialize the API: Create an instance of DerivAPIBasic using the WebSocket connection.
Handle API response: Define websiteStatusResponse to process the response, handle errors, and log website status.
Request website status: Define getWebsiteStatus to send a request to the API for website status when called.
Button event listener: Attach an event listener to a button to trigger the website status request with a click.
JavaScript
Java
Perl
PHP
Python
Rust
Swift
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication,replace it with your app's ID.
const app_id = app_id;
...

---

### Get contracts for a symbol
**URL:** https://developers.deriv.com/docs/get-contracts-for-a-symbol

**Code Examples:**
```text
DerivAPIBasic
```

```text
app_id
```

```text
DerivAPIBasic
```

```text
R_50
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the contracts for symbol response
const handleContractsForSymbolResponse = async (response) => {
  const data = JSON.parse(response.data);

  // Check for errors in the response
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'contracts_for', log the contracts information
  if (data.msg_type === 'contracts_for') {
    const contractsInfo = data.contracts_for;
    console.log('Contracts for Symbol:', contractsInfo);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleContractsForSymbolResponse);
};

// Function to request contracts for a specific symbol
const getContractsForSymbol = async () => {
  const contracts_for_symbol_request = {
    contracts_for: 'R_50',   // Specify the symbol
    currency: 'USD',
    landing_company: 'svg',
    product_type: 'basic',
  };

  connection.addEventListener('message', handleContractsForSymbolResponse); // Add event listener
  await api.contractsFor(contracts_for_symbol_request); // Send the contracts request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const contracts_for_symbol_button = document.querySelector('#contractsForSymbol');
  if (contracts_for_symbol_button) {
    contracts_for_symbol_button.addEventListener('click', getContractsForSymbol);
  }
} else {
  // If running in Node.js, directly call the function
  getContractsForSymbol();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `contracts_for_symbol.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node contracts_for_symbol.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="contractsForSymbol">Get Contracts for Symbol</button>`
 * - Open the HTML file in a browser, and click the button to retrieve contracts for the symbol.
 */
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the contracts for symbol response
const handleContractsForSymbolResponse = async (response) => {
  const data = JSON.parse(response.data);

  // Check for errors in the response
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'contracts_for', log the contracts information
  if (data.msg_type === 'contracts_for') {
    const contractsInfo = data.contracts_for;
    console.log('Contracts for Symbol:', contractsInfo);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleContractsForSymbolResponse);
};

// Function to request contracts for a specific symbol
const getContractsForSymbol = async () => {
  const contracts_for_symbol_request = {
    contracts_for: 'R_50',   // Specify the symbol
    currency: 'USD',
    landing_company: 'svg',
    product_type: 'basic',
  };

  connection.addEventListener('message', handleContractsForSymbolResponse); // Add event listener
  await api.contractsFor(contracts_for_symbol_request); // Send the contracts request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const contracts_for_symbol_button = document.querySelector('#contractsForSymbol');
  if (contracts_for_symbol_button) {
    contracts_for_symbol_button.addEventListener('click', getContractsForSymbol);
  }
} else {
  // If running in Node.js, directly call the function
  getContractsForSymbol();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `contracts_for_symbol.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node contracts_for_symbol.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="contractsForSymbol">Get Contracts for Symbol</button>`
 * - Open the HTML file in a browser, and click the button to retrieve contracts for the symbol.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send contracts for symbol request
                    JsonObject contractsForSymbolRequest = new JsonObject();
                    contractsForSymbolRequest.addProperty("contracts_for", "R_50"); // Specify symbol here
                    contractsForSymbolRequest.addProperty("currency", "USD");
                    contractsForSymbolRequest.addProperty("landing_company", "svg");
                    contractsForSymbolRequest.addProperty("product_type", "basic");
                    send(contractsForSymbolRequest.toString());
                    System.out.println("[sent] Contracts for symbol request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("contracts_for".equals(data.get("msg_type").getAsString())) {
                        JsonObject contractsFor = data.getAsJsonObject("contracts_for");
                        System.out.println("Contracts for Symbol: " + contractsFor);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send contracts for symbol request
                    JsonObject contractsForSymbolRequest = new JsonObject();
                    contractsForSymbolRequest.addProperty("contracts_for", "R_50"); // Specify symbol here
                    contractsForSymbolRequest.addProperty("currency", "USD");
                    contractsForSymbolRequest.addProperty("landing_company", "svg");
                    contractsForSymbolRequest.addProperty("product_type", "basic");
                    send(contractsForSymbolRequest.toString());
                    System.out.println("[sent] Contracts for symbol request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("contracts_for".equals(data.get("msg_type").getAsString())) {
                        JsonObject contractsFor = data.getAsJsonObject("contracts_for");
                        System.out.println("Contracts for Symbol: " + contractsFor);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.
 */
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a contracts for symbol request
sub send_contracts_for_symbol {
    my $connection = shift;
    my $contracts_for_request = encode_json({
        contracts_for => 'R_50',    # Symbol for which contracts are requested
        currency => 'USD',          # Set currency to USD
        landing_company => 'svg',   # Landing company (e.g., svg)
        product_type => 'basic'     # Product type is set to 'basic'
    });
    $connection->send($contracts_for_request);
    say "[request] Contracts for symbol request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send the contracts for symbol request
    send_contracts_for_symbol($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Process contracts_for response
        if ($data->{msg_type} && $data->{msg_type} eq 'contracts_for') {
            say "[contracts] Contracts for Symbol (R_50):";
            foreach my $contract (@{$data->{contracts_for}{available}}) {
                my $contract_type            = $contract->{contract_type} // "N/A";
                my $contract_display         = $contract->{contract_display} // "N/A";
                my $contract_category_display = $contract->{contract_category_display} // "N/A";
                my $market                   = $contract->{market} // "N/A";
                my $submarket                = $contract->{submarket} // "N/A";
                my $expiry_type              = $contract->{expiry_type} // "N/A";
                my $min_duration             = $contract->{min_contract_duration} // "N/A";
                my $max_duration             = $contract->{max_contract_duration} // "N/A";
                my $barrier                  = $contract->{barrier} // "N/A";
                my $sentiment                = $contract->{sentiment} // "N/A";

                # Print contract details
                say "  - Contract Type: $contract_type";
                say "    - Display Name: $contract_display";
                say "    - Category: $contract_category_display";
                say "    - Market: $market";
                say "    - Submarket: $submarket";
                say "    - Expiry Type: $expiry_type";
                say "    - Min Duration: $min_duration";
                say "    - Max Duration: $max_duration";
                say "    - Barrier: $barrier";
                say "    - Sentiment: $sentiment";
                say "    --------------------";
            }
            say "[contracts] End of Contracts Response.";
            $connection->close;  # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `contracts_for_symbol.pl`.
# 4. Run the script using the command:
#      perl contracts_for_symbol.pl
# This script will connect to the Deriv WebSocket API, request contracts for a specific symbol, and print the details.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a contracts for symbol request
sub send_contracts_for_symbol {
    my $connection = shift;
    my $contracts_for_request = encode_json({
        contracts_for => 'R_50',    # Symbol for which contracts are requested
        currency => 'USD',          # Set currency to USD
        landing_company => 'svg',   # Landing company (e.g., svg)
        product_type => 'basic'     # Product type is set to 'basic'
    });
    $connection->send($contracts_for_request);
    say "[request] Contracts for symbol request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send the contracts for symbol request
    send_contracts_for_symbol($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Process contracts_for response
        if ($data->{msg_type} && $data->{msg_type} eq 'contracts_for') {
            say "[contracts] Contracts for Symbol (R_50):";
            foreach my $contract (@{$data->{contracts_for}{available}}) {
                my $contract_type            = $contract->{contract_type} // "N/A";
                my $contract_display         = $contract->{contract_display} // "N/A";
                my $contract_category_display = $contract->{contract_category_display} // "N/A";
                my $market                   = $contract->{market} // "N/A";
                my $submarket                = $contract->{submarket} // "N/A";
                my $expiry_type              = $contract->{expiry_type} // "N/A";
                my $min_duration             = $contract->{min_contract_duration} // "N/A";
                my $max_duration             = $contract->{max_contract_duration} // "N/A";
                my $barrier                  = $contract->{barrier} // "N/A";
                my $sentiment                = $contract->{sentiment} // "N/A";

                # Print contract details
                say "  - Contract Type: $contract_type";
                say "    - Display Name: $contract_display";
                say "    - Category: $contract_category_display";
                say "    - Market: $market";
                say "    - Submarket: $submarket";
                say "    - Expiry Type: $expiry_type";
                say "    - Min Duration: $min_duration";
                say "    - Max Duration: $max_duration";
                say "    - Barrier: $barrier";
                say "    - Sentiment: $sentiment";
                say "    --------------------";
            }
            say "[contracts] End of Contracts Response.";
            $connection->close;  # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `contracts_for_symbol.pl`.
# 4. Run the script using the command:
#      perl contracts_for_symbol.pl
# This script will connect to the Deriv WebSocket API, request contracts for a specific symbol, and print the details.
```

```text
<?php
// Include necessary libraries (you may need to install Ratchet via Composer)
require 'vendor/autoload.php';

use Ratchet\Client\WebSocket;
use Ratchet\Client\Connector;
use React\EventLoop\Factory as LoopFactory;
use React\Socket\Connector as ReactConnector;

// Define the app_id (replace 'your_app_id' with your actual app_id)
$app_id = 'your_app_id';

// Create an event loop to handle WebSocket events
$loop = LoopFactory::create();
$reactConnector = new ReactConnector($loop);
$connector = new Connector($loop, $reactConnector);

// Define the request object for contracts_for API call
$contracts_for_symbol_request = [
    'contracts_for'   => 'R_50',  // Symbol for which contracts are requested
    'currency'        => 'USD',   // Set currency to USD
    'landing_company' => 'svg',   // Landing company
    'product_type'    => 'basic', // Product type is set to 'basic'
];

// Connect to the Deriv WebSocket API
$connector("wss://ws.derivws.com/websockets/v3?app_id=$app_id")
    ->then(function(WebSocket $conn) use ($contracts_for_symbol_request, $loop) {
        // Send the contracts_for request to the WebSocket server
        $conn->send(json_encode($contracts_for_symbol_request));
        echo "Request sent: " . json_encode($contracts_for_symbol_request) . PHP_EOL;

        // Handle messages received from the server
        $conn->on('message', function($message) use ($conn, $loop) {
            // Decode the received message (JSON format)
            $data = json_decode($message, true);

            // Check if there is an error in the response
            if (isset($data['error'])) {
                echo "Error: " . $data['error']['message'] . PHP_EOL;
                $conn->close();
                $loop->stop(); // Stop the event loop
            }

            // If the response is for 'contracts_for', print the contract information
            if (isset($data['msg_type']) && $data['msg_type'] === 'contracts_for') {
                echo "Contracts for symbol: " . json_encode($data['contracts_for'], JSON_PRETTY_PRINT) . PHP_EOL;
                $conn->close(); // Close the WebSocket connection
                $loop->stop();  // Stop the event loop
            }
        });

        // Handle WebSocket connection closing
        $conn->on('close', function($code = null, $reason = null) use ($loop) {
            echo "Connection closed ({$code} - {$reason})" . PHP_EOL;
            $loop->stop(); // Stop the event loop when the connection is closed
        });
    }, function($e) use ($loop) {
        // Handle connection errors
        echo "Could not connect: {$e->getMessage()}" . PHP_EOL;
        $loop->stop();
    });

// Run the event loop to keep the connection alive
$loop->run();
```

```text
<?php
// Include necessary libraries (you may need to install Ratchet via Composer)
require 'vendor/autoload.php';

use Ratchet\Client\WebSocket;
use Ratchet\Client\Connector;
use React\EventLoop\Factory as LoopFactory;
use React\Socket\Connector as ReactConnector;

// Define the app_id (replace 'your_app_id' with your actual app_id)
$app_id = 'your_app_id';

// Create an event loop to handle WebSocket events
$loop = LoopFactory::create();
$reactConnector = new ReactConnector($loop);
$connector = new Connector($loop, $reactConnector);

// Define the request object for contracts_for API call
$contracts_for_symbol_request = [
    'contracts_for'   => 'R_50',  // Symbol for which contracts are requested
    'currency'        => 'USD',   // Set currency to USD
    'landing_company' => 'svg',   // Landing company
    'product_type'    => 'basic', // Product type is set to 'basic'
];

// Connect to the Deriv WebSocket API
$connector("wss://ws.derivws.com/websockets/v3?app_id=$app_id")
    ->then(function(WebSocket $conn) use ($contracts_for_symbol_request, $loop) {
        // Send the contracts_for request to the WebSocket server
        $conn->send(json_encode($contracts_for_symbol_request));
        echo "Request sent: " . json_encode($contracts_for_symbol_request) . PHP_EOL;

        // Handle messages received from the server
        $conn->on('message', function($message) use ($conn, $loop) {
            // Decode the received message (JSON format)
            $data = json_decode($message, true);

            // Check if there is an error in the response
            if (isset($data['error'])) {
                echo "Error: " . $data['error']['message'] . PHP_EOL;
                $conn->close();
                $loop->stop(); // Stop the event loop
            }

            // If the response is for 'contracts_for', print the contract information
            if (isset($data['msg_type']) && $data['msg_type'] === 'contracts_for') {
                echo "Contracts for symbol: " . json_encode($data['contracts_for'], JSON_PRETTY_PRINT) . PHP_EOL;
                $conn->close(); // Close the WebSocket connection
                $loop->stop();  // Stop the event loop
            }
        });

        // Handle WebSocket connection closing
        $conn->on('close', function($code = null, $reason = null) use ($loop) {
            echo "Connection closed ({$code} - {$reason})" . PHP_EOL;
            $loop->stop(); // Stop the event loop when the connection is closed
        });
    }, function($e) use ($loop) {
        // Handle connection errors
        echo "Could not connect: {$e->getMessage()}" . PHP_EOL;
        $loop->stop();
    });

// Run the event loop to keep the connection alive
$loop->run();
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a contracts for symbol request
        contracts_for_symbol_request = {
            "contracts_for": "R_50",
            "currency": "USD",
            "landing_company": "svg",
            "product_type": "basic"
        }
        response = await api.send(contracts_for_symbol_request)
        print("Contracts for symbol request sent")

        # Process the response and print contract details
        print_contracts_for_symbol(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print contract details for a symbol
def print_contracts_for_symbol(response):
    data = response.get("contracts_for", {})
    if data:
        print("Contracts for Symbol (R_50):")
        contracts = data.get("available", [])
        for contract in contracts:
            print(f"  - Contract Type: {contract.get('contract_type')}")
            print(f"    - Display Name: {contract.get('contract_display')}")
            print(f"    - Category: {contract.get('contract_category_display')}")
            print(f"    - Market: {contract.get('market')}")
            print(f"    - Submarket: {contract.get('submarket')}")
            print(f"    - Expiry Type: {contract.get('expiry_type')}")
            print(f"    - Min Duration: {contract.get('min_contract_duration')}")
            print(f"    - Max Duration: {contract.get('max_contract_duration')}")
            print(f"    - Barrier: {contract.get('barrier')}")
            print(f"    - Sentiment: {contract.get('sentiment')}")
            print("    --------------------")
    print("[End of Contracts for Symbol Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `contracts_for_symbol_client.py`.
# 4. Run the code from the command line:
#      python contracts_for_symbol_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request contract details for the symbol "R_50", and send pings every 30 seconds to keep the connection alive.
# The response includes important contract details such as contract type, category, market, durations, and barriers.
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a contracts for symbol request
        contracts_for_symbol_request = {
            "contracts_for": "R_50",
            "currency": "USD",
            "landing_company": "svg",
            "product_type": "basic"
        }
        response = await api.send(contracts_for_symbol_request)
        print("Contracts for symbol request sent")

        # Process the response and print contract details
        print_contracts_for_symbol(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print contract details for a symbol
def print_contracts_for_symbol(response):
    data = response.get("contracts_for", {})
    if data:
        print("Contracts for Symbol (R_50):")
        contracts = data.get("available", [])
        for contract in contracts:
            print(f"  - Contract Type: {contract.get('contract_type')}")
            print(f"    - Display Name: {contract.get('contract_display')}")
            print(f"    - Category: {contract.get('contract_category_display')}")
            print(f"    - Market: {contract.get('market')}")
            print(f"    - Submarket: {contract.get('submarket')}")
            print(f"    - Expiry Type: {contract.get('expiry_type')}")
            print(f"    - Min Duration: {contract.get('min_contract_duration')}")
            print(f"    - Max Duration: {contract.get('max_contract_duration')}")
            print(f"    - Barrier: {contract.get('barrier')}")
            print(f"    - Sentiment: {contract.get('sentiment')}")
            print("    --------------------")
    print("[End of Contracts for Symbol Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `contracts_for_symbol_client.py`.
# 4. Run the code from the command line:
#      python contracts_for_symbol_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request contract details for the symbol "R_50", and send pings every 30 seconds to keep the connection alive.
# The response includes important contract details such as contract type, category, market, durations, and barriers.
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Contracts for symbol request JSON
    let contracts_for_symbol_request = json!({
        "contracts_for": "R_50",
        "currency": "USD",
        "landing_company": "svg",
        "product_type": "basic"
    });

    // Clone `socket` to send the contracts for symbol request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(contracts_for_symbol_request.to_string())).await.is_ok() {
            println!("[request] Contracts for symbol request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "contracts_for" {
                        println!("Contracts for Symbol (R_50):");
                        if let Some(contracts) = data["contracts_for"]["available"].as_array() {
                            for contract in contracts {
                                println!("  - Contract Type: {}", contract["contract_type"]);
                                println!("    - Display Name: {}", contract["contract_display"]);
                                println!("    - Category: {}", contract["contract_category_display"]);
                                println!("    - Market: {}", contract["market"]);
                                println!("    - Submarket: {}", contract["submarket"]);
                                println!("    - Expiry Type: {}", contract["expiry_type"]);
                                println!("    - Min Duration: {}", contract["min_contract_duration"]);
                                println!("    - Max Duration: {}", contract["max_contract_duration"]);
                                println!("    - Barrier: {}", contract["barrier"]);
                                println!("    - Sentiment: {}", contract["sentiment"]);
                                println!("    --------------------");
                            }
                        }
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request contract details for the symbol "R_50", and print out important contract details such as type, category, market, submarket, expiry type, duration, and barrier information.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Contracts for symbol request JSON
    let contracts_for_symbol_request = json!({
        "contracts_for": "R_50",
        "currency": "USD",
        "landing_company": "svg",
        "product_type": "basic"
    });

    // Clone `socket` to send the contracts for symbol request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(contracts_for_symbol_request.to_string())).await.is_ok() {
            println!("[request] Contracts for symbol request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "contracts_for" {
                        println!("Contracts for Symbol (R_50):");
                        if let Some(contracts) = data["contracts_for"]["available"].as_array() {
                            for contract in contracts {
                                println!("  - Contract Type: {}", contract["contract_type"]);
                                println!("    - Display Name: {}", contract["contract_display"]);
                                println!("    - Category: {}", contract["contract_category_display"]);
                                println!("    - Market: {}", contract["market"]);
                                println!("    - Submarket: {}", contract["submarket"]);
                                println!("    - Expiry Type: {}", contract["expiry_type"]);
                                println!("    - Min Duration: {}", contract["min_contract_duration"]);
                                println!("    - Max Duration: {}", contract["max_contract_duration"]);
                                println!("    - Barrier: {}", contract["barrier"]);
                                println!("    - Sentiment: {}", contract["sentiment"]);
                                println!("    --------------------");
                            }
                        }
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request contract details for the symbol "R_50", and print out important contract details such as type, category, market, submarket, expiry type, duration, and barrier information.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a contracts for symbol request
void send_contracts_for_symbol_request(struct lws *wsi) {
    const char *contracts_for_symbol_msg = "{\"contracts_for\": \"R_50\", \"currency\": \"USD\", \"landing_company\": \"svg\", \"product_type\": \"basic\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], contracts_for_symbol_msg, strlen(contracts_for_symbol_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(contracts_for_symbol_msg), LWS_WRITE_TEXT);
    lwsl_user("Contracts for symbol request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_contracts_for_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "contracts_for"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "contracts_for") == 0) {
        json_t *contracts_for = json_object_get(root, "contracts_for");
        json_t *available_contracts = json_object_get(contracts_for, "available");

        printf("Contracts for Symbol (R_50):\n");
        size_t index;
        json_t *contract;
        json_array_foreach(available_contracts, index, contract) {
            const char *contract_type = json_string_value(json_object_get(contract, "contract_type"));
            const char *display_name = json_string_value(json_object_get(contract, "contract_display"));
            const char *category = json_string_value(json_object_get(contract, "contract_category_display"));
            const char *market = json_string_value(json_object_get(contract, "market"));
            const char *submarket = json_string_value(json_object_get(contract, "submarket"));
            const char *expiry_type = json_string_value(json_object_get(contract, "expiry_type"));
            const char *min_duration = json_string_value(json_object_get(contract, "min_contract_duration"));
            const char *max_duration = json_string_value(json_object_get(contract, "max_contract_duration"));

            printf("  - Contract Type: %s\n", contract_type);
            printf("    - Display Name: %s\n", display_name);
            printf("    - Category: %s\n", category);
            printf("    - Market: %s\n", market);
            printf("    - Submarket: %s\n", submarket);
            printf("    - Expiry Type: %s\n", expiry_type);
            printf("    - Min Duration: %s\n", min_duration);
            printf("    - Max Duration: %s\n", max_duration);
            printf("    --------------------\n");
        }
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_contracts_for_symbol_request(wsi);  // Send contracts for symbol request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_contracts_for_symbol_request(wsi);  // Periodically request contracts
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_contracts_for_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a contracts for symbol request
void send_contracts_for_symbol_request(struct lws *wsi) {
    const char *contracts_for_symbol_msg = "{\"contracts_for\": \"R_50\", \"currency\": \"USD\", \"landing_company\": \"svg\", \"product_type\": \"basic\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], contracts_for_symbol_msg, strlen(contracts_for_symbol_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(contracts_for_symbol_msg), LWS_WRITE_TEXT);
    lwsl_user("Contracts for symbol request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_contracts_for_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "contracts_for"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "contracts_for") == 0) {
        json_t *contracts_for = json_object_get(root, "contracts_for");
        json_t *available_contracts = json_object_get(contracts_for, "available");

        printf("Contracts for Symbol (R_50):\n");
        size_t index;
        json_t *contract;
        json_array_foreach(available_contracts, index, contract) {
            const char *contract_type = json_string_value(json_object_get(contract, "contract_type"));
            const char *display_name = json_string_value(json_object_get(contract, "contract_display"));
            const char *category = json_string_value(json_object_get(contract, "contract_category_display"));
            const char *market = json_string_value(json_object_get(contract, "market"));
            const char *submarket = json_string_value(json_object_get(contract, "submarket"));
            const char *expiry_type = json_string_value(json_object_get(contract, "expiry_type"));
            const char *min_duration = json_string_value(json_object_get(contract, "min_contract_duration"));
            const char *max_duration = json_string_value(json_object_get(contract, "max_contract_duration"));

            printf("  - Contract Type: %s\n", contract_type);
            printf("    - Display Name: %s\n", display_name);
            printf("    - Category: %s\n", category);
            printf("    - Market: %s\n", market);
            printf("    - Submarket: %s\n", submarket);
            printf("    - Expiry Type: %s\n", expiry_type);
            printf("    - Min Duration: %s\n", min_duration);
            printf("    - Max Duration: %s\n", max_duration);
            printf("    --------------------\n");
        }
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_contracts_for_symbol_request(wsi);  // Send contracts for symbol request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_contracts_for_symbol_request(wsi);  // Periodically request contracts
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_contracts_for_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send contracts for symbol request
            await SendContractsForSymbolRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendContractsForSymbolRequest(ClientWebSocket webSocket)
    {
        var contractsForSymbolRequest = new
        {
            contracts_for = "R_50",
            currency = "USD",
            landing_company = "svg",
            product_type = "basic"
        };

        string requestJson = JsonSerializer.Serialize(contractsForSymbolRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[request] Contracts for symbol request sent.");
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[8192];
    var messageBuilder = new StringBuilder();

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            break;
        }

        messageBuilder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));

        if (result.EndOfMessage)
        {
            try
            {
                var data = JsonDocument.Parse(messageBuilder.ToString()).RootElement;
                if (data.TryGetProperty("error", out var error))
                {
                    Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                    break;
                }

                if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "contracts_for")
                {
                    Console.WriteLine("Contracts for Symbol (R_50):");
                    foreach (var contract in data.GetProperty("contracts_for").GetProperty("available").EnumerateArray())
                    {
                        Console.WriteLine($"  - Contract Type: {contract.GetProperty("contract_type").GetString()}");
                        Console.WriteLine($"    - Display Name: {contract.GetProperty("contract_display").GetString()}");
                        Console.WriteLine($"    - Category: {contract.GetProperty("contract_category_display").GetString()}");
                        Console.WriteLine($"    - Market: {contract.GetProperty("market").GetString()}");
                        Console.WriteLine($"    - Submarket: {contract.GetProperty("submarket").GetString()}");
                        Console.WriteLine($"    - Expiry Type: {contract.GetProperty("expiry_type").GetString()}");

                        // Check for optional properties with safe access
                        Console.WriteLine($"    - Min Duration: {(contract.TryGetProperty("min_contract_duration", out var minDuration) ? minDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Max Duration: {(contract.TryGetProperty("max_contract_duration", out var maxDuration) ? maxDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Barrier: {(contract.TryGetProperty("barrier", out var barrier) ? barrier.GetString() : "N/A")}");
                        Console.WriteLine($"    - Sentiment: {(contract.TryGetProperty("sentiment", out var sentiment) ? sentiment.GetString() : "N/A")}");
                        Console.WriteLine("    --------------------");
                    }
                }

                messageBuilder.Clear();
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"[Error] Failed to parse JSON message: {ex.Message}");
            }
        }
    }
}


}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send contracts for symbol request
            await SendContractsForSymbolRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendContractsForSymbolRequest(ClientWebSocket webSocket)
    {
        var contractsForSymbolRequest = new
        {
            contracts_for = "R_50",
            currency = "USD",
            landing_company = "svg",
            product_type = "basic"
        };

        string requestJson = JsonSerializer.Serialize(contractsForSymbolRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[request] Contracts for symbol request sent.");
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[8192];
    var messageBuilder = new StringBuilder();

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            break;
        }

        messageBuilder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));

        if (result.EndOfMessage)
        {
            try
            {
                var data = JsonDocument.Parse(messageBuilder.ToString()).RootElement;
                if (data.TryGetProperty("error", out var error))
                {
                    Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                    break;
                }

                if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "contracts_for")
                {
                    Console.WriteLine("Contracts for Symbol (R_50):");
                    foreach (var contract in data.GetProperty("contracts_for").GetProperty("available").EnumerateArray())
                    {
                        Console.WriteLine($"  - Contract Type: {contract.GetProperty("contract_type").GetString()}");
                        Console.WriteLine($"    - Display Name: {contract.GetProperty("contract_display").GetString()}");
                        Console.WriteLine($"    - Category: {contract.GetProperty("contract_category_display").GetString()}");
                        Console.WriteLine($"    - Market: {contract.GetProperty("market").GetString()}");
                        Console.WriteLine($"    - Submarket: {contract.GetProperty("submarket").GetString()}");
                        Console.WriteLine($"    - Expiry Type: {contract.GetProperty("expiry_type").GetString()}");

                        // Check for optional properties with safe access
                        Console.WriteLine($"    - Min Duration: {(contract.TryGetProperty("min_contract_duration", out var minDuration) ? minDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Max Duration: {(contract.TryGetProperty("max_contract_duration", out var maxDuration) ? maxDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Barrier: {(contract.TryGetProperty("barrier", out var barrier) ? barrier.GetString() : "N/A")}");
                        Console.WriteLine($"    - Sentiment: {(contract.TryGetProperty("sentiment", out var sentiment) ? sentiment.GetString() : "N/A")}");
                        Console.WriteLine("    --------------------");
                    }
                }

                messageBuilder.Clear();
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"[Error] Failed to parse JSON message: {ex.Message}");
            }
        }
    }
}


}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//replace with your app_id
	readLimit    = 65536 // Set a higher read limit, e.g., 64 KB
)

type ContractsForRequest struct {
	ContractsFor   string `json:"contracts_for"`
	Currency       string `json:"currency"`
	LandingCompany string `json:"landing_company"`
	ProductType    string `json:"product_type"`
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("[status] WebSocket connection established.")

	// Set a higher read limit
	conn.SetReadLimit(readLimit)

	// Send contracts for symbol request
	err = sendContractsForSymbolRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send contracts for symbol request: %v", err)
	}

	// Handle incoming messages
	handleResponses(ctx, conn)
}

func sendContractsForSymbolRequest(ctx context.Context, conn *websocket.Conn) error {
	contractsRequest := ContractsForRequest{
		ContractsFor:   "R_50",
		Currency:       "USD",
		LandingCompany: "svg",
		ProductType:    "basic",
	}
	fmt.Println("[request] Sending contracts for symbol request...")
	return wsjson.Write(ctx, conn, contractsRequest)
}

func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}

		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		msgType := response["msg_type"]
		if msgType == "contracts_for" {
			contracts := response["contracts_for"].(map[string]interface{})["available"].([]interface{})
			fmt.Println("Contracts for Symbol (R_50):")
			for _, contract := range contracts {
				contractMap := contract.(map[string]interface{})
				fmt.Printf("  - Contract Type: %v\n", contractMap["contract_type"])
				fmt.Printf("    - Display Name: %v\n", contractMap["contract_display"])
				fmt.Printf("    - Category: %v\n", contractMap["contract_category_display"])
				fmt.Printf("    - Market: %v\n", contractMap["market"])
				fmt.Printf("    - Submarket: %v\n", contractMap["submarket"])
				fmt.Printf("    - Expiry Type: %v\n", contractMap["expiry_type"])
				fmt.Printf("    - Min Duration: %v\n", contractMap["min_contract_duration"])
				fmt.Printf("    - Max Duration: %v\n", contractMap["max_contract_duration"])
				fmt.Printf("    - Barrier: %v\n", contractMap["barrier"])
				fmt.Printf("    - Sentiment: %v\n", contractMap["sentiment"])
				fmt.Println("    --------------------")
			}
		} else {
			fmt.Printf("Received message: %v\n", response)
		}
	}
}
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//replace with your app_id
	readLimit    = 65536 // Set a higher read limit, e.g., 64 KB
)

type ContractsForRequest struct {
	ContractsFor   string `json:"contracts_for"`
	Currency       string `json:"currency"`
	LandingCompany string `json:"landing_company"`
	ProductType    string `json:"product_type"`
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("[status] WebSocket connection established.")

	// Set a higher read limit
	conn.SetReadLimit(readLimit)

	// Send contracts for symbol request
	err = sendContractsForSymbolRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send contracts for symbol request: %v", err)
	}

	// Handle incoming messages
	handleResponses(ctx, conn)
}

func sendContractsForSymbolRequest(ctx context.Context, conn *websocket.Conn) error {
	contractsRequest := ContractsForRequest{
		ContractsFor:   "R_50",
		Currency:       "USD",
		LandingCompany: "svg",
		ProductType:    "basic",
	}
	fmt.Println("[request] Sending contracts for symbol request...")
	return wsjson.Write(ctx, conn, contractsRequest)
}

func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}

		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		msgType := response["msg_type"]
		if msgType == "contracts_for" {
			contracts := response["contracts_for"].(map[string]interface{})["available"].([]interface{})
			fmt.Println("Contracts for Symbol (R_50):")
			for _, contract := range contracts {
				contractMap := contract.(map[string]interface{})
				fmt.Printf("  - Contract Type: %v\n", contractMap["contract_type"])
				fmt.Printf("    - Display Name: %v\n", contractMap["contract_display"])
				fmt.Printf("    - Category: %v\n", contractMap["contract_category_display"])
				fmt.Printf("    - Market: %v\n", contractMap["market"])
				fmt.Printf("    - Submarket: %v\n", contractMap["submarket"])
				fmt.Printf("    - Expiry Type: %v\n", contractMap["expiry_type"])
				fmt.Printf("    - Min Duration: %v\n", contractMap["min_contract_duration"])
				fmt.Printf("    - Max Duration: %v\n", contractMap["max_contract_duration"])
				fmt.Printf("    - Barrier: %v\n", contractMap["barrier"])
				fmt.Printf("    - Sentiment: %v\n", contractMap["sentiment"])
				fmt.Println("    --------------------")
			}
		} else {
			fmt.Printf("Received message: %v\n", response)
		}
	}
}
```

**Content Summary:**
Follow these steps to retrieve the list of available contracts, along with the latest barrier and duration limits for each contract, for a given symbol using the Deriv API:

Import Deriv API: Import the DerivAPIBasic library from Skypack CDN.
WebSocket connection: Create a WebSocket connection to the Deriv API using your app_id.
API initialization: Initialize the DerivAPIBasic instance with the WebSocket connection.
Request object: Define a request object to fetch contracts for a specific symbol (e.g., R_50).
Response handling: Handle the API response:
Parse the data and log any errors.
If the response contains contract data, log it.
Remove the event listener after the response is received.
Trigger request: On a button click, the function sends the request to the API to get the contracts for the symbol.
JavaScript
Java
Perl
PHP
Python
Rust
Swift
C
C#
Go
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app...

---

## üîå 2. WEBSOCKET CONNECTION

### Getting started with Deriv APIs
**URL:** https://developers.deriv.com/docs/getting-started

**Details:**
Quick start

This guide will help you seamlessly integrate our API into your applications, providing access to real-time market data, trading functionalities, account information, and more. The possibilities are limitless.

While Deriv‚Äôs API is powerful and flexible, using it effectively does require some programming knowledge.

It‚Äôs important to note that Deriv does not provide a programmer. You‚Äôll need to work with a trusted
developer on your own or handle the development yourself if you have programming expertise.

However, everything you need to build a manual or automated trading platform is available through the Deriv API.

Updated 3 months ago

Did this page help you?
Yes
No...

---

### Authentication
**URL:** https://developers.deriv.com/docs/authentication

**Implementation Examples:**
```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID
```

```text
YOUR_APP_ID
```

```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID&affiliate_token=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
FB58247C-6B33-4677-A6AD-168C2D72323C
```

```text
dynamicworks
```

```text
jqd7qq_iBB18zg8lBvFoLmNd7ZgqdRLk
```

```text
myaffiliates
```

```text
t
```

```text
utm_campaign
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://[YOUR_WEBSITE_URL]/redirect/?acct1=cr799393&token1=a1-f7pnteezo4jzhpxclctizt27hyeot&cur1=usd& acct2=vrtc1859315&token2=a1clwe3vfuuus5kraceykdsoqm4snfq&cur2=usd&acct3=CRW1157&token3=a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC&cur3=usd&acct4=VRW1160&token4=a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV&cur3=usd
```

```text
https://[YOUR_WEBSITE_URL]/redirect/?acct1=cr799393&token1=a1-f7pnteezo4jzhpxclctizt27hyeot&cur1=usd& acct2=vrtc1859315&token2=a1clwe3vfuuus5kraceykdsoqm4snfq&cur2=usd&acct3=CRW1157&token3=a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC&cur3=usd&acct4=VRW1160&token4=a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV&cur3=usd
```

```text
const user_accounts = [
  {
    currency: 'usd',
    token: 'a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC',
    account: 'CRW1157'
  },
  {
    account: 'VRW1160',
    token: 'a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV',
    currency: 'usd',
  },
  {
    account: 'cr799393',
    token: 'a1-f7pnteezo4jzhpxclctizt27hyeot',
    currency: 'usd',
  },
  {
    account: 'vrtc1859315',
    token: 'a1clwe3vfuuus5kraceykdsoqm4snfq',
    currency: 'usd',
  },
];
```

```text
const user_accounts = [
  {
    currency: 'usd',
    token: 'a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC',
    account: 'CRW1157'
  },
  {
    account: 'VRW1160',
    token: 'a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV',
    currency: 'usd',
  },
  {
    account: 'cr799393',
    token: 'a1-f7pnteezo4jzhpxclctizt27hyeot',
    currency: 'usd',
  },
  {
    account: 'vrtc1859315',
    token: 'a1clwe3vfuuus5kraceykdsoqm4snfq',
    currency: 'usd',
  },
];
```

```text
{
  "authorize": "a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC"
}
```

```text
{
  "authorize": "a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC"
}
```

```text
{
  "account_list": [
    {
      "account_category": "wallet",
      "account_type": "doughflow",
      "broker": "CRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "linked_to": [],
      "loginid": "CRW1157"
    },
    {
      "account_category": "wallet",
      "account_type": "virtual",
      "broker": "VRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 1,
      "landing_company_name": "virtual",
      "linked_to": [],
      "loginid": "VRW1160"
    },
    {
      "account_type": "trading",
      "created_at": 1647509550,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "CR799393",
      "trading": {}
    },
    {
      "account_type": "trading",
      "created_at": 1664132232,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "VRTC1859315",
      "trading": {}
    },
  ],
  "balance": 0,
  "country": "aq",
  "currency": "USD",
  "email": "ss@deriv.com",
  "fullname": "Ms QA script ssRPPta",
  "is_virtual": 0,
  "landing_company_fullname": "Deriv (SVG) LLC",
  "landing_company_name": "svg",
  "linked_to": [],
  "local_currencies": {
    "AAD": {
      "fractional_digits": 2
    }
  },
  "loginid": "CRW1157",
  "preferred_language": "EN",
  "scopes": [
    "admin",
    "payments",
    "read",
    "trade",
    "trading_information"
  ],
  "upgradeable_landing_companies": [],
  "user_id": 464
}
```

```text
{
  "account_list": [
    {
      "account_category": "wallet",
      "account_type": "doughflow",
      "broker": "CRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "linked_to": [],
      "loginid": "CRW1157"
    },
    {
      "account_category": "wallet",
      "account_type": "virtual",
      "broker": "VRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 1,
      "landing_company_name": "virtual",
      "linked_to": [],
      "loginid": "VRW1160"
    },
    {
      "account_type": "trading",
      "created_at": 1647509550,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "CR799393",
      "trading": {}
    },
    {
      "account_type": "trading",
      "created_at": 1664132232,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "VRTC1859315",
      "trading": {}
    },
  ],
  "balance": 0,
  "country": "aq",
  "currency": "USD",
  "email": "ss@deriv.com",
  "fullname": "Ms QA script ssRPPta",
  "is_virtual": 0,
  "landing_company_fullname": "Deriv (SVG) LLC",
  "landing_company_name": "svg",
  "linked_to": [],
  "local_currencies": {
    "AAD": {
      "fractional_digits": 2
    }
  },
  "loginid": "CRW1157",
  "preferred_language": "EN",
  "scopes": [
    "admin",
    "payments",
    "read",
    "trade",
    "trading_information"
  ],
  "upgradeable_landing_companies": [],
  "user_id": 464
}
```

**Details:**
To unlock the complete functionality of Deriv APIs, you must first authenticate and then authorize your users.

For Deriv APIs, your users must be authenticated and authorized by our OAuth provider and WebSocket Server.

The OAuth provider handles user logins and grants secure access tokens. The WebSocket server then uses these tokens to verify users and facilitate seamless communication with the Deriv API. Together, these components ensure the security and efficiency of your app.

Authentication process

OAuth, short for Open Authorization, is a protocol that enables a client to access server-hosted resources on behalf of the user without exposing their credentials. For more information, refer to OAuth.

This method enables Deriv account holders to log into third-party apps without generating an API token. Consequently, the third-party app does not access the user‚Äôs password or permanent API token, enhancing security.

To authenticate your user:

Make sure the URL is specified correct...

---

### Understanding APIs
**URL:** https://developers.deriv.com/docs/understanding-apis

**Details:**
WebSockets

Deriv APIs run on WebSockets, enabling fast development of efficient, interconnected systems.

WebSockets excel in applications requiring ongoing data exchange, such as real-time trading systems.

For more insight into WebSockets, explore our additional resources.

Various functions of API calls

Each API has a functionality associated with it. These functions are as follows:

Send: The server responds with the requested data only once. All API calls support the send function of requesting and receiving responses.
Subscribe: Subscribing to an API call initiates a continuous stream of data from that specific API call.
Forget: Stops the data stream initiated by the subscribe call using the Forget API call.

Refer to API calls. for more information.

For ease of understanding, we have categorised all the APIs according to their use and functions:

Updated 4 months ago

Did this page help you?
Yes
No...

---

### MT5 APIs
**URL:** https://developers.deriv.com/docs/mt5

**Details:**
MT5 APIs facilitate the management and interaction with MetaTrader 5 trading accounts.

They provide functionalities for account creation, password management, retrieving account details, and managing financial transactions like deposits and withdrawals. These APIs are crucial for maintaining and operating MT5 accounts on our trading platforms.

Here are the MT5 APIs we support:

#	API Name	Description	Send	Subscribe	Scope
1	MT5: Deposit	Allows deposits from a Deriv account into an MT5 account.	‚úî	‚úò	Payments
2	MT5: Get Setting	Retrieves MT5 user account settings.	‚úî	‚úò	Read
3	MT5: Accounts List	Retrieves a list of all the MT5 accounts associated with the client.	‚úî	‚úò	Read
4	MT5: New Account	Creates a new MT5 user account, either a demo or real account.	‚úî	‚úò	Admin
5	MT5: Password Change	Changes the password of the MT5 account.	‚úî	‚úò	Admin
6	MT5: Password Check	Validates the main password for the MT5 user.	‚úî	‚úò	Admin
7	MT5: Password Reset	Resets the password for the MT5 account.	‚úî	‚úò	Admin
8	MT5:...

---

### P2P APIs
**URL:** https://developers.deriv.com/docs/p2p

**Implementation Examples:**
```text
p2p_order_create
```

**Details:**
P2P APIs are designed to manage and facilitate peer-to-peer (P2P) transactions. They offer functionalities for creating and managing P2P advertisements, registering and updating advertisers, handling orders, and managing communication and disputes between participants.

These APIs are crucial for enabling and operating P2P transactions on the Deriv platform, allowing users to engage in seamless and secure trading.

üöß

P2P APIs are only available for real accounts. Ensure that you have a real account to access P2P services.

#	API Name	Description	Send	Subscribe	Scope
1	P2P: Advert Create	Creates a P2P advertisement. This can only be used by a verified P2P advertiser.	‚úî	‚úò	Payments
2	P2P: Advert Information	Retrieves details about a specific P2P advertisement.	‚úî	‚úî	Payments
3	P2P: Advert List	Returns available P2P advertisements for use with the p2p_order_create function.	‚úî	‚úò	Payments
4	P2P: Advert Update	Updates an existing P2P advertisement. This can only be used by the original advert...

---

### Application APIs
**URL:** https://developers.deriv.com/docs/application-apis

**Implementation Examples:**
```text
app_id
```

```text
app_markup
```

```text
app_markup
```

**Details:**
Application APIs are designed to manage your applications on Deriv. They provide functionalities for registering, updating, and deleting applications, as well as retrieving detailed information and usage statistics.

These APIs are crucial for managing access and permissions for third-party applications, ensuring secure and controlled integration with external services on the Deriv trading platforms.

#	API Name	Description	Send	Subscribe	Scope
1	Application: Delete	Sends a request to delete an application.	‚úî	‚úò	Admin
2	Application: Get Details	Retrieves the information of the OAuth application specified by app_id.	‚úî	‚úò	Read
3	Application: List	List all of the account's OAuth applications.	‚úî	‚úò	Read
4	Application: Markup Details	Retrieves details of app_markup according to specified criteria.	‚úî	‚úò	Read
5	Application: Markup Statistics	Retrieves statistics of app_markup.	‚úî	‚úò	Read
6	Application: Register	Registers a new OAuth application.	‚úî	‚úò	Admin
7	Application: Update	Updates an existing O...

---

### Account APIs
**URL:** https://developers.deriv.com/docs/account-apis

**Implementation Examples:**
```text
Maltainvest
```

```text
get_self_exclusion
```

```text
get_account_settings
```

**Details:**
Account APIs are designed to manage user accounts, settings, and security. They provide functionalities for authorising sessions, managing API tokens, retrieving and updating account information, handling KYC (Know Your Customer) processes, and setting trading and self-exclusion limits.

These APIs ensure secure, compliant, and personalised interactions on the Deriv platforms, empowering users to manage their accounts and trading activities effectively.

#	API Name	Description	Send	Subscribe	Scope
1	API Token	This call manages API tokens.	‚úî	‚úò	Admin
2	Authorize	Authorises the current WebSocket session using a token. This must precede requests that require access to the client account, such as purchasing or selling contracts.	‚úî	‚úò	NA
3	Balance	Retrieves the user account balance.	‚úî	‚úî	Read
4	Document Upload	Requests and uploads KYC documents from the client.	‚úî	‚úò	Admin
5	Account Status	Retrieves the current status of the user account.	‚úî	‚úò	Read
6	Login History	Retrieves a summary of the user‚Äô...

---

### Market Data APIs
**URL:** https://developers.deriv.com/docs/market-data-apis

**Details:**
Market Data APIs provide access to real-time market data and pricing information on Deriv.

They offer functionalities for retrieving active trading symbols, exchange rates, contract details, and price proposals. Additionally, these APIs enable real-time streaming of spot prices and access to historical tick data, helping users make informed trading decisions.

These APIs are crucial for accessing accurate and up-to-date market data, ensuring users can trade efficiently on the Deriv trading platforms.

#	API Name	Description	Send	Subscribe	Scope
1	Active Symbols	Retrieves a list of all currently active symbols (underlying markets available for trading).	‚úî	‚úò	NA
2	Asset Index	Retrieves a list of available underlyings along with their corresponding contract types and duration limits. For logged-in users, only assets available under their landing company will be returned.	‚úî	‚úò	NA
3	Exchange Rates	Retrieves the exchange rate between a base currency and a target currency supported by the syst...

---

### Cashier APIs
**URL:** https://developers.deriv.com/docs/cashier-apis

**Implementation Examples:**
```text
account_from
```

**Details:**
Cashier APIs are designed to handle payments and account management. They provide functionalities for retrieving cashier information, transferring funds between accounts (both fiat and cryptocurrency), and obtaining a list of available payout currencies.

These APIs are essential for managing financial transactions, allowing users to control their funds within the platform efficiently.

#	API Name	Description	Send	Subscribe	Scope
1	Cashier Information	Requests the cashier information for the specified type.	‚úî	‚úò	Payments
2	Transfer Between Accounts	Allows transfers between a user‚Äôs fiat and cryptocurrency accounts (fees may apply). The account_from parameter must match the currently authorised account.	‚úî	‚úò	Payments
3	Payout Currencies	Retrieves a list of available payout currencies. If a user is logged in, only the currencies available for their account will be returned.	‚úî	‚úò	NA

Updated 4 months ago

Did this page help you?
Yes
No...

---

### Reports APIs
**URL:** https://developers.deriv.com/docs/reports-apis

**Details:**
Reports APIs are designed to monitor and report user account activity. They provide functionalities for retrieving reality check summaries, generating account statements, and subscribing to real-time transaction notifications.

These APIs are essential for ensuring regulatory compliance and giving clients up-to-date insights into their trading activities and account status.

#	API Name	Description	Send	Subscribe	Scope
1	Reality Check	Retrieves a summary of the client‚Äôs trades and account status for the Reality Check feature.

This includes the time elapsed since the session began and the associated profit/loss.	‚úî	‚úò	Read, Trading Information
2	Statement	Retrieves a summary of account transactions according to the specified search criteria.	‚úî	‚úò	Read, Trading Information
3	Transactions Stream	Subscribes to real-time transaction notifications.	‚úî	‚úî	Read, Trading Information

Updated 4 months ago

Did this page help you?
Yes
No...

---

### Trading APIs
**URL:** https://developers.deriv.com/docs/trading-apis

**Implementation Examples:**
```text
tokens
```

```text
portfolio
```

```text
buy_contract_for_multiple_accounts
```

**Details:**
Trading APIs focus on trading and managing contracts.

They include functionalities for buying, selling, and updating contracts, as well as managing copy trading activities. The APIs also allow users to retrieve important trading information such as profit tables, portfolio details, and contract durations.

These APIs are essential for users who actively trade on the platform and need to manage their trading accounts effectively.

#	API Name	Description	Send	Subscribe	Scope
1	Buy Contract: Trade	Buys a contract.	‚úî	‚úò	Trade
2	Buy Contract for Multiple Accounts	Buys a contract for multiple accounts specified by the tokens parameter. Note that although this is an authorized call, the contract is not purchased for the authorized account.	‚úî	‚úò	Trade
3	Cancel a Contract	Cancels a contract using its contract ID.	‚úî	‚úò	Trade
4	Update Contract	Updates the conditions of a contract.	‚úî	‚úò	Trade
5	Update Contract History	Retrieves the update history of a contract.	‚úî	‚úò	Read
6	Copy Trading: Start	Starts c...

---

### Utilities APIs
**URL:** https://developers.deriv.com/docs/utilities-apis

**Details:**
Utilities APIs provide essential information and utility functions for the platform‚Äôs operations. They offer functionalities for retrieving economic calendar events, managing real-time message streams, and accessing details about landing companies and server statuses.

Additionally, these APIs include utility features like server time, ping requests, and country/state lists for account management.

These APIs ensure smooth platform operations and deliver up-to-date trading and account management information.

#	API Name	Description	Send	Subscribe	Scope
1	Economic Calendar	Retrieve a list of economic events for a specific currency. If no currency is specified, the list includes all currencies.	‚úî	‚úò	NA
2	Forget	Immediately cancels the real-time stream of messages with a specific ID.	‚úî	‚úò	NA
3	Forget All	Immediately cancels all real-time streams of messages of a given type.	‚úî	‚úò	NA
4	Landing Company	Retrieve the appropriate landing company based on the client‚Äôs country. Different landing com...

---

### Payment Agent
**URL:** https://developers.deriv.com/docs/payment-agent

**Details:**
Payment Agent APIs are designed to manage and facilitate Payment Agent(PA) transactions. Payment agents allow users to deposit and withdraw funds using local payment methods that might not be available via the main website's cashier system.

These APIs are crucial for enabling and operating PA transactions on the Deriv platform, allowing users to engage in seamless and secure transactions.

#	API Name	Description	Send	Subscribe	Scope
1	Payment Agent: Withdraw justification	Provide justification to perform withdrawal using a Payment Agent.	‚úî	‚úò	Payments
2	Payment Agent Create	Saves client's payment agent details.	‚úî	‚úò	Payments
3	Payment Agent: List	Will return a list of Payment Agents for a given country for a given currency.	‚úî	‚úò	Payments
4	Payment Agent: Transfer	This call is available only to accounts that are approved Payment Agents.	‚úî	‚úò	Payments
5	Payment Agent: Withdraw	Initiate a withdrawal to an approved Payment Agent.	‚úî	‚úò	Payments

Updated 4 months ago

Did this page help you?
Yes...

---

### WebSockets
**URL:** https://developers.deriv.com/docs/websockets

**Implementation Examples:**
```text
wss://ws.derivws.com/websockets/v3?app_id={app_id}
```

```text
{app_id}
```

```text
api_call_limits
```

```text
{app_id}
```

```text
let socket = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id={app_id}');
```

```text
let socket = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id={app_id}');
```

```text
readyState
```

```text
1
```

```text
readyState
```

```text
socket.onopen = function (e) {
  console.log('[open] Connection established');
  console.log('Sending to server');
  const sendMessage = JSON.stringify({ ping: 1 });
  socket.send(sendMessage);
};
```

```text
socket.onopen = function (e) {
  console.log('[open] Connection established');
  console.log('Sending to server');
  const sendMessage = JSON.stringify({ ping: 1 });
  socket.send(sendMessage);
};
```

```text
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`);
};
```

```text
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`);
};
```

```text
Close()
```

```text
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
  } else {
    // e.g. server process killed or network down
    // event.code is usually 1006 in this case
    console.log('[close] Connection died');
  }
};
```

```text
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
  } else {
    // e.g. server process killed or network down
    // event.code is usually 1006 in this case
    console.log('[close] Connection died');
  }
};
```

```text
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`);
};
```

```text
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`);
};
```

```text
Open()
```

```text
OnOpen
```

```text
Send
```

```text
byte[]
```

```text
Close()
```

```text
const app_id = 'app_id'; // Replace with your app_id.
const socket = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`); // Create a new WebSocket connection using the app_id

// Event handler for when the WebSocket connection is opened
socket.onopen = function (e) {
  console.log('[open] Connection established'); // Log connection establishment
  console.log('Sending to server');

  const sendMessage = JSON.stringify({ ping: 1 }); // Create a ping message in JSON format
  socket.send(sendMessage); // Send the ping message to the server
};

// Event handler for when a message is received from the server
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`); // Log the message received from the server
};

// Event handler for when the WebSocket connection is closed
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`); // Log clean close with code and reason
  } else {
    console.log('[close] Connection died'); // Log an abrupt close
  }
};

// Event handler for when an error occurs with the WebSocket connection
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`); // Log the error that occurred
};

/*
Instructions to run this code:

1. Ensure Node.js is installed on your machine. You can download it from https://nodejs.org/.
2. Install the `ws` WebSocket library by running:
   npm install ws
3. Save this code to a file, e.g., `websocket_client.js`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   node websocket_client.js

Ensure that the `app_id` in the URL is replaced with your own if needed.
*/
```

```text
const app_id = 'app_id'; // Replace with your app_id.
const socket = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`); // Create a new WebSocket connection using the app_id

// Event handler for when the WebSocket connection is opened
socket.onopen = function (e) {
  console.log('[open] Connection established'); // Log connection establishment
  console.log('Sending to server');

  const sendMessage = JSON.stringify({ ping: 1 }); // Create a ping message in JSON format
  socket.send(sendMessage); // Send the ping message to the server
};

// Event handler for when a message is received from the server
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`); // Log the message received from the server
};

// Event handler for when the WebSocket connection is closed
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`); // Log clean close with code and reason
  } else {
    console.log('[close] Connection died'); // Log an abrupt close
  }
};

// Event handler for when an error occurs with the WebSocket connection
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`); // Log the error that occurred
};

/*
Instructions to run this code:

1. Ensure Node.js is installed on your machine. You can download it from https://nodejs.org/.
2. Install the `ws` WebSocket library by running:
   npm install ws
3. Save this code to a file, e.g., `websocket_client.js`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   node websocket_client.js

Ensure that the `app_id` in the URL is replaced with your own if needed.
*/
```

```text
import asyncio
import websockets
import json

async def connect_to_websocket():
    app_id = app_id  # Replace with your app_id
    uri = f"wss://ws.derivws.com/websockets/v3?app_id={app_id}"  # WebSocket URI with the app_id

    try:
        # Establish a connection to the WebSocket server
        async with websockets.connect(uri) as websocket:
            print("[open] Connection established")  # Connection opened
            print("Sending to server")

            # Prepare the message to send (ping message in JSON format)
            send_message = json.dumps({"ping": 1})
            await websocket.send(send_message)  # Send the ping message to the server

            # Wait for a response from the server
            response = await websocket.recv()
            print(f"[message] Data received from server: {response}")  # Log the server's response

    except websockets.ConnectionClosedError as e:
        # Handle the scenario where the connection is closed
        if e.code == 1000:
            print(f"[close] Connection closed cleanly, code={e.code} reason={e.reason}")  # Clean close
        else:
            print("[close] Connection died")  # Abrupt close, likely due to network or server issues

    except Exception as e:
        # Handle any other exceptions that may occur
        print(f"[error] {str(e)}")  # Log any errors that occur

# Run the WebSocket client
# asyncio.get_event_loop().run_until_complete() starts the coroutine connect_to_websocket()
asyncio.get_event_loop().run_until_complete(connect_to_websocket())

'''
Instructions to run this code:

1. Ensure Python 3 is installed on your machine. You can download it from https://www.python.org/.
2. Install the `websockets` library by running:
   pip install websockets
3. Save this code to a file, e.g., `websocket_client.py`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   python websocket_client.py

Replace `app_id` with your own application ID if needed.
'''
```

```text
import asyncio
import websockets
import json

async def connect_to_websocket():
    app_id = app_id  # Replace with your app_id
    uri = f"wss://ws.derivws.com/websockets/v3?app_id={app_id}"  # WebSocket URI with the app_id

    try:
        # Establish a connection to the WebSocket server
        async with websockets.connect(uri) as websocket:
            print("[open] Connection established")  # Connection opened
            print("Sending to server")

            # Prepare the message to send (ping message in JSON format)
            send_message = json.dumps({"ping": 1})
            await websocket.send(send_message)  # Send the ping message to the server

            # Wait for a response from the server
            response = await websocket.recv()
            print(f"[message] Data received from server: {response}")  # Log the server's response

    except websockets.ConnectionClosedError as e:
        # Handle the scenario where the connection is closed
        if e.code == 1000:
            print(f"[close] Connection closed cleanly, code={e.code} reason={e.reason}")  # Clean close
        else:
            print("[close] Connection died")  # Abrupt close, likely due to network or server issues

    except Exception as e:
        # Handle any other exceptions that may occur
        print(f"[error] {str(e)}")  # Log any errors that occur

# Run the WebSocket client
# asyncio.get_event_loop().run_until_complete() starts the coroutine connect_to_websocket()
asyncio.get_event_loop().run_until_complete(connect_to_websocket())

'''
Instructions to run this code:

1. Ensure Python 3 is installed on your machine. You can download it from https://www.python.org/.
2. Install the `websockets` library by running:
   pip install websockets
3. Save this code to a file, e.g., `websocket_client.py`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   python websocket_client.py

Replace `app_id` with your own application ID if needed.
'''
```

```text
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.ByteBuffer;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id.
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {
                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");
                    System.out.println("Sending to server");

                    // Create a ping message in JSON format
                    String sendMessage = "{\"ping\": 1}";
                    this.send(sendMessage); // Send the ping message to the server
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Data received from server: " + message); // Log the received message
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    if (remote) {
                        System.out.println("[close] Connection closed by server, code=" + code + " reason=" + reason); // Remote close
                    } else {
                        System.out.println("[close] Connection closed by client, code=" + code + " reason=" + reason); // Client close
                    }
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage()); // Log any errors
                }
                
                @Override
                public void onMessage(ByteBuffer bytes) {
                    System.out.println("[message] ByteBuffer received from server"); // Handle binary message if necessary
                }
            };

            client.connect(); // Connect to the WebSocket server

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run this code:

1. Add the Java-WebSocket library to your project. You can do this by:
   - Using Maven: Add the following dependency to your `pom.xml`:
     <dependency>
         <groupId>org.java-websocket</groupId>
         <artifactId>Java-WebSocket</artifactId>
         <version>1.5.2</version>
     </dependency>
   - Using Gradle: Add the following to your `build.gradle`:
     implementation 'org.java-websocket:Java-WebSocket:1.5.2'

2. Save this code to a file, e.g., `WebSocketExample.java`.

3. Compile the program:
   javac WebSocketExample.java

4. Run the program:
   java WebSocketExample

Make sure to replace `app_id` with your actual application ID if needed.
*/
```

```text
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.ByteBuffer;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id.
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {
                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");
                    System.out.println("Sending to server");

                    // Create a ping message in JSON format
                    String sendMessage = "{\"ping\": 1}";
                    this.send(sendMessage); // Send the ping message to the server
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Data received from server: " + message); // Log the received message
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    if (remote) {
                        System.out.println("[close] Connection closed by server, code=" + code + " reason=" + reason); // Remote close
                    } else {
                        System.out.println("[close] Connection closed by client, code=" + code + " reason=" + reason); // Client close
                    }
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage()); // Log any errors
                }
                
                @Override
                public void onMessage(ByteBuffer bytes) {
                    System.out.println("[message] ByteBuffer received from server"); // Handle binary message if necessary
                }
            };

            client.connect(); // Connect to the WebSocket server

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run this code:

1. Add the Java-WebSocket library to your project. You can do this by:
   - Using Maven: Add the following dependency to your `pom.xml`:
     <dependency>
         <groupId>org.java-websocket</groupId>
         <artifactId>Java-WebSocket</artifactId>
         <version>1.5.2</version>
     </dependency>
   - Using Gradle: Add the following to your `build.gradle`:
     implementation 'org.java-websocket:Java-WebSocket:1.5.2'

2. Save this code to a file, e.g., `WebSocketExample.java`.

3. Compile the program:
   javac WebSocketExample.java

4. Run the program:
   java WebSocketExample

Make sure to replace `app_id` with your actual application ID if needed.
*/
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use AnyEvent;
use AnyEvent::WebSocket::Client 0.12;
use JSON;
use feature 'say';

# WebSocket URL and app_id
my $app_id = app_id; //Replace with your app_id
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging



# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        # handle error...
        warn $@;
        return;

    }
    say "WebSocket connection established.";


    $connection->send('{ ping => 1 }');
    say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";


    # Handle incoming messages
    $connection->on(each_message => sub {
        my($connection, $message) = @_;

        say "message received";
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use AnyEvent;
use AnyEvent::WebSocket::Client 0.12;
use JSON;
use feature 'say';

# WebSocket URL and app_id
my $app_id = app_id; //Replace with your app_id
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging



# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        # handle error...
        warn $@;
        return;

    }
    say "WebSocket connection established.";


    $connection->send('{ ping => 1 }');
    say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";


    # Handle incoming messages
    $connection->on(each_message => sub {
        my($connection, $message) = @_;

        say "message received";
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
<?php

// Include Composer's autoload file
require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your specific app ID
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] Connection established\n";
    echo "Sending to server\n";

    // Send a ping message
    $client->send(json_encode(["ping" => 1]));
    echo "[debug] Message sent: {\"ping\":1}\n";

    // Receive a response from the server
    $response = $client->receive();
    echo "[message] Received from WebSocket: '$response'\n";

    // Close the connection
    $client->close();
    echo "[close] Connection closed\n";

} catch (\WebSocket\ConnectionException $e) {
    echo "[error] Connection error: " . $e->getMessage() . "\n";
} catch (Exception $e) {
    echo "[error] General error: " . $e->getMessage() . "\n";
}

/*
Instructions to run this code:

1. Ensure PHP is installed on your machine. You can check by running `php -v` in your terminal.
2. Install Composer, the dependency manager for PHP, from https://getcomposer.org/.
3. Initialize a Composer project in the directory where this file is saved:
composer init
4. Install the `textalk/websocket` package by adding it to your `composer.json` file or by running:
composer require textalk/websocket
5. Save the PHP code above to a file, e.g., `websocket_client.php`.
6. Run the code in the terminal:
php websocket_client.php
Note: Replace the `app_id` in the URL with your own application ID if needed.
*/
```

```text
<?php

// Include Composer's autoload file
require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your specific app ID
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] Connection established\n";
    echo "Sending to server\n";

    // Send a ping message
    $client->send(json_encode(["ping" => 1]));
    echo "[debug] Message sent: {\"ping\":1}\n";

    // Receive a response from the server
    $response = $client->receive();
    echo "[message] Received from WebSocket: '$response'\n";

    // Close the connection
    $client->close();
    echo "[close] Connection closed\n";

} catch (\WebSocket\ConnectionException $e) {
    echo "[error] Connection error: " . $e->getMessage() . "\n";
} catch (Exception $e) {
    echo "[error] General error: " . $e->getMessage() . "\n";
}

/*
Instructions to run this code:

1. Ensure PHP is installed on your machine. You can check by running `php -v` in your terminal.
2. Install Composer, the dependency manager for PHP, from https://getcomposer.org/.
3. Initialize a Composer project in the directory where this file is saved:
composer init
4. Install the `textalk/websocket` package by adding it to your `composer.json` file or by running:
composer require textalk/websocket
5. Save the PHP code above to a file, e.g., `websocket_client.php`.
6. Run the code in the terminal:
php websocket_client.php
Note: Replace the `app_id` in the URL with your own application ID if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server
    let (mut socket, _response) = connect_async(url).await.expect("Failed to connect");

    println!("[open] Connection established");

    // Prepare the ping message
    let send_message = r#"{"ping": 1}"#;
    socket.send(Message::Text(send_message.into())).await.expect("Failed to send message");

    println!("Message sent to server");

    // Receive a message from the server
    if let Some(Ok(msg)) = socket.next().await {
        println!("[message] Data received from server: {:?}", msg);
    }

    // Close the connection
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed cleanly");
}

/*
Instructions to run this code:

1. Ensure that Rust and Cargo (Rust's package manager) are installed. You can install them from https://rustup.rs/.
2. Initialize a new Rust project if you haven‚Äôt already:
cargo new websocket_client
cd websocket_client
3. Add the following dependencies to your `Cargo.toml` file under `[dependencies]`:
tokio = { version = ‚Äú1‚Äù, features = [‚Äúfull‚Äù] }
tokio-tungstenite = ‚Äú0.15‚Äù
futures-util = ‚Äú0.3‚Äù
url = ‚Äú2.2‚Äù
4. Replace the contents of `src/main.rs` with the code above.
5. Compile and run the code using:
cargo run
Note: Replace `app_id` in the URL with your own application ID if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server
    let (mut socket, _response) = connect_async(url).await.expect("Failed to connect");

    println!("[open] Connection established");

    // Prepare the ping message
    let send_message = r#"{"ping": 1}"#;
    socket.send(Message::Text(send_message.into())).await.expect("Failed to send message");

    println!("Message sent to server");

    // Receive a message from the server
    if let Some(Ok(msg)) = socket.next().await {
        println!("[message] Data received from server: {:?}", msg);
    }

    // Close the connection
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed cleanly");
}

/*
Instructions to run this code:

1. Ensure that Rust and Cargo (Rust's package manager) are installed. You can install them from https://rustup.rs/.
2. Initialize a new Rust project if you haven‚Äôt already:
cargo new websocket_client
cd websocket_client
3. Add the following dependencies to your `Cargo.toml` file under `[dependencies]`:
tokio = { version = ‚Äú1‚Äù, features = [‚Äúfull‚Äù] }
tokio-tungstenite = ‚Äú0.15‚Äù
futures-util = ‚Äú0.3‚Äù
url = ‚Äú2.2‚Äù
4. Replace the contents of `src/main.rs` with the code above.
5. Compile and run the code using:
cargo run
Note: Replace `app_id` in the URL with your own application ID if needed.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a ping message to the server
    func sendPingMessage() {
        let message = URLSessionWebSocketTask.Message.string("{\"ping\": 1}") // Prepare the ping message in JSON format
        webSocketTask?.send(message) { error in
            if let error = error {
                print("[error] Failed to send message: \(error.localizedDescription)")
            } else {
                print("Sending to server")
            }
        }
    }
    
    // Send the ping message initially
    sendPingMessage()

    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    print("[message] Data received from server: \(text)")
                case .data(let data):
                    print("[message] Data received from server: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }

                // Continue to receive messages
                receiveMessage()

            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }

    // Start receiving messages
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    // Use this function when you need to close the connection
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Call the function to connect to the WebSocket
connectWebSocket()

// Example usage: Call closeWebSocketConnection() to close the connection when needed
// The following line will close the connection after 10 seconds for demonstration purposes
DispatchQueue.main.asyncAfter(deadline: .now() + 10) { closeWebSocketConnection() }

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run this code:

1. Ensure that Xcode is installed on your macOS system, or if you're using another platform, ensure Swift is set up correctly.
2. Create a new Swift file in Xcode or any text editor, and paste the above code into it.
3. In Xcode:
   - Go to `File` -> `New` -> `Project`, and select a macOS Command Line Tool.
   - In the project, create a new Swift file and paste this code.
4. Run the project in Xcode to execute the WebSocket client.
5. Alternatively, save the code to a file named `websocket_client.swift` and run it from the terminal using:
swift websocket_client.swift
Note: Replace `app_id` in the WebSocket URL with your own application ID if needed.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a ping message to the server
    func sendPingMessage() {
        let message = URLSessionWebSocketTask.Message.string("{\"ping\": 1}") // Prepare the ping message in JSON format
        webSocketTask?.send(message) { error in
            if let error = error {
                print("[error] Failed to send message: \(error.localizedDescription)")
            } else {
                print("Sending to server")
            }
        }
    }
    
    // Send the ping message initially
    sendPingMessage()

    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    print("[message] Data received from server: \(text)")
                case .data(let data):
                    print("[message] Data received from server: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }

                // Continue to receive messages
                receiveMessage()

            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }

    // Start receiving messages
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    // Use this function when you need to close the connection
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Call the function to connect to the WebSocket
connectWebSocket()

// Example usage: Call closeWebSocketConnection() to close the connection when needed
// The following line will close the connection after 10 seconds for demonstration purposes
DispatchQueue.main.asyncAfter(deadline: .now() + 10) { closeWebSocketConnection() }

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run this code:

1. Ensure that Xcode is installed on your macOS system, or if you're using another platform, ensure Swift is set up correctly.
2. Create a new Swift file in Xcode or any text editor, and paste the above code into it.
3. In Xcode:
   - Go to `File` -> `New` -> `Project`, and select a macOS Command Line Tool.
   - In the project, create a new Swift file and paste this code.
4. Run the project in Xcode to execute the WebSocket client.
5. Alternatively, save the code to a file named `websocket_client.swift` and run it from the terminal using:
swift websocket_client.swift
Note: Replace `app_id` in the WebSocket URL with your own application ID if needed.
*/
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE: {
        const char *ping_msg = "{\"ping\": 1}";
        unsigned char buf[LWS_PRE + 20];
        memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
        lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
        break;
    }

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE: {
        const char *ping_msg = "{\"ping\": 1}";
        unsigned char buf[LWS_PRE + 20];
        memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
        lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
        break;
    }

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    public static async Task Main(string[] args)
    {
        string app_id = "app_id"; // Replace with your app_id.
        string uri = $"wss://ws.derivws.com/websockets/v3?app_id={app_id}"; // WebSocket URI with the app_id

        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            try
            {
                // Connect to the WebSocket server
                await webSocket.ConnectAsync(new Uri(uri), CancellationToken.None);
                Console.WriteLine("[open] Connection established");

                // Send a ping message to the server
                string sendMessage = "{\"ping\": 1}"; // Prepare the ping message in JSON format
                ArraySegment<byte> bytesToSend = new ArraySegment<byte>(Encoding.UTF8.GetBytes(sendMessage));
                await webSocket.SendAsync(bytesToSend, WebSocketMessageType.Text, true, CancellationToken.None);
                Console.WriteLine("Sending to server");

                // Receive message from the server
                var buffer = new byte[1024];
                WebSocketReceiveResult result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
                string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
                Console.WriteLine("[message] Data received from server: " + response);

                // Close the WebSocket connection cleanly
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Close connection", CancellationToken.None);
                Console.WriteLine("[close] Connection closed cleanly");
            }
            catch (WebSocketException e)
            {
                Console.WriteLine("[error] WebSocket error: " + e.Message);
            }
            catch (Exception e)
            {
                Console.WriteLine("[error] " + e.Message);
            }
        }
    }
}

/*
 * Instructions:
 * 1. Ensure you have the .NET SDK installed on your machine. You can download it from https://dotnet.microsoft.com/download.
 * 2. Save this code in a file, e.g., WebSocketExample.cs.
 * 3. Open a terminal and navigate to the directory where you saved the file.
 * 4. Create a new .NET console project and add the required WebSocket package:
 *      dotnet new console -o WebSocketExampleApp
 *      mv WebSocketExample.cs WebSocketExampleApp/WebSocketExample.cs
 *      cd WebSocketExampleApp
 *      dotnet add package System.Net.WebSockets.Client --version 4.5.3
 * 5. Run the application with:
 *      dotnet run
 *
 * Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
 */
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    public static async Task Main(string[] args)
    {
        string app_id = "app_id"; // Replace with your app_id.
        string uri = $"wss://ws.derivws.com/websockets/v3?app_id={app_id}"; // WebSocket URI with the app_id

        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            try
            {
                // Connect to the WebSocket server
                await webSocket.ConnectAsync(new Uri(uri), CancellationToken.None);
                Console.WriteLine("[open] Connection established");

                // Send a ping message to the server
                string sendMessage = "{\"ping\": 1}"; // Prepare the ping message in JSON format
                ArraySegment<byte> bytesToSend = new ArraySegment<byte>(Encoding.UTF8.GetBytes(sendMessage));
                await webSocket.SendAsync(bytesToSend, WebSocketMessageType.Text, true, CancellationToken.None);
                Console.WriteLine("Sending to server");

                // Receive message from the server
                var buffer = new byte[1024];
                WebSocketReceiveResult result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
                string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
                Console.WriteLine("[message] Data received from server: " + response);

                // Close the WebSocket connection cleanly
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Close connection", CancellationToken.None);
                Console.WriteLine("[close] Connection closed cleanly");
            }
            catch (WebSocketException e)
            {
                Console.WriteLine("[error] WebSocket error: " + e.Message);
            }
            catch (Exception e)
            {
                Console.WriteLine("[error] " + e.Message);
            }
        }
    }
}

/*
 * Instructions:
 * 1. Ensure you have the .NET SDK installed on your machine. You can download it from https://dotnet.microsoft.com/download.
 * 2. Save this code in a file, e.g., WebSocketExample.cs.
 * 3. Open a terminal and navigate to the directory where you saved the file.
 * 4. Create a new .NET console project and add the required WebSocket package:
 *      dotnet new console -o WebSocketExampleApp
 *      mv WebSocketExample.cs WebSocketExampleApp/WebSocketExample.cs
 *      cd WebSocketExampleApp
 *      dotnet add package System.Net.WebSockets.Client --version 4.5.3
 * 5. Run the application with:
 *      dotnet run
 *
 * Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
 */
```

```text
package main

import (
    "fmt"
    "log"
    "net/url"
    "os"
    "os/signal"
    "time"

    "github.com/gorilla/websocket"
)

func main() {
    // Define the WebSocket server URL
    appID := "app_id" // Replace with your app_id.
    serverURL := url.URL{Scheme: "wss", Host: "ws.derivws.com", Path: "/websockets/v3", RawQuery: "app_id=" + appID}
    fmt.Printf("Connecting to %s\n", serverURL.String())

    // Connect to the WebSocket server
    c, _, err := websocket.DefaultDialer.Dial(serverURL.String(), nil)
    if err != nil {
        log.Fatal("Dial error:", err)
    }
    defer c.Close()

    done := make(chan struct{})

    // Goroutine to handle receiving messages from the server
    go func() {
        defer close(done)
        for {
            _, message, err := c.ReadMessage()
            if err != nil {
                log.Println("Read error:", err)
                return
            }
            fmt.Printf("[message] Data received from server: %s\n", message)
        }
    }()

    // Send a ping message to the server
    pingMessage := `{"ping": 1}` // Prepare the ping message in JSON format
    err = c.WriteMessage(websocket.TextMessage, []byte(pingMessage))
    if err != nil {
        log.Println("Write error:", err)
        return
    }
    fmt.Println("Sending to server")

    // Set up signal handling to gracefully close the connection
    interrupt := make(chan os.Signal, 1)
    signal.Notify(interrupt, os.Interrupt)

    // Loop to handle connection closure or interruptions
    for {
        select {
        case <-done:
            return
        case <-interrupt:
            fmt.Println("[close] Interrupt signal received. Closing connection.")
            // Close the WebSocket connection gracefully
            err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
            if err != nil {
                log.Println("Write close error:", err)
                return
            }
            select {
            case <-done:
            case <-time.After(time.Second):
            }
            return
        }
    }
}

/*
Instructions:
1. Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.
2. Install the Gorilla WebSocket package by running:
       go get github.com/gorilla/websocket
3. Save this code to a file, e.g., websocket_client.go.
4. Open a terminal, navigate to the directory where you saved the file, and run:
       go run websocket_client.go

Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
*/
```

```text
package main

import (
    "fmt"
    "log"
    "net/url"
    "os"
    "os/signal"
    "time"

    "github.com/gorilla/websocket"
)

func main() {
    // Define the WebSocket server URL
    appID := "app_id" // Replace with your app_id.
    serverURL := url.URL{Scheme: "wss", Host: "ws.derivws.com", Path: "/websockets/v3", RawQuery: "app_id=" + appID}
    fmt.Printf("Connecting to %s\n", serverURL.String())

    // Connect to the WebSocket server
    c, _, err := websocket.DefaultDialer.Dial(serverURL.String(), nil)
    if err != nil {
        log.Fatal("Dial error:", err)
    }
    defer c.Close()

    done := make(chan struct{})

    // Goroutine to handle receiving messages from the server
    go func() {
        defer close(done)
        for {
            _, message, err := c.ReadMessage()
            if err != nil {
                log.Println("Read error:", err)
                return
            }
            fmt.Printf("[message] Data received from server: %s\n", message)
        }
    }()

    // Send a ping message to the server
    pingMessage := `{"ping": 1}` // Prepare the ping message in JSON format
    err = c.WriteMessage(websocket.TextMessage, []byte(pingMessage))
    if err != nil {
        log.Println("Write error:", err)
        return
    }
    fmt.Println("Sending to server")

    // Set up signal handling to gracefully close the connection
    interrupt := make(chan os.Signal, 1)
    signal.Notify(interrupt, os.Interrupt)

    // Loop to handle connection closure or interruptions
    for {
        select {
        case <-done:
            return
        case <-interrupt:
            fmt.Println("[close] Interrupt signal received. Closing connection.")
            // Close the WebSocket connection gracefully
            err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
            if err != nil {
                log.Println("Write close error:", err)
                return
            }
            select {
            case <-done:
            case <-time.After(time.Second):
            }
            return
        }
    }
}

/*
Instructions:
1. Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.
2. Install the Gorilla WebSocket package by running:
       go get github.com/gorilla/websocket
3. Save this code to a file, e.g., websocket_client.go.
4. Open a terminal, navigate to the directory where you saved the file, and run:
       go run websocket_client.go

Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
*/
```

**Details:**
General information
Base endpoint

To connect to Deriv's WebSocket APIs, you'll need to use the following base endpoint:

wss://ws.derivws.com/websockets/v3?app_id={app_id}

Make sure to replace {app_id} with the unique ID of the application you registered.

Rate limits

The rate limits for API requests can change over time. To find out the current limit, you can make a server status call and check the api_call_limits field. This ensures you always have the most up-to-date information.

Session validity

Your WebSocket session will time out after 2 minutes of inactivity. If there are no requests or responses during this time, the server will close the connection. To prevent this, send requests periodically to keep the connection alive.

For example, you can send a ping request or another simple call like time at regular intervals.

Create WebSocket

To get started with WebSockets, you must first create a new WebSocket instance. Here‚Äôs how you can do it:

Create a WebSocket instance

Us...

---

### Functions of API Calls
**URL:** https://developers.deriv.com/docs/functions-of-api-calls

**Implementation Examples:**
```text
method name
```

```text
1
```

```text
method name
```

```text
{
  "residence_list": 1, // Method Name
  "passthrough": {},   // Optional
  "req_id": 2          // Optional
}
```

```text
{
  "residence_list": 1, // Method Name
  "passthrough": {},   // Optional
  "req_id": 2          // Optional
}
```

```text
residence_list
```

```text
passthrough
```

```text
req_id
```

```text
passthrough
```

```text
req_id
```

```text
method name
```

```text
{
  "echo_req": {
    "req_id": 1,
    "residence_list": 1
  },
  "msg_type": "residence_list",
  "req_id": 1,
  "residence_list": [
    {
      "identity": {
        "services": {
          "idv": {
            "documents_supported": {},
            "has_visual_sample": 0,
            "is_country_supported": 0
          },
          "onfido": {
            "documents_supported": {
              "driving_licence": {
                "display_name": "Driving Licence"
              }
            },
            "is_country_supported": 0
          }
        }
      },
      "phone_idd": "35818",
      "text": "Aland Islands",
      "value": "ax"
    },
    {
      "identity": {
        "services": {
          "idv": {
            "documents_supported": {},
            "has_visual_sample": 0,
            "is_country_supported": 0
          },
          "onfido": {
            "documents_supported": {
              "driving_licence": {
                "display_name": "Driving Licence"
              },
              "national_identity_card": {
                "display_name": "National Identity Card"
              },
              "passport": {
                "display_name": "Passport"
              }
            },
            "is_country_supported": 1
          }
        }
      },
      "phone_idd": "355",
      "text": "Albania",
      "tin_format": [
        "^[A-Ta-t0-9]\\d{8}[A-Wa-w]$"
      ],
      "value": "al"
    }
  ]
}
```

```text
{
  "echo_req": {
    "req_id": 1,
    "residence_list": 1
  },
  "msg_type": "residence_list",
  "req_id": 1,
  "residence_list": [
    {
      "identity": {
        "services": {
          "idv": {
            "documents_supported": {},
            "has_visual_sample": 0,
            "is_country_supported": 0
          },
          "onfido": {
            "documents_supported": {
              "driving_licence": {
                "display_name": "Driving Licence"
              }
            },
            "is_country_supported": 0
          }
        }
      },
      "phone_idd": "35818",
      "text": "Aland Islands",
      "value": "ax"
    },
    {
      "identity": {
        "services": {
          "idv": {
            "documents_supported": {},
            "has_visual_sample": 0,
            "is_country_supported": 0
          },
          "onfido": {
            "documents_supported": {
              "driving_licence": {
                "display_name": "Driving Licence"
              },
              "national_identity_card": {
                "display_name": "National Identity Card"
              },
              "passport": {
                "display_name": "Passport"
              }
            },
            "is_country_supported": 1
          }
        }
      },
      "phone_idd": "355",
      "text": "Albania",
      "tin_format": [
        "^[A-Ta-t0-9]\\d{8}[A-Wa-w]$"
      ],
      "value": "al"
    }
  ]
}
```

```text
residence_list
```

```text
echo_req
```

```text
msg_type
```

```text
onmessage
```

```text
req_id
```

```text
socket.onmessage = (event) => {
  const receivedMessage = JSON.parse(event.data);

  switch (receivedMessage.msg_type) {
    case "residence_list":
      console.log("The residence list is:", receivedMessage.residence_list);
      break;
    case "other_request_identifier":
      console.log("The response:", receivedMessage.some_other_request_identifier);
      break;
    default:
      console.log("Received message:", receivedMessage);
      break;
  }
};
```

```text
socket.onmessage = (event) => {
  const receivedMessage = JSON.parse(event.data);

  switch (receivedMessage.msg_type) {
    case "residence_list":
      console.log("The residence list is:", receivedMessage.residence_list);
      break;
    case "other_request_identifier":
      console.log("The response:", receivedMessage.some_other_request_identifier);
      break;
    default:
      console.log("Received message:", receivedMessage);
      break;
  }
};
```

```text
msg_type
```

**Details:**
Request format

When interacting with Deriv‚Äôs WebSocket API, all requests must be sent as JSON in text frames, with one request per frame.

To help you manage the flow of requests and responses, each API call follows a standardized structure. This structure aids in caching, validation, and synchronizing requests and responses, making your WebSocket connection smoother and more efficient.

API call method name

Every request must include a method name field, which serves as a unique identifier. Typically, this is set to 1, but it can sometimes be a string.

üöß

The method name is always required, as it defines the specific data you‚Äôll receive from the WebSocket server.

Required fields

Each request contains required fields and may also have optional fields. For example, a residence_list call returns a list of countries and their two-letter codes, suitable for populating an account opening form.

Example request data for residence list:

JSON
{
  "residence_list": 1, // Method Name
  "p...

---

### Mark-up
**URL:** https://developers.deriv.com/docs/mark-up

**Details:**
If you build a platform or app that allows users to trade manually or via automation using Deriv APIs, you can earn up to 3% markup commission on every contract your users execute.

Example:

Let‚Äôs say a user places a $10 stake, and the potential payout without any markup is $17.20 if the trade wins.

If you set a 2% markup, your commission will be calculated on the potential payout: 2% of $17.20 = $0.34

With this adjusted stake, the user‚Äôs new potential payout becomes: $16.63

üöß

‚ö†Ô∏è Markup impacts the user‚Äôs profit. The higher the markup, the lower their payout.

Another Example:

Stake: USD 25.50

Payout: USD 50

Markup: 2% of USD 50 = USD 1

Client Balance Debited: USD 26.50

Other ways to monetize the Deriv API

You can make money with your Deriv API application in several ways:

Charge for Access
Offer your trading app for a subscription or one-time fee if it provides value to users.

Offer Premium Features
Charge extra for advanced features like real-time market data or advance...

---

### Error codes
**URL:** https://developers.deriv.com/docs/error-codes

**Details:**
General
Error Code	Message
AccountShouldBeReal	Only real accounts are allowed to open [_1] real accounts. Demo account cannot open real dxtrader.
AccountTypesMismatch	Transfer between real and virtual accounts is not allowed.
AccountWithDeposit	Change of currency is not allowed for an existing account with previous deposits.
AffiliateNotFound	N/A
AllowCopiersError	Copier can't be a trader.
AlreadyAgeVerified	Your age has already been verified.
AlreadyVerified	This account is already phone number verified.
AmountNotAllowed	The minimum amount for transfers is [_1] [_2] after conversion fees are deducted. Please adjust the amount.
AppGet	Not Found
AppRegister	Not Found
AppUpdate	N/A
AppropriatenessTestFailed	Failed to reach an acceptable trading experience score.
AuthenticateAccount	Please authenticate your [_1] account to proceed with the fund transfer.
AuthenticateAccountCreate	Please verify your [_1] account to proceed with account creation.
AuthorizationRequired	Please log in.
BadSess...

---

### How to contribute to our docs
**URL:** https://developers.deriv.com/docs/how-to-contribute-to-our-docs

**Implementation Examples:**
```text
git remote add upstream https://github.com/deriv-com/api-docs-readme.git
```

```text
git fetch upstream
```

```text
git rebase upstream/master
```

**Details:**
We value and appreciate all contributions to our documentation. You can contribute in the following ways:

Suggest edits option: Share your suggestions for improving the clarity or accuracy of our documentation.
Propose enhancements for our GitHub repository: Submit feature suggestions or improvements via our GitHub repository.
Submit a Pull Request (PR): You can submit a PR to our documents repository on GitHub for more direct involvement.
Post a message in our community forum to engage with other users and developers.
Suggest edits

To suggest edits to our documentation, follow these steps after logging in:

Click on the "Suggest Edits" button.
Locate the area in the Guides page where you would like to suggest edits and use the editor to make those changes.
Click "Suggest" and add a title to the suggested edits. You can also provide an optional description before submitting your suggestion.
[Optional] You can also add additional edits, preview the change, add a comment, and see the b...

---

### Frequently Asked Questions
**URL:** https://developers.deriv.com/docs/frequently-asked-questions

**Implementation Examples:**
```text
affiliate_token
```

```text
api_call_limits
```

```text
website_status
```

```text
api_call_limits
```

```text
website_status
```

```text
max_proposal_subscription
```

```text
max_requests_general
```

```text
max_requests_outcome
```

```text
max_requests_pricing
```

```text
website_status
```

**Details:**
How do you set up copy trading?

To set up copy trading on Deriv, follow these steps:

Log into your Deriv account: Ensure you‚Äôre logged into your Deriv account.
Access the Copy Trading feature: Read here to understand the developer API setup.
Choose a Trader to Copy: Review the list of available traders and their performance metrics to select a trader that aligns with your investment goals. You can use the Copy Trading Statistics API to view the performance of the selected trader.
Set Your Trading Parameters: Decide how much capital you want to allocate for copying trades and configure your risk management preferences.
Start Copying: Once set up, your account will automatically replicate the trades of your chosen trader. You can monitor and manage this at any time.

For more technical details on API setup for copy trading, Refer to the documentation here: Copy Trading.

How to add your affiliate token to your app and not miss any clients?

When creating new accounts, ensure to include...

---

### Keep connection live
**URL:** https://developers.deriv.com/docs/keep-connection-live

**Implementation Examples:**
```text
DerivAPIBasic
```

```text
import DerivAPIBasic from 'https://cdn.skypack.dev/@deriv/deriv-api/dist/DerivAPIBasic';
```

```text
app_id
```

```text
wss://ws.derivws.com/websockets/v3?app_id=${app_id}
```

```text
const connection = new WebSocket(
```

```text
);
```

```text
DerivAPIBasic
```

```text
const api = new DerivAPIBasic({ connection });
```

```text
proposal()
```

```text
const proposal = () => {  
  api.subscribe({  
    proposal: 1,  
    subscribe: 1,  
    amount: 10,  
    basis: 'payout',  
    contract_type: 'CALL',  
    currency: 'USD',  
    duration: 1,  
    duration_unit: 'm',  
    symbol: 'R_100',  
    barrier: '+0.1',  
  });  
};
```

```text
const proposal = () => {  
  api.subscribe({  
    proposal: 1,  
    subscribe: 1,  
    amount: 10,  
    basis: 'payout',  
    contract_type: 'CALL',  
    currency: 'USD',  
    duration: 1,  
    duration_unit: 'm',  
    symbol: 'R_100',  
    barrier: '+0.1',  
  });  
};
```

```text
ping()
```

```text
ping
```

```text
setInterval
```

```text
const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000);
};
```

```text
const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000);
};
```

```text
wsResponse()
```

```text
const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error: %s ', data.error.message);
    connection.removeEventListener('message', wsResponse, false);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details: %s', data.proposal.longcode);
    console.log('Ask Price: %s', data.proposal.display_value);
    console.log('Payout: %f', data.proposal.payout);
    console.log('Spot: %f', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};
```

```text
const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error: %s ', data.error.message);
    connection.removeEventListener('message', wsResponse, false);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details: %s', data.proposal.longcode);
    console.log('Ask Price: %s', data.proposal.display_value);
    console.log('Payout: %f', data.proposal.payout);
    console.log('Spot: %f', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};
```

```text
checkSignal()
```

```text
proposal()
```

```text
ping()
```

```text
connection.addEventListener('message', wsResponse)
```

```text
wsResponse()
```

```text
const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};
```

```text
const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};
```

```text
endCall()
```

```text
unsubscribe()
```

```text
proposal()
```

```text
const endCall = () => {
  connection.removeEventListener('message', wsResponse, false);
  proposal().unsubscribe();
};
```

```text
const endCall = () => {
  connection.removeEventListener('message', wsResponse, false);
  proposal().unsubscribe();
};
```

```text
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

const app_id = app_id; // Replace with your app_id if different.
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
const api = new DerivAPIBasic({ connection });

const proposal = () => {
  api.subscribe({
    proposal: 1,
    subscribe: 1,
    amount: 10,
    basis: 'payout',
    contract_type: 'CALL',
    currency: 'USD',
    duration: 1,
    duration_unit: 'm',
    symbol: 'R_100',
    barrier: '+0.1',
  });
};

const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000); // Sends a ping message every 30 seconds
};

const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error:', data.error.message);
    connection.removeEventListener('message', wsResponse);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details:', data.proposal.longcode);
    console.log('Ask Price:', data.proposal.display_value);
    console.log('Payout:', data.proposal.payout);
    console.log('Spot:', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};

const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};

// Browser-specific functionality
if (typeof document !== 'undefined') {
  const keep_alive_button = document.querySelector('#keep_alive');
  const end_call_button = document.querySelector('#end_call');

  keep_alive_button.addEventListener('click', checkSignal);
  end_call_button.addEventListener('click', () => {
    connection.removeEventListener('message', wsResponse);
    proposal().unsubscribe();
  });
} else {
  // For Node.js environment: start the signal check immediately
  checkSignal();
}

/*
Instructions:

1. **Install Node.js**: Ensure you have Node.js installed from https://nodejs.org/.
2. **Install Deriv API Package**: Use npm to install the Deriv API package by running:
npm install @deriv/deriv-api
3. **Save the Code**: Save the code in a file, e.g., `websocket_example.js`.
4. **Run in Node.js**:
- In your terminal, navigate to the directory where you saved the file.
- Run the script using:
  ```
  node websocket_example.js
  ```
5. **Run in a Browser**:
- Include the script in your HTML page, and ensure there are two buttons with IDs `keep_alive` and `end_call`.
- Use the `keep_alive` button to start the signal check and the `end_call` button to unsubscribe from the proposal and stop receiving messages.

Replace the `app_id` in the URL if you have a different app ID.
*/
```

```text
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

const app_id = app_id; // Replace with your app_id if different.
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
const api = new DerivAPIBasic({ connection });

const proposal = () => {
  api.subscribe({
    proposal: 1,
    subscribe: 1,
    amount: 10,
    basis: 'payout',
    contract_type: 'CALL',
    currency: 'USD',
    duration: 1,
    duration_unit: 'm',
    symbol: 'R_100',
    barrier: '+0.1',
  });
};

const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000); // Sends a ping message every 30 seconds
};

const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error:', data.error.message);
    connection.removeEventListener('message', wsResponse);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details:', data.proposal.longcode);
    console.log('Ask Price:', data.proposal.display_value);
    console.log('Payout:', data.proposal.payout);
    console.log('Spot:', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};

const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};

// Browser-specific functionality
if (typeof document !== 'undefined') {
  const keep_alive_button = document.querySelector('#keep_alive');
  const end_call_button = document.querySelector('#end_call');

  keep_alive_button.addEventListener('click', checkSignal);
  end_call_button.addEventListener('click', () => {
    connection.removeEventListener('message', wsResponse);
    proposal().unsubscribe();
  });
} else {
  // For Node.js environment: start the signal check immediately
  checkSignal();
}

/*
Instructions:

1. **Install Node.js**: Ensure you have Node.js installed from https://nodejs.org/.
2. **Install Deriv API Package**: Use npm to install the Deriv API package by running:
npm install @deriv/deriv-api
3. **Save the Code**: Save the code in a file, e.g., `websocket_example.js`.
4. **Run in Node.js**:
- In your terminal, navigate to the directory where you saved the file.
- Run the script using:
  ```
  node websocket_example.js
  ```
5. **Run in a Browser**:
- Include the script in your HTML page, and ensure there are two buttons with IDs `keep_alive` and `end_call`.
- Use the `keep_alive` button to start the signal check and the `end_call` button to unsubscribe from the proposal and stop receiving messages.

Replace the `app_id` in the URL if you have a different app ID.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a proposal subscription request
    func sendProposalSubscription() {
        let proposalRequest = [
            "proposal": 1,
            "subscribe": 1,
            "amount": 10,
            "basis": "payout",
            "contract_type": "CALL",
            "currency": "USD",
            "duration": 1,
            "duration_unit": "m",
            "symbol": "R_100",
            "barrier": "+0.1"
        ] as [String: Any]
        
        if let proposalData = try? JSONSerialization.data(withJSONObject: proposalRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(proposalData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send proposal subscription: \(error.localizedDescription)")
                } else {
                    print("Proposal subscription sent.")
                }
            }
        }
    }
    
    // Function to send a ping message every 30 seconds
    func startPing() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            let pingMessage = URLSessionWebSocketTask.Message.string("{\"ping\": 1}")
            webSocketTask?.send(pingMessage) { error in
                if let error = error {
                    print("[error] Failed to send ping: \(error.localizedDescription)")
                } else {
                    print("Ping sent to keep connection alive.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the proposal and ping response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "proposal", let proposal = data["proposal"] as? [String: Any] {
            print("Details: \(proposal["longcode"] ?? "")")
            print("Ask Price: \(proposal["display_value"] ?? "")")
            print("Payout: \(proposal["payout"] ?? "")")
            print("Spot: \(proposal["spot"] ?? "")")
        } else if data["msg_type"] as? String == "ping" {
            print("[Ping] Ping response received.")
        }
    }
    
    // Start sending the proposal subscription and pinging the server
    sendProposalSubscription()
    startPing()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
 * Instructions to Run:
 * 1. Ensure Swift is installed on your machine.
 * 2. Save this code in a file, for example, `WebSocketClient.swift`.
 * 3. Open a terminal, navigate to the directory where you saved the file, and run:
 *      swift WebSocketClient.swift
 * 4. The script connects to the WebSocket server, sends a proposal subscription, and sends a ping every 30 seconds to keep the connection alive.
 */
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a proposal subscription request
    func sendProposalSubscription() {
        let proposalRequest = [
            "proposal": 1,
            "subscribe": 1,
            "amount": 10,
            "basis": "payout",
            "contract_type": "CALL",
            "currency": "USD",
            "duration": 1,
            "duration_unit": "m",
            "symbol": "R_100",
            "barrier": "+0.1"
        ] as [String: Any]
        
        if let proposalData = try? JSONSerialization.data(withJSONObject: proposalRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(proposalData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send proposal subscription: \(error.localizedDescription)")
                } else {
                    print("Proposal subscription sent.")
                }
            }
        }
    }
    
    // Function to send a ping message every 30 seconds
    func startPing() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            let pingMessage = URLSessionWebSocketTask.Message.string("{\"ping\": 1}")
            webSocketTask?.send(pingMessage) { error in
                if let error = error {
                    print("[error] Failed to send ping: \(error.localizedDescription)")
                } else {
                    print("Ping sent to keep connection alive.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the proposal and ping response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "proposal", let proposal = data["proposal"] as? [String: Any] {
            print("Details: \(proposal["longcode"] ?? "")")
            print("Ask Price: \(proposal["display_value"] ?? "")")
            print("Payout: \(proposal["payout"] ?? "")")
            print("Spot: \(proposal["spot"] ?? "")")
        } else if data["msg_type"] as? String == "ping" {
            print("[Ping] Ping response received.")
        }
    }
    
    // Start sending the proposal subscription and pinging the server
    sendProposalSubscription()
    startPing()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
 * Instructions to Run:
 * 1. Ensure Swift is installed on your machine.
 * 2. Save this code in a file, for example, `WebSocketClient.swift`.
 * 3. Open a terminal, navigate to the directory where you saved the file, and run:
 *      swift WebSocketClient.swift
 * 4. The script connects to the WebSocket server, sends a proposal subscription, and sends a ping every 30 seconds to keep the connection alive.
 */
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{time::interval, sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[open] Connection established");

    // Proposal request JSON
    let proposal_request = json!({
        "proposal": 1,
        "subscribe": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    });

    // Clone `socket` for the ping task and start pinging every 30 seconds
    let ping_socket = Arc::clone(&socket);
    let ping_task = spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            let mut socket = ping_socket.lock().await;
            if socket.send(Message::Text(json!({ "ping": 1 }).to_string())).await.is_ok() {
                println!("[ping] Ping sent to keep connection alive.");
            }
        }
    });

    // Clone `socket` for sending the proposal
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(proposal_request.to_string())).await.is_ok() {
            println!("Proposal subscription sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if let Some(proposal) = data.get("proposal") {
                        println!("Details: {}", proposal["longcode"]);
                        println!("Ask Price: {}", proposal["display_value"]);
                        println!("Payout: {}", proposal["payout"]);
                        println!("Spot: {}", proposal["spot"]);
                    } else if data.get("msg_type").unwrap_or(&json!("")) == "ping" {
                        println!("[Ping] Ping response received.");
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(ping_task, send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{time::interval, sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[open] Connection established");

    // Proposal request JSON
    let proposal_request = json!({
        "proposal": 1,
        "subscribe": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    });

    // Clone `socket` for the ping task and start pinging every 30 seconds
    let ping_socket = Arc::clone(&socket);
    let ping_task = spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            let mut socket = ping_socket.lock().await;
            if socket.send(Message::Text(json!({ "ping": 1 }).to_string())).await.is_ok() {
                println!("[ping] Ping sent to keep connection alive.");
            }
        }
    });

    // Clone `socket` for sending the proposal
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(proposal_request.to_string())).await.is_ok() {
            println!("Proposal subscription sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if let Some(proposal) = data.get("proposal") {
                        println!("Details: {}", proposal["longcode"]);
                        println!("Ask Price: {}", proposal["display_value"]);
                        println!("Payout: {}", proposal["payout"]);
                        println!("Spot: {}", proposal["spot"]);
                    } else if data.get("msg_type").unwrap_or(&json!("")) == "ping" {
                        println!("[Ping] Ping response received.");
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(ping_task, send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a proposal subscription request
    $proposal_request = json_encode([
        "proposal" => 1,
        "subscribe" => 1,
        "amount" => 10,
        "basis" => "payout",
        "contract_type" => "CALL",
        "currency" => "USD",
        "duration" => 1,
        "duration_unit" => "m",
        "symbol" => "R_100",
        "barrier" => "+0.1"
    ]);
    $client->send($proposal_request);
    echo "[sent] Proposal subscription sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "proposal") {
            $proposal = $data["proposal"];
            echo "[proposal] Details: {$proposal['longcode']}\n";
            echo "[proposal] Ask Price: {$proposal['display_value']}\n";
            echo "[proposal] Payout: {$proposal['payout']}\n";
            echo "[proposal] Spot: {$proposal['spot']}\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `websocket_client.php`.
6. Run the code from the command line:

   php websocket_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a proposal subscription request
    $proposal_request = json_encode([
        "proposal" => 1,
        "subscribe" => 1,
        "amount" => 10,
        "basis" => "payout",
        "contract_type" => "CALL",
        "currency" => "USD",
        "duration" => 1,
        "duration_unit" => "m",
        "symbol" => "R_100",
        "barrier" => "+0.1"
    ]);
    $client->send($proposal_request);
    echo "[sent] Proposal subscription sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "proposal") {
            $proposal = $data["proposal"];
            echo "[proposal] Details: {$proposal['longcode']}\n";
            echo "[proposal] Ask Price: {$proposal['display_value']}\n";
            echo "[proposal] Payout: {$proposal['payout']}\n";
            echo "[proposal] Spot: {$proposal['spot']}\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `websocket_client.php`.
6. Run the code from the command line:

   php websocket_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// Define constants
const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//Replace with your app_id
)

// ProposalRequest defines the structure of the proposal subscription request
type ProposalRequest struct {
	Proposal      int    `json:"proposal"`
	Subscribe     int    `json:"subscribe"`
	Amount        int    `json:"amount"`
	Basis         string `json:"basis"`
	ContractType  string `json:"contract_type"`
	Currency      string `json:"currency"`
	Duration      int    `json:"duration"`
	DurationUnit  string `json:"duration_unit"`
	Symbol        string `json:"symbol"`
	Barrier       string `json:"barrier"`
}

func main() {
	// Set up WebSocket connection context
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish a WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("WebSocket connection established.")

	// Send initial proposal subscription request
	err = sendProposalRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send proposal request: %v", err)
	}

	// Start keep-alive ping
	go keepAlivePing(ctx, conn)

	// Handle incoming messages
	handleResponses(ctx, conn)
}

// sendProposalRequest sends a proposal subscription request to the WebSocket server
func sendProposalRequest(ctx context.Context, conn *websocket.Conn) error {
	// Construct proposal subscription request
	proposal := ProposalRequest{
		Proposal:     1,
		Subscribe:    1,
		Amount:       10,
		Basis:        "payout",
		ContractType: "CALL",
		Currency:     "USD",
		Duration:     1,
		DurationUnit: "m",
		Symbol:       "R_100",
		Barrier:      "+0.1",
	}
	fmt.Println("Sending proposal subscription...")

	return wsjson.Write(ctx, conn, proposal)
}

// keepAlivePing sends a ping message every 30 seconds to keep the connection alive
func keepAlivePing(ctx context.Context, conn *websocket.Conn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Send ping message
			pingMsg := map[string]int{"ping": 1}
			err := wsjson.Write(ctx, conn, pingMsg)
			if err != nil {
				log.Printf("Ping failed: %v", err)
				return
			}
			fmt.Println("Ping sent.")
		case <-ctx.Done():
			return
		}
	}
}

// handleResponses listens for and processes messages received from the WebSocket server
func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}
		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		// Process response messages
		msgType := response["msg_type"]
		switch msgType {
		case "proposal":
			// Print proposal details
			proposal := response["proposal"].(map[string]interface{})
			fmt.Printf("Details: %v\n", proposal["longcode"])
			fmt.Printf("Ask Price: %v\n", proposal["display_value"])
			fmt.Printf("Payout: %v\n", proposal["payout"])
			fmt.Printf("Spot: %v\n", proposal["spot"])
		case "ping":
			fmt.Println("[Ping] Ping response received.")
		default:
			fmt.Printf("Received message: %v\n", response)
		}
	}
}

/*
Instructions to run the code locally:

1. Install Go: Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.

2. Save the code:
   - Save this code into a file named `connect.go`.

3. Initialize a Go module:
   - Open a terminal in the directory containing `connect.go`.
   - Run `go mod init app` to initialize a new Go module.
   - Run `go get nhooyr.io/websocket` to install the WebSocket package dependency.

4. Run the code:
   - Execute the code using the command `go run connect.go`.
   - Alternatively, you can build and run the executable:
     ```
     go build -o connect connect.go
     ./connect
     ```
5. Replace `app_id=1089` with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// Define constants
const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//Replace with your app_id
)

// ProposalRequest defines the structure of the proposal subscription request
type ProposalRequest struct {
	Proposal      int    `json:"proposal"`
	Subscribe     int    `json:"subscribe"`
	Amount        int    `json:"amount"`
	Basis         string `json:"basis"`
	ContractType  string `json:"contract_type"`
	Currency      string `json:"currency"`
	Duration      int    `json:"duration"`
	DurationUnit  string `json:"duration_unit"`
	Symbol        string `json:"symbol"`
	Barrier       string `json:"barrier"`
}

func main() {
	// Set up WebSocket connection context
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish a WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("WebSocket connection established.")

	// Send initial proposal subscription request
	err = sendProposalRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send proposal request: %v", err)
	}

	// Start keep-alive ping
	go keepAlivePing(ctx, conn)

	// Handle incoming messages
	handleResponses(ctx, conn)
}

// sendProposalRequest sends a proposal subscription request to the WebSocket server
func sendProposalRequest(ctx context.Context, conn *websocket.Conn) error {
	// Construct proposal subscription request
	proposal := ProposalRequest{
		Proposal:     1,
		Subscribe:    1,
		Amount:       10,
		Basis:        "payout",
		ContractType: "CALL",
		Currency:     "USD",
		Duration:     1,
		DurationUnit: "m",
		Symbol:       "R_100",
		Barrier:      "+0.1",
	}
	fmt.Println("Sending proposal subscription...")

	return wsjson.Write(ctx, conn, proposal)
}

// keepAlivePing sends a ping message every 30 seconds to keep the connection alive
func keepAlivePing(ctx context.Context, conn *websocket.Conn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Send ping message
			pingMsg := map[string]int{"ping": 1}
			err := wsjson.Write(ctx, conn, pingMsg)
			if err != nil {
				log.Printf("Ping failed: %v", err)
				return
			}
			fmt.Println("Ping sent.")
		case <-ctx.Done():
			return
		}
	}
}

// handleResponses listens for and processes messages received from the WebSocket server
func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}
		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		// Process response messages
		msgType := response["msg_type"]
		switch msgType {
		case "proposal":
			// Print proposal details
			proposal := response["proposal"].(map[string]interface{})
			fmt.Printf("Details: %v\n", proposal["longcode"])
			fmt.Printf("Ask Price: %v\n", proposal["display_value"])
			fmt.Printf("Payout: %v\n", proposal["payout"])
			fmt.Printf("Spot: %v\n", proposal["spot"])
		case "ping":
			fmt.Println("[Ping] Ping response received.")
		default:
			fmt.Printf("Received message: %v\n", response)
		}
	}
}

/*
Instructions to run the code locally:

1. Install Go: Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.

2. Save the code:
   - Save this code into a file named `connect.go`.

3. Initialize a Go module:
   - Open a terminal in the directory containing `connect.go`.
   - Run `go mod init app` to initialize a new Go module.
   - Run `go get nhooyr.io/websocket` to install the WebSocket package dependency.

4. Run the code:
   - Execute the code using the command `go run connect.go`.
   - Alternatively, you can build and run the executable:
     ```
     go build -o connect connect.go
     ./connect
     ```
5. Replace `app_id=1089` with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed
    private static readonly int pingInterval = 30000; // Ping every 30 seconds

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("WebSocket connection established.");

            // Send initial proposal subscription request
            await SendProposalSubscription(webSocket);

            // Start a task to send pings to keep connection alive
            Task keepAlivePingTask = KeepAlivePing(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);

            // Ensure the keep-alive ping task finishes
            await keepAlivePingTask;
        }
    }

    private static async Task SendProposalSubscription(ClientWebSocket webSocket)
    {
        var proposalRequest = new
        {
            proposal = 1,
            subscribe = 1,
            amount = 10,
            basis = "payout",
            contract_type = "CALL",
            currency = "USD",
            duration = 1,
            duration_unit = "m",
            symbol = "R_100",
            barrier = "+0.1"
        };

        string requestJson = JsonSerializer.Serialize(proposalRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("Proposal subscription sent.");
    }

    private static async Task KeepAlivePing(ClientWebSocket webSocket)
    {
        while (webSocket.State == WebSocketState.Open)
        {
            await Task.Delay(pingInterval);

            var pingRequest = new { ping = 1 };
            string pingJson = JsonSerializer.Serialize(pingRequest);
            var pingBytes = Encoding.UTF8.GetBytes(pingJson);
            await webSocket.SendAsync(new ArraySegment<byte>(pingBytes), WebSocketMessageType.Text, true, CancellationToken.None);
            Console.WriteLine("Ping sent to keep connection alive.");
        }
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[1024 * 4];

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        else
        {
            string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
            var data = JsonSerializer.Deserialize<JsonElement>(response);

            if (data.TryGetProperty("error", out var error))
            {
                Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                break;
            }

            if (data.TryGetProperty("msg_type", out var msgType))
            {
                if (msgType.GetString() == "proposal")
                {
                    var proposal = data.GetProperty("proposal");

                    // Extract proposal details with type-checking
                    string longcode = proposal.GetProperty("longcode").GetString();
                    Console.WriteLine($"Details: {longcode}");

                    string displayValue = proposal.GetProperty("display_value").GetRawText();
                    Console.WriteLine($"Ask Price: {displayValue}");

                    string payout = proposal.GetProperty("payout").GetRawText();
                    Console.WriteLine($"Payout: {payout}");

                    string spot = proposal.GetProperty("spot").GetRawText();
                    Console.WriteLine($"Spot: {spot}");
                }
                else if (msgType.GetString() == "ping")
                {
                    Console.WriteLine("[Ping] Ping response received.");
                }
            }
        }
    }
}
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed
    private static readonly int pingInterval = 30000; // Ping every 30 seconds

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("WebSocket connection established.");

            // Send initial proposal subscription request
            await SendProposalSubscription(webSocket);

            // Start a task to send pings to keep connection alive
            Task keepAlivePingTask = KeepAlivePing(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);

            // Ensure the keep-alive ping task finishes
            await keepAlivePingTask;
        }
    }

    private static async Task SendProposalSubscription(ClientWebSocket webSocket)
    {
        var proposalRequest = new
        {
            proposal = 1,
            subscribe = 1,
            amount = 10,
            basis = "payout",
            contract_type = "CALL",
            currency = "USD",
            duration = 1,
            duration_unit = "m",
            symbol = "R_100",
            barrier = "+0.1"
        };

        string requestJson = JsonSerializer.Serialize(proposalRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("Proposal subscription sent.");
    }

    private static async Task KeepAlivePing(ClientWebSocket webSocket)
    {
        while (webSocket.State == WebSocketState.Open)
        {
            await Task.Delay(pingInterval);

            var pingRequest = new { ping = 1 };
            string pingJson = JsonSerializer.Serialize(pingRequest);
            var pingBytes = Encoding.UTF8.GetBytes(pingJson);
            await webSocket.SendAsync(new ArraySegment<byte>(pingBytes), WebSocketMessageType.Text, true, CancellationToken.None);
            Console.WriteLine("Ping sent to keep connection alive.");
        }
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[1024 * 4];

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        else
        {
            string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
            var data = JsonSerializer.Deserialize<JsonElement>(response);

            if (data.TryGetProperty("error", out var error))
            {
                Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                break;
            }

            if (data.TryGetProperty("msg_type", out var msgType))
            {
                if (msgType.GetString() == "proposal")
                {
                    var proposal = data.GetProperty("proposal");

                    // Extract proposal details with type-checking
                    string longcode = proposal.GetProperty("longcode").GetString();
                    Console.WriteLine($"Details: {longcode}");

                    string displayValue = proposal.GetProperty("display_value").GetRawText();
                    Console.WriteLine($"Ask Price: {displayValue}");

                    string payout = proposal.GetProperty("payout").GetRawText();
                    Console.WriteLine($"Payout: {payout}");

                    string spot = proposal.GetProperty("spot").GetRawText();
                    Console.WriteLine($"Spot: {spot}");
                }
                else if (msgType.GetString() == "ping")
                {
                    Console.WriteLine("[Ping] Ping response received.");
                }
            }
        }
    }
}
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>
#include <time.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a proposal subscription message
void send_proposal(struct lws *wsi) {
    const char *proposal_msg = "{\"proposal\": 1, \"subscribe\": 1, \"amount\": 10, \"basis\": \"payout\", \"contract_type\": \"CALL\", \"currency\": \"USD\", \"duration\": 1, \"duration_unit\": \"m\", \"symbol\": \"R_100\", \"barrier\": \"+0.1\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], proposal_msg, strlen(proposal_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(proposal_msg), LWS_WRITE_TEXT);
    lwsl_user("Proposal subscription sent\n");
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_proposal(wsi);  // Send proposal on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>
#include <time.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a proposal subscription message
void send_proposal(struct lws *wsi) {
    const char *proposal_msg = "{\"proposal\": 1, \"subscribe\": 1, \"amount\": 10, \"basis\": \"payout\", \"contract_type\": \"CALL\", \"currency\": \"USD\", \"duration\": 1, \"duration_unit\": \"m\", \"symbol\": \"R_100\", \"barrier\": \"+0.1\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], proposal_msg, strlen(proposal_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(proposal_msg), LWS_WRITE_TEXT);
    lwsl_user("Proposal subscription sent\n");
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_proposal(wsi);  // Send proposal on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
import asyncio
from deriv_api import DerivAPI
from deriv_api.subscription_manager import SubscriptionManager

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    # Initialize the SubscriptionManager
    subscription_manager = SubscriptionManager(api)

    # Define the proposal request
    proposal_request = {
        "proposal": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    }

    # Subscribe to the proposal stream
    try:
        proposal_stream = await subscription_manager.subscribe(proposal_request)
        print("Subscribed to proposal stream")

        # Handle incoming messages and print formatted proposal details
        proposal_stream.subscribe(
            on_next=lambda message: print_proposal_details(message),
            on_error=lambda e: print(f"Error: {e}"),
            on_completed=lambda: print("Subscription completed")
        )

        # Function to send a ping every 30 seconds
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop and proposal subscription concurrently
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print proposal details
def print_proposal_details(message):
    data = message.get("proposal", {})
    if data:
        print(f"Details: {data.get('longcode', 'N/A')}")
        print(f"Ask Price: {data.get('display_value', 'N/A')}")
        print(f"Payout: {data.get('payout', 'N/A')}")
        print(f"Spot: {data.get('spot', 'N/A')}")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

"""
Instructions to run this code:

1. **Install the Required Library**:
   - Ensure that `python-deriv-api` is installed. If not, install it using:
     ```
     pip install python-deriv-api
     ```
2. **Save and Run the Code**:
   - Save this code to a file, e.g., `connect.py`.
   - Run the script using:
     ```
     python connect.py
     ```
3. **Configuration**:
   - Replace the `app_id` variable with your actual Deriv app ID if needed.

This script will connect to the Deriv API WebSocket, subscribe to a proposal stream, print proposal details, and send a ping every 30 seconds to keep the connection active. 
"""
```

```text
import asyncio
from deriv_api import DerivAPI
from deriv_api.subscription_manager import SubscriptionManager

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    # Initialize the SubscriptionManager
    subscription_manager = SubscriptionManager(api)

    # Define the proposal request
    proposal_request = {
        "proposal": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    }

    # Subscribe to the proposal stream
    try:
        proposal_stream = await subscription_manager.subscribe(proposal_request)
        print("Subscribed to proposal stream")

        # Handle incoming messages and print formatted proposal details
        proposal_stream.subscribe(
            on_next=lambda message: print_proposal_details(message),
            on_error=lambda e: print(f"Error: {e}"),
            on_completed=lambda: print("Subscription completed")
        )

        # Function to send a ping every 30 seconds
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop and proposal subscription concurrently
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print proposal details
def print_proposal_details(message):
    data = message.get("proposal", {})
    if data:
        print(f"Details: {data.get('longcode', 'N/A')}")
        print(f"Ask Price: {data.get('display_value', 'N/A')}")
        print(f"Payout: {data.get('payout', 'N/A')}")
        print(f"Spot: {data.get('spot', 'N/A')}")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

"""
Instructions to run this code:

1. **Install the Required Library**:
   - Ensure that `python-deriv-api` is installed. If not, install it using:
     ```
     pip install python-deriv-api
     ```
2. **Save and Run the Code**:
   - Save this code to a file, e.g., `connect.py`.
   - Run the script using:
     ```
     python connect.py
     ```
3. **Configuration**:
   - Replace the `app_id` variable with your actual Deriv app ID if needed.

This script will connect to the Deriv API WebSocket, subscribe to a proposal stream, print proposal details, and send a ping every 30 seconds to keep the connection active. 
"""
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Define a ping interval in seconds
my $ping_interval = 30;

# Function to send a proposal subscription request
sub send_proposal {
    my $connection = shift;
    my $proposal_request = encode_json({
        proposal       => 1,
        subscribe      => 1,
        amount         => 10,
        basis          => 'payout',
        contract_type  => 'CALL',
        currency       => 'USD',
        duration       => 1,
        duration_unit  => 'm',
        symbol         => 'R_100',
        barrier        => '+0.1'
    });
    $connection->send($proposal_request);
    say "Proposal subscription sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "WebSocket connection established.";

    # Set up a repeating timer to send ping every 30 seconds
    my $ping_timer = AnyEvent->timer(
        after    => $ping_interval,
        interval => $ping_interval,
        cb       => sub {
            $connection->send(encode_json({ ping => 1 }));
            say "Ping sent to keep connection alive.";
        }
    );

    # Send the initial proposal subscription
    send_proposal($connection);

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;
        my $data = decode_json($message->body);

        # Handle errors
        if ($data->{error}) {
            say "[Error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle proposal messages
        if ($data->{msg_type} && $data->{msg_type} eq 'proposal') {
            my $proposal = $data->{proposal};
            say "Details: $proposal->{longcode}";
            say "Ask Price: $proposal->{display_value}";
            say "Payout: $proposal->{payout}";
            say "Spot: $proposal->{spot}";
        } elsif ($data->{msg_type} && $data->{msg_type} eq 'ping') {
            say "[Ping] Ping response received.";
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
        $ping_timer = undef;  # Stop the ping timer
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Define a ping interval in seconds
my $ping_interval = 30;

# Function to send a proposal subscription request
sub send_proposal {
    my $connection = shift;
    my $proposal_request = encode_json({
        proposal       => 1,
        subscribe      => 1,
        amount         => 10,
        basis          => 'payout',
        contract_type  => 'CALL',
        currency       => 'USD',
        duration       => 1,
        duration_unit  => 'm',
        symbol         => 'R_100',
        barrier        => '+0.1'
    });
    $connection->send($proposal_request);
    say "Proposal subscription sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "WebSocket connection established.";

    # Set up a repeating timer to send ping every 30 seconds
    my $ping_timer = AnyEvent->timer(
        after    => $ping_interval,
        interval => $ping_interval,
        cb       => sub {
            $connection->send(encode_json({ ping => 1 }));
            say "Ping sent to keep connection alive.";
        }
    );

    # Send the initial proposal subscription
    send_proposal($connection);

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;
        my $data = decode_json($message->body);

        # Handle errors
        if ($data->{error}) {
            say "[Error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle proposal messages
        if ($data->{msg_type} && $data->{msg_type} eq 'proposal') {
            my $proposal = $data->{proposal};
            say "Details: $proposal->{longcode}";
            say "Ask Price: $proposal->{display_value}";
            say "Payout: $proposal->{payout}";
            say "Spot: $proposal->{spot}";
        } elsif ($data->{msg_type} && $data->{msg_type} eq 'ping') {
            say "[Ping] Ping response received.";
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
        $ping_timer = undef;  # Stop the ping timer
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

**Details:**
Follow these steps to maintain a live WebSocket connection with the Deriv API:

Import the Deriv API library

Import the DerivAPIBasic library, which provides an interface to interact with the Deriv WebSocket API:

import DerivAPIBasic from 'https://cdn.skypack.dev/@deriv/deriv-api/dist/DerivAPIBasic';

Establish a WebSocket connection

Create a WebSocket connection using your app_id and the API URL:

(wss://ws.derivws.com/websockets/v3?app_id=${app_id}).

This connection will be used to send and receive messages from the Deriv API.

const connection = new WebSocket(wss://ws.derivws.com/websockets/v3?app_id=${app_id});

Create an API object

Create an instance of DerivAPIBasic, passing the WebSocket connection as a parameter.

This object interacts with the API, such as subscribing to proposals and sending pings.

const api = new DerivAPIBasic({ connection });

Send a proposal subscription

The proposal() function subscribes to a proposal and sends details such as the trade amount, cur...

---

### Check website status
**URL:** https://developers.deriv.com/docs/check-website-status

**Implementation Examples:**
```text
DerivAPIBasic
```

```text
app_id
```

```text
DerivAPIBasic
```

```text
websiteStatusResponse
```

```text
getWebsiteStatus
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication,replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the website status response
const handleWebsiteStatusResponse = async (response) => {
  const data = JSON.parse(response.data);

  // If there's an error in the response, log the error message and disconnect
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'website_status', log the relevant details
  if (data.msg_type === 'website_status') {
    const websiteStatus = data.website_status;
    console.log('Website Status:', websiteStatus.site_status);
    console.log('Available Languages:', websiteStatus.supported_languages);
    console.log('Terms & Conditions Version:', websiteStatus.terms_conditions_version);
    console.log('Broker Codes:', websiteStatus.broker_codes);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleWebsiteStatusResponse);
};

// Function to request website status from the API
const requestWebsiteStatus = async () => {
  connection.addEventListener('message', handleWebsiteStatusResponse); // Add the event listener for response
  await api.websiteStatus(); // Send the website status request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const website_status_button = document.querySelector('#websiteStatus');
  if (website_status_button) {
    website_status_button.addEventListener('click', requestWebsiteStatus);
  }
} else {
  // If running in Node.js, directly call the function
  requestWebsiteStatus();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `connect.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node connect.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="websiteStatus">Check Website Status</button>`
 * - Open the HTML file in a browser, and click the button to check the website status.
 */
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication,replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the website status response
const handleWebsiteStatusResponse = async (response) => {
  const data = JSON.parse(response.data);

  // If there's an error in the response, log the error message and disconnect
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'website_status', log the relevant details
  if (data.msg_type === 'website_status') {
    const websiteStatus = data.website_status;
    console.log('Website Status:', websiteStatus.site_status);
    console.log('Available Languages:', websiteStatus.supported_languages);
    console.log('Terms & Conditions Version:', websiteStatus.terms_conditions_version);
    console.log('Broker Codes:', websiteStatus.broker_codes);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleWebsiteStatusResponse);
};

// Function to request website status from the API
const requestWebsiteStatus = async () => {
  connection.addEventListener('message', handleWebsiteStatusResponse); // Add the event listener for response
  await api.websiteStatus(); // Send the website status request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const website_status_button = document.querySelector('#websiteStatus');
  if (website_status_button) {
    website_status_button.addEventListener('click', requestWebsiteStatus);
  }
} else {
  // If running in Node.js, directly call the function
  requestWebsiteStatus();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `connect.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node connect.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="websiteStatus">Check Website Status</button>`
 * - Open the HTML file in a browser, and click the button to check the website status.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send website status request
                    JsonObject websiteStatusRequest = new JsonObject();
                    websiteStatusRequest.addProperty("website_status", 1);
                    send(websiteStatusRequest.toString());
                    System.out.println("[sent] Website status request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("website_status".equals(data.get("msg_type").getAsString())) {
                        JsonObject websiteStatus = data.getAsJsonObject("website_status");
                        String siteStatus = websiteStatus.get("site_status").getAsString();
                        System.out.println("Website Status: " + siteStatus);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.


 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send website status request
                    JsonObject websiteStatusRequest = new JsonObject();
                    websiteStatusRequest.addProperty("website_status", 1);
                    send(websiteStatusRequest.toString());
                    System.out.println("[sent] Website status request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("website_status".equals(data.get("msg_type").getAsString())) {
                        JsonObject websiteStatus = data.getAsJsonObject("website_status");
                        String siteStatus = websiteStatus.get("site_status").getAsString();
                        System.out.println("Website Status: " + siteStatus);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.


 */
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a website status request
sub send_website_status {
    my $connection = shift;
    my $website_status_request = encode_json({ website_status => 1 });
    $connection->send($website_status_request);
    say "[status] Website status request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send website status request immediately
    send_website_status($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle website status response
        if ($data->{msg_type} && $data->{msg_type} eq 'website_status') {
            my $website_status = $data->{website_status};
            say "Site Status: " . ($website_status->{site_status} // 'Unknown');
            say "Supported Languages: " . join(", ", @{$website_status->{supported_languages}});
            $connection->close; # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, request the website status, and print the response.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a website status request
sub send_website_status {
    my $connection = shift;
    my $website_status_request = encode_json({ website_status => 1 });
    $connection->send($website_status_request);
    say "[status] Website status request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send website status request immediately
    send_website_status($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle website status response
        if ($data->{msg_type} && $data->{msg_type} eq 'website_status') {
            my $website_status = $data->{website_status};
            say "Site Status: " . ($website_status->{site_status} // 'Unknown');
            say "Supported Languages: " . join(", ", @{$website_status->{supported_languages}});
            $connection->close; # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, request the website status, and print the response.
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a website status request
    $website_status_request = json_encode(["website_status" => 1]);
    $client->send($website_status_request);
    echo "[sent] Website status request sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "website_status") {
            $website_status = $data["website_status"];

            // Print important information from the website status
            echo "[status] Website Status:\n";
            echo "  - Site Status: " . ($website_status["site_status"] ?? "N/A") . "\n";
            echo "  - Supported Languages: " . implode(", ", $website_status["supported_languages"] ?? []) . "\n";

            // Extract and print currency information
            echo "  - Currencies Config:\n";
            foreach ($website_status["currencies_config"] ?? [] as $currency => $config) {
                echo "    * {$currency} ({$config['name']}):\n";
                echo "      - Type: " . ($config["type"] ?? "N/A") . "\n";
                echo "      - Fractional Digits: " . ($config["fractional_digits"] ?? "N/A") . "\n";
                echo "      - Deposit Suspended: " . ($config["is_deposit_suspended"] ? "Yes" : "No") . "\n";
                echo "      - Withdrawal Suspended: " . ($config["is_withdrawal_suspended"] ? "Yes" : "No") . "\n";
            }

            echo "[status] End of Website Status Response.\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `website_status_client.php`.
6. Run the code from the command line:

   php website_status_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a website status request
    $website_status_request = json_encode(["website_status" => 1]);
    $client->send($website_status_request);
    echo "[sent] Website status request sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "website_status") {
            $website_status = $data["website_status"];

            // Print important information from the website status
            echo "[status] Website Status:\n";
            echo "  - Site Status: " . ($website_status["site_status"] ?? "N/A") . "\n";
            echo "  - Supported Languages: " . implode(", ", $website_status["supported_languages"] ?? []) . "\n";

            // Extract and print currency information
            echo "  - Currencies Config:\n";
            foreach ($website_status["currencies_config"] ?? [] as $currency => $config) {
                echo "    * {$currency} ({$config['name']}):\n";
                echo "      - Type: " . ($config["type"] ?? "N/A") . "\n";
                echo "      - Fractional Digits: " . ($config["fractional_digits"] ?? "N/A") . "\n";
                echo "      - Deposit Suspended: " . ($config["is_deposit_suspended"] ? "Yes" : "No") . "\n";
                echo "      - Withdrawal Suspended: " . ($config["is_withdrawal_suspended"] ? "Yes" : "No") . "\n";
            }

            echo "[status] End of Website Status Response.\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `website_status_client.php`.
6. Run the code from the command line:

   php website_status_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a website status request
        website_status_request = {"website_status": 1}
        response = await api.send(website_status_request)
        print("Website status request sent")

        # Process the response and print important information
        print_website_status(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print website status details
def print_website_status(response):
    data = response.get("website_status", {})
    if data:
        print("[Website Status]")
        print(f"  - Site Status: {data.get('site_status', 'N/A')}")
        print("  - Supported Languages:", ", ".join(data.get("supported_languages", [])))

        # Display currency configurations
        currencies_config = data.get("currencies_config", {})
        print("  - Currencies Config:")
        for currency, config in currencies_config.items():
            print(f"    * {currency} ({config.get('name', 'N/A')}):")
            print(f"      - Type: {config.get('type', 'N/A')}")
            print(f"      - Fractional Digits: {config.get('fractional_digits', 'N/A')}")
            print(f"      - Deposit Suspended: {'Yes' if config.get('is_deposit_suspended') else 'No'}")
            print(f"      - Withdrawal Suspended: {'Yes' if config.get('is_withdrawal_suspended') else 'No'}")
        print("[End of Website Status Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `website_status_client.py`.
# 4. Run the code from the command line:
#      python website_status_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request the website status, and send pings every 30 seconds to keep the connection alive.
# The response includes important details about the website status and configuration for each currency.
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a website status request
        website_status_request = {"website_status": 1}
        response = await api.send(website_status_request)
        print("Website status request sent")

        # Process the response and print important information
        print_website_status(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print website status details
def print_website_status(response):
    data = response.get("website_status", {})
    if data:
        print("[Website Status]")
        print(f"  - Site Status: {data.get('site_status', 'N/A')}")
        print("  - Supported Languages:", ", ".join(data.get("supported_languages", [])))

        # Display currency configurations
        currencies_config = data.get("currencies_config", {})
        print("  - Currencies Config:")
        for currency, config in currencies_config.items():
            print(f"    * {currency} ({config.get('name', 'N/A')}):")
            print(f"      - Type: {config.get('type', 'N/A')}")
            print(f"      - Fractional Digits: {config.get('fractional_digits', 'N/A')}")
            print(f"      - Deposit Suspended: {'Yes' if config.get('is_deposit_suspended') else 'No'}")
            print(f"      - Withdrawal Suspended: {'Yes' if config.get('is_withdrawal_suspended') else 'No'}")
        print("[End of Website Status Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `website_status_client.py`.
# 4. Run the code from the command line:
#      python website_status_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request the website status, and send pings every 30 seconds to keep the connection alive.
# The response includes important details about the website status and configuration for each currency.
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Website status request JSON
    let website_status_request = json!({
        "website_status": 1
    });

    // Clone `socket` to send the website status request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(website_status_request.to_string())).await.is_ok() {
            println!("[status] Website status request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "website_status" {
                        println!("[Website Status] Site Status: {}", data["website_status"]["site_status"]);
                        let supported_languages: Vec<String> = data["website_status"]["supported_languages"]
                            .as_array()
                            .unwrap_or(&vec![])
                            .iter()
                            .filter_map(|lang| lang.as_str().map(|s| s.to_string()))
                            .collect();
                        println!("Supported Languages: {:?}", supported_languages);
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request the website status, print the website's status, supported languages, and handle any potential errors in the response.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Website status request JSON
    let website_status_request = json!({
        "website_status": 1
    });

    // Clone `socket` to send the website status request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(website_status_request.to_string())).await.is_ok() {
            println!("[status] Website status request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "website_status" {
                        println!("[Website Status] Site Status: {}", data["website_status"]["site_status"]);
                        let supported_languages: Vec<String> = data["website_status"]["supported_languages"]
                            .as_array()
                            .unwrap_or(&vec![])
                            .iter()
                            .filter_map(|lang| lang.as_str().map(|s| s.to_string()))
                            .collect();
                        println!("Supported Languages: {:?}", supported_languages);
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request the website status, print the website's status, supported languages, and handle any potential errors in the response.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run the code:

1. Ensure Swift is installed on your machine. You can use Xcode or install the Swift toolchain from https://swift.org/.
2. Create a new Swift file (e.g., `WebSocketClient.swift`) and paste the code above.
3. Open a terminal and navigate to the directory where the file is saved.
4. Run the code with the following command:

   swift WebSocketClient.swift

5. The program will connect to the Deriv WebSocket API, request the website status, and print the site's operational status and supported languages.
6. To stop the program, press `Ctrl+C` in the terminal.

Note: Replace `app_id` with your actual app_id if required.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run the code:

1. Ensure Swift is installed on your machine. You can use Xcode or install the Swift toolchain from https://swift.org/.
2. Create a new Swift file (e.g., `WebSocketClient.swift`) and paste the code above.
3. Open a terminal and navigate to the directory where the file is saved.
4. Run the code with the following command:

   swift WebSocketClient.swift

5. The program will connect to the Deriv WebSocket API, request the website status, and print the site's operational status and supported languages.
6. To stop the program, press `Ctrl+C` in the terminal.

Note: Replace `app_id` with your actual app_id if required.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send website status request
            await SendWebsiteStatusRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendWebsiteStatusRequest(ClientWebSocket webSocket)
    {
        var websiteStatusRequest = new { website_status = 1 };

        string requestJson = JsonSerializer.Serialize(websiteStatusRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[status] Website status request sent.");
    }

 private static async Task HandleResponses(ClientWebSocket webSocket)
 {
     var buffer = new byte[8192]; // Increased buffer size

     while (webSocket.State == WebSocketState.Open)
     {
         var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

         if (result.MessageType == WebSocketMessageType.Close)
         {
             Console.WriteLine("WebSocket connection closed by server.");
             await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
         }
         else
         {
             // Append received bytes to a string builder
             var response = Encoding.UTF8.GetString(buffer, 0, result.Count);
             var data = JsonDocument.Parse(response).RootElement;

             // Check for "error" in the response
             if (data.TryGetProperty("error", out var error))
             {
                 Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                 await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                 break;
             }

             // Process the "msg_type" property
             if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "website_status")
             {
                 var websiteStatus = data.GetProperty("website_status");
                 Console.WriteLine("Site Status: " + websiteStatus.GetProperty("site_status").GetString());
                 Console.WriteLine("Supported Languages: " + websiteStatus.GetProperty("supported_languages").ToString());
             }
         }
     }
 }
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send website status request
            await SendWebsiteStatusRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendWebsiteStatusRequest(ClientWebSocket webSocket)
    {
        var websiteStatusRequest = new { website_status = 1 };

        string requestJson = JsonSerializer.Serialize(websiteStatusRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[status] Website status request sent.");
    }

 private static async Task HandleResponses(ClientWebSocket webSocket)
 {
     var buffer = new byte[8192]; // Increased buffer size

     while (webSocket.State == WebSocketState.Open)
     {
         var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

         if (result.MessageType == WebSocketMessageType.Close)
         {
             Console.WriteLine("WebSocket connection closed by server.");
             await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
         }
         else
         {
             // Append received bytes to a string builder
             var response = Encoding.UTF8.GetString(buffer, 0, result.Count);
             var data = JsonDocument.Parse(response).RootElement;

             // Check for "error" in the response
             if (data.TryGetProperty("error", out var error))
             {
                 Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                 await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                 break;
             }

             // Process the "msg_type" property
             if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "website_status")
             {
                 var websiteStatus = data.GetProperty("website_status");
                 Console.WriteLine("Site Status: " + websiteStatus.GetProperty("site_status").GetString());
                 Console.WriteLine("Supported Languages: " + websiteStatus.GetProperty("supported_languages").ToString());
             }
         }
     }
 }
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a website status request
void send_website_status_request(struct lws *wsi) {
    const char *website_status_msg = "{\"website_status\": 1}";
    unsigned char buf[LWS_PRE + 128];
    memcpy(&buf[LWS_PRE], website_status_msg, strlen(website_status_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(website_status_msg), LWS_WRITE_TEXT);
    lwsl_user("Website status request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_website_status_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "website_status"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "website_status") == 0) {
        json_t *website_status = json_object_get(root, "website_status");
        if (website_status) {
            const char *site_status = json_string_value(json_object_get(website_status, "site_status"));
            printf("Website Status: %s\n", site_status);
        }
    } else if (msg_type && strcmp(msg_type, "ping") == 0) {
        printf("Ping response received.\n");
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_website_status_request(wsi);  // Send website status request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_website_status_request(wsi);  // Periodically request website status
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_website_status_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a website status request
void send_website_status_request(struct lws *wsi) {
    const char *website_status_msg = "{\"website_status\": 1}";
    unsigned char buf[LWS_PRE + 128];
    memcpy(&buf[LWS_PRE], website_status_msg, strlen(website_status_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(website_status_msg), LWS_WRITE_TEXT);
    lwsl_user("Website status request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_website_status_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "website_status"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "website_status") == 0) {
        json_t *website_status = json_object_get(root, "website_status");
        if (website_status) {
            const char *site_status = json_string_value(json_object_get(website_status, "site_status"));
            printf("Website Status: %s\n", site_status);
        }
    } else if (msg_type && strcmp(msg_type, "ping") == 0) {
        printf("Ping response received.\n");
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_website_status_request(wsi);  // Send website status request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_website_status_request(wsi);  // Periodically request website status
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_website_status_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

**Details:**
Follow these simple steps to look into general settings like call limits, currency information, supported languages and more using the Deriv API:

Import the API module: Load the DerivAPIBasic module to interact with the Deriv API.
Setup WebSocket: Establish a WebSocket connection using the app_id for authentication.
Initialize the API: Create an instance of DerivAPIBasic using the WebSocket connection.
Handle API response: Define websiteStatusResponse to process the response, handle errors, and log website status.
Request website status: Define getWebsiteStatus to send a request to the API for website status when called.
Button event listener: Attach an event listener to a button to trigger the website status request with a click.
JavaScript
Java
Perl
PHP
Python
Rust
Swift
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication,replace it with your app's ID.
const app_id = app_id;
...

---

### Get contracts for a symbol
**URL:** https://developers.deriv.com/docs/get-contracts-for-a-symbol

**Implementation Examples:**
```text
DerivAPIBasic
```

```text
app_id
```

```text
DerivAPIBasic
```

```text
R_50
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the contracts for symbol response
const handleContractsForSymbolResponse = async (response) => {
  const data = JSON.parse(response.data);

  // Check for errors in the response
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'contracts_for', log the contracts information
  if (data.msg_type === 'contracts_for') {
    const contractsInfo = data.contracts_for;
    console.log('Contracts for Symbol:', contractsInfo);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleContractsForSymbolResponse);
};

// Function to request contracts for a specific symbol
const getContractsForSymbol = async () => {
  const contracts_for_symbol_request = {
    contracts_for: 'R_50',   // Specify the symbol
    currency: 'USD',
    landing_company: 'svg',
    product_type: 'basic',
  };

  connection.addEventListener('message', handleContractsForSymbolResponse); // Add event listener
  await api.contractsFor(contracts_for_symbol_request); // Send the contracts request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const contracts_for_symbol_button = document.querySelector('#contractsForSymbol');
  if (contracts_for_symbol_button) {
    contracts_for_symbol_button.addEventListener('click', getContractsForSymbol);
  }
} else {
  // If running in Node.js, directly call the function
  getContractsForSymbol();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `contracts_for_symbol.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node contracts_for_symbol.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="contractsForSymbol">Get Contracts for Symbol</button>`
 * - Open the HTML file in a browser, and click the button to retrieve contracts for the symbol.
 */
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the contracts for symbol response
const handleContractsForSymbolResponse = async (response) => {
  const data = JSON.parse(response.data);

  // Check for errors in the response
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'contracts_for', log the contracts information
  if (data.msg_type === 'contracts_for') {
    const contractsInfo = data.contracts_for;
    console.log('Contracts for Symbol:', contractsInfo);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleContractsForSymbolResponse);
};

// Function to request contracts for a specific symbol
const getContractsForSymbol = async () => {
  const contracts_for_symbol_request = {
    contracts_for: 'R_50',   // Specify the symbol
    currency: 'USD',
    landing_company: 'svg',
    product_type: 'basic',
  };

  connection.addEventListener('message', handleContractsForSymbolResponse); // Add event listener
  await api.contractsFor(contracts_for_symbol_request); // Send the contracts request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const contracts_for_symbol_button = document.querySelector('#contractsForSymbol');
  if (contracts_for_symbol_button) {
    contracts_for_symbol_button.addEventListener('click', getContractsForSymbol);
  }
} else {
  // If running in Node.js, directly call the function
  getContractsForSymbol();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `contracts_for_symbol.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node contracts_for_symbol.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="contractsForSymbol">Get Contracts for Symbol</button>`
 * - Open the HTML file in a browser, and click the button to retrieve contracts for the symbol.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send contracts for symbol request
                    JsonObject contractsForSymbolRequest = new JsonObject();
                    contractsForSymbolRequest.addProperty("contracts_for", "R_50"); // Specify symbol here
                    contractsForSymbolRequest.addProperty("currency", "USD");
                    contractsForSymbolRequest.addProperty("landing_company", "svg");
                    contractsForSymbolRequest.addProperty("product_type", "basic");
                    send(contractsForSymbolRequest.toString());
                    System.out.println("[sent] Contracts for symbol request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("contracts_for".equals(data.get("msg_type").getAsString())) {
                        JsonObject contractsFor = data.getAsJsonObject("contracts_for");
                        System.out.println("Contracts for Symbol: " + contractsFor);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send contracts for symbol request
                    JsonObject contractsForSymbolRequest = new JsonObject();
                    contractsForSymbolRequest.addProperty("contracts_for", "R_50"); // Specify symbol here
                    contractsForSymbolRequest.addProperty("currency", "USD");
                    contractsForSymbolRequest.addProperty("landing_company", "svg");
                    contractsForSymbolRequest.addProperty("product_type", "basic");
                    send(contractsForSymbolRequest.toString());
                    System.out.println("[sent] Contracts for symbol request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("contracts_for".equals(data.get("msg_type").getAsString())) {
                        JsonObject contractsFor = data.getAsJsonObject("contracts_for");
                        System.out.println("Contracts for Symbol: " + contractsFor);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.
 */
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a contracts for symbol request
sub send_contracts_for_symbol {
    my $connection = shift;
    my $contracts_for_request = encode_json({
        contracts_for => 'R_50',    # Symbol for which contracts are requested
        currency => 'USD',          # Set currency to USD
        landing_company => 'svg',   # Landing company (e.g., svg)
        product_type => 'basic'     # Product type is set to 'basic'
    });
    $connection->send($contracts_for_request);
    say "[request] Contracts for symbol request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send the contracts for symbol request
    send_contracts_for_symbol($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Process contracts_for response
        if ($data->{msg_type} && $data->{msg_type} eq 'contracts_for') {
            say "[contracts] Contracts for Symbol (R_50):";
            foreach my $contract (@{$data->{contracts_for}{available}}) {
                my $contract_type            = $contract->{contract_type} // "N/A";
                my $contract_display         = $contract->{contract_display} // "N/A";
                my $contract_category_display = $contract->{contract_category_display} // "N/A";
                my $market                   = $contract->{market} // "N/A";
                my $submarket                = $contract->{submarket} // "N/A";
                my $expiry_type              = $contract->{expiry_type} // "N/A";
                my $min_duration             = $contract->{min_contract_duration} // "N/A";
                my $max_duration             = $contract->{max_contract_duration} // "N/A";
                my $barrier                  = $contract->{barrier} // "N/A";
                my $sentiment                = $contract->{sentiment} // "N/A";

                # Print contract details
                say "  - Contract Type: $contract_type";
                say "    - Display Name: $contract_display";
                say "    - Category: $contract_category_display";
                say "    - Market: $market";
                say "    - Submarket: $submarket";
                say "    - Expiry Type: $expiry_type";
                say "    - Min Duration: $min_duration";
                say "    - Max Duration: $max_duration";
                say "    - Barrier: $barrier";
                say "    - Sentiment: $sentiment";
                say "    --------------------";
            }
            say "[contracts] End of Contracts Response.";
            $connection->close;  # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `contracts_for_symbol.pl`.
# 4. Run the script using the command:
#      perl contracts_for_symbol.pl
# This script will connect to the Deriv WebSocket API, request contracts for a specific symbol, and print the details.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a contracts for symbol request
sub send_contracts_for_symbol {
    my $connection = shift;
    my $contracts_for_request = encode_json({
        contracts_for => 'R_50',    # Symbol for which contracts are requested
        currency => 'USD',          # Set currency to USD
        landing_company => 'svg',   # Landing company (e.g., svg)
        product_type => 'basic'     # Product type is set to 'basic'
    });
    $connection->send($contracts_for_request);
    say "[request] Contracts for symbol request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send the contracts for symbol request
    send_contracts_for_symbol($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Process contracts_for response
        if ($data->{msg_type} && $data->{msg_type} eq 'contracts_for') {
            say "[contracts] Contracts for Symbol (R_50):";
            foreach my $contract (@{$data->{contracts_for}{available}}) {
                my $contract_type            = $contract->{contract_type} // "N/A";
                my $contract_display         = $contract->{contract_display} // "N/A";
                my $contract_category_display = $contract->{contract_category_display} // "N/A";
                my $market                   = $contract->{market} // "N/A";
                my $submarket                = $contract->{submarket} // "N/A";
                my $expiry_type              = $contract->{expiry_type} // "N/A";
                my $min_duration             = $contract->{min_contract_duration} // "N/A";
                my $max_duration             = $contract->{max_contract_duration} // "N/A";
                my $barrier                  = $contract->{barrier} // "N/A";
                my $sentiment                = $contract->{sentiment} // "N/A";

                # Print contract details
                say "  - Contract Type: $contract_type";
                say "    - Display Name: $contract_display";
                say "    - Category: $contract_category_display";
                say "    - Market: $market";
                say "    - Submarket: $submarket";
                say "    - Expiry Type: $expiry_type";
                say "    - Min Duration: $min_duration";
                say "    - Max Duration: $max_duration";
                say "    - Barrier: $barrier";
                say "    - Sentiment: $sentiment";
                say "    --------------------";
            }
            say "[contracts] End of Contracts Response.";
            $connection->close;  # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `contracts_for_symbol.pl`.
# 4. Run the script using the command:
#      perl contracts_for_symbol.pl
# This script will connect to the Deriv WebSocket API, request contracts for a specific symbol, and print the details.
```

```text
<?php
// Include necessary libraries (you may need to install Ratchet via Composer)
require 'vendor/autoload.php';

use Ratchet\Client\WebSocket;
use Ratchet\Client\Connector;
use React\EventLoop\Factory as LoopFactory;
use React\Socket\Connector as ReactConnector;

// Define the app_id (replace 'your_app_id' with your actual app_id)
$app_id = 'your_app_id';

// Create an event loop to handle WebSocket events
$loop = LoopFactory::create();
$reactConnector = new ReactConnector($loop);
$connector = new Connector($loop, $reactConnector);

// Define the request object for contracts_for API call
$contracts_for_symbol_request = [
    'contracts_for'   => 'R_50',  // Symbol for which contracts are requested
    'currency'        => 'USD',   // Set currency to USD
    'landing_company' => 'svg',   // Landing company
    'product_type'    => 'basic', // Product type is set to 'basic'
];

// Connect to the Deriv WebSocket API
$connector("wss://ws.derivws.com/websockets/v3?app_id=$app_id")
    ->then(function(WebSocket $conn) use ($contracts_for_symbol_request, $loop) {
        // Send the contracts_for request to the WebSocket server
        $conn->send(json_encode($contracts_for_symbol_request));
        echo "Request sent: " . json_encode($contracts_for_symbol_request) . PHP_EOL;

        // Handle messages received from the server
        $conn->on('message', function($message) use ($conn, $loop) {
            // Decode the received message (JSON format)
            $data = json_decode($message, true);

            // Check if there is an error in the response
            if (isset($data['error'])) {
                echo "Error: " . $data['error']['message'] . PHP_EOL;
                $conn->close();
                $loop->stop(); // Stop the event loop
            }

            // If the response is for 'contracts_for', print the contract information
            if (isset($data['msg_type']) && $data['msg_type'] === 'contracts_for') {
                echo "Contracts for symbol: " . json_encode($data['contracts_for'], JSON_PRETTY_PRINT) . PHP_EOL;
                $conn->close(); // Close the WebSocket connection
                $loop->stop();  // Stop the event loop
            }
        });

        // Handle WebSocket connection closing
        $conn->on('close', function($code = null, $reason = null) use ($loop) {
            echo "Connection closed ({$code} - {$reason})" . PHP_EOL;
            $loop->stop(); // Stop the event loop when the connection is closed
        });
    }, function($e) use ($loop) {
        // Handle connection errors
        echo "Could not connect: {$e->getMessage()}" . PHP_EOL;
        $loop->stop();
    });

// Run the event loop to keep the connection alive
$loop->run();
```

```text
<?php
// Include necessary libraries (you may need to install Ratchet via Composer)
require 'vendor/autoload.php';

use Ratchet\Client\WebSocket;
use Ratchet\Client\Connector;
use React\EventLoop\Factory as LoopFactory;
use React\Socket\Connector as ReactConnector;

// Define the app_id (replace 'your_app_id' with your actual app_id)
$app_id = 'your_app_id';

// Create an event loop to handle WebSocket events
$loop = LoopFactory::create();
$reactConnector = new ReactConnector($loop);
$connector = new Connector($loop, $reactConnector);

// Define the request object for contracts_for API call
$contracts_for_symbol_request = [
    'contracts_for'   => 'R_50',  // Symbol for which contracts are requested
    'currency'        => 'USD',   // Set currency to USD
    'landing_company' => 'svg',   // Landing company
    'product_type'    => 'basic', // Product type is set to 'basic'
];

// Connect to the Deriv WebSocket API
$connector("wss://ws.derivws.com/websockets/v3?app_id=$app_id")
    ->then(function(WebSocket $conn) use ($contracts_for_symbol_request, $loop) {
        // Send the contracts_for request to the WebSocket server
        $conn->send(json_encode($contracts_for_symbol_request));
        echo "Request sent: " . json_encode($contracts_for_symbol_request) . PHP_EOL;

        // Handle messages received from the server
        $conn->on('message', function($message) use ($conn, $loop) {
            // Decode the received message (JSON format)
            $data = json_decode($message, true);

            // Check if there is an error in the response
            if (isset($data['error'])) {
                echo "Error: " . $data['error']['message'] . PHP_EOL;
                $conn->close();
                $loop->stop(); // Stop the event loop
            }

            // If the response is for 'contracts_for', print the contract information
            if (isset($data['msg_type']) && $data['msg_type'] === 'contracts_for') {
                echo "Contracts for symbol: " . json_encode($data['contracts_for'], JSON_PRETTY_PRINT) . PHP_EOL;
                $conn->close(); // Close the WebSocket connection
                $loop->stop();  // Stop the event loop
            }
        });

        // Handle WebSocket connection closing
        $conn->on('close', function($code = null, $reason = null) use ($loop) {
            echo "Connection closed ({$code} - {$reason})" . PHP_EOL;
            $loop->stop(); // Stop the event loop when the connection is closed
        });
    }, function($e) use ($loop) {
        // Handle connection errors
        echo "Could not connect: {$e->getMessage()}" . PHP_EOL;
        $loop->stop();
    });

// Run the event loop to keep the connection alive
$loop->run();
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a contracts for symbol request
        contracts_for_symbol_request = {
            "contracts_for": "R_50",
            "currency": "USD",
            "landing_company": "svg",
            "product_type": "basic"
        }
        response = await api.send(contracts_for_symbol_request)
        print("Contracts for symbol request sent")

        # Process the response and print contract details
        print_contracts_for_symbol(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print contract details for a symbol
def print_contracts_for_symbol(response):
    data = response.get("contracts_for", {})
    if data:
        print("Contracts for Symbol (R_50):")
        contracts = data.get("available", [])
        for contract in contracts:
            print(f"  - Contract Type: {contract.get('contract_type')}")
            print(f"    - Display Name: {contract.get('contract_display')}")
            print(f"    - Category: {contract.get('contract_category_display')}")
            print(f"    - Market: {contract.get('market')}")
            print(f"    - Submarket: {contract.get('submarket')}")
            print(f"    - Expiry Type: {contract.get('expiry_type')}")
            print(f"    - Min Duration: {contract.get('min_contract_duration')}")
            print(f"    - Max Duration: {contract.get('max_contract_duration')}")
            print(f"    - Barrier: {contract.get('barrier')}")
            print(f"    - Sentiment: {contract.get('sentiment')}")
            print("    --------------------")
    print("[End of Contracts for Symbol Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `contracts_for_symbol_client.py`.
# 4. Run the code from the command line:
#      python contracts_for_symbol_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request contract details for the symbol "R_50", and send pings every 30 seconds to keep the connection alive.
# The response includes important contract details such as contract type, category, market, durations, and barriers.
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a contracts for symbol request
        contracts_for_symbol_request = {
            "contracts_for": "R_50",
            "currency": "USD",
            "landing_company": "svg",
            "product_type": "basic"
        }
        response = await api.send(contracts_for_symbol_request)
        print("Contracts for symbol request sent")

        # Process the response and print contract details
        print_contracts_for_symbol(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print contract details for a symbol
def print_contracts_for_symbol(response):
    data = response.get("contracts_for", {})
    if data:
        print("Contracts for Symbol (R_50):")
        contracts = data.get("available", [])
        for contract in contracts:
            print(f"  - Contract Type: {contract.get('contract_type')}")
            print(f"    - Display Name: {contract.get('contract_display')}")
            print(f"    - Category: {contract.get('contract_category_display')}")
            print(f"    - Market: {contract.get('market')}")
            print(f"    - Submarket: {contract.get('submarket')}")
            print(f"    - Expiry Type: {contract.get('expiry_type')}")
            print(f"    - Min Duration: {contract.get('min_contract_duration')}")
            print(f"    - Max Duration: {contract.get('max_contract_duration')}")
            print(f"    - Barrier: {contract.get('barrier')}")
            print(f"    - Sentiment: {contract.get('sentiment')}")
            print("    --------------------")
    print("[End of Contracts for Symbol Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `contracts_for_symbol_client.py`.
# 4. Run the code from the command line:
#      python contracts_for_symbol_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request contract details for the symbol "R_50", and send pings every 30 seconds to keep the connection alive.
# The response includes important contract details such as contract type, category, market, durations, and barriers.
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Contracts for symbol request JSON
    let contracts_for_symbol_request = json!({
        "contracts_for": "R_50",
        "currency": "USD",
        "landing_company": "svg",
        "product_type": "basic"
    });

    // Clone `socket` to send the contracts for symbol request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(contracts_for_symbol_request.to_string())).await.is_ok() {
            println!("[request] Contracts for symbol request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "contracts_for" {
                        println!("Contracts for Symbol (R_50):");
                        if let Some(contracts) = data["contracts_for"]["available"].as_array() {
                            for contract in contracts {
                                println!("  - Contract Type: {}", contract["contract_type"]);
                                println!("    - Display Name: {}", contract["contract_display"]);
                                println!("    - Category: {}", contract["contract_category_display"]);
                                println!("    - Market: {}", contract["market"]);
                                println!("    - Submarket: {}", contract["submarket"]);
                                println!("    - Expiry Type: {}", contract["expiry_type"]);
                                println!("    - Min Duration: {}", contract["min_contract_duration"]);
                                println!("    - Max Duration: {}", contract["max_contract_duration"]);
                                println!("    - Barrier: {}", contract["barrier"]);
                                println!("    - Sentiment: {}", contract["sentiment"]);
                                println!("    --------------------");
                            }
                        }
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request contract details for the symbol "R_50", and print out important contract details such as type, category, market, submarket, expiry type, duration, and barrier information.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Contracts for symbol request JSON
    let contracts_for_symbol_request = json!({
        "contracts_for": "R_50",
        "currency": "USD",
        "landing_company": "svg",
        "product_type": "basic"
    });

    // Clone `socket` to send the contracts for symbol request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(contracts_for_symbol_request.to_string())).await.is_ok() {
            println!("[request] Contracts for symbol request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "contracts_for" {
                        println!("Contracts for Symbol (R_50):");
                        if let Some(contracts) = data["contracts_for"]["available"].as_array() {
                            for contract in contracts {
                                println!("  - Contract Type: {}", contract["contract_type"]);
                                println!("    - Display Name: {}", contract["contract_display"]);
                                println!("    - Category: {}", contract["contract_category_display"]);
                                println!("    - Market: {}", contract["market"]);
                                println!("    - Submarket: {}", contract["submarket"]);
                                println!("    - Expiry Type: {}", contract["expiry_type"]);
                                println!("    - Min Duration: {}", contract["min_contract_duration"]);
                                println!("    - Max Duration: {}", contract["max_contract_duration"]);
                                println!("    - Barrier: {}", contract["barrier"]);
                                println!("    - Sentiment: {}", contract["sentiment"]);
                                println!("    --------------------");
                            }
                        }
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request contract details for the symbol "R_50", and print out important contract details such as type, category, market, submarket, expiry type, duration, and barrier information.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a contracts for symbol request
void send_contracts_for_symbol_request(struct lws *wsi) {
    const char *contracts_for_symbol_msg = "{\"contracts_for\": \"R_50\", \"currency\": \"USD\", \"landing_company\": \"svg\", \"product_type\": \"basic\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], contracts_for_symbol_msg, strlen(contracts_for_symbol_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(contracts_for_symbol_msg), LWS_WRITE_TEXT);
    lwsl_user("Contracts for symbol request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_contracts_for_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "contracts_for"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "contracts_for") == 0) {
        json_t *contracts_for = json_object_get(root, "contracts_for");
        json_t *available_contracts = json_object_get(contracts_for, "available");

        printf("Contracts for Symbol (R_50):\n");
        size_t index;
        json_t *contract;
        json_array_foreach(available_contracts, index, contract) {
            const char *contract_type = json_string_value(json_object_get(contract, "contract_type"));
            const char *display_name = json_string_value(json_object_get(contract, "contract_display"));
            const char *category = json_string_value(json_object_get(contract, "contract_category_display"));
            const char *market = json_string_value(json_object_get(contract, "market"));
            const char *submarket = json_string_value(json_object_get(contract, "submarket"));
            const char *expiry_type = json_string_value(json_object_get(contract, "expiry_type"));
            const char *min_duration = json_string_value(json_object_get(contract, "min_contract_duration"));
            const char *max_duration = json_string_value(json_object_get(contract, "max_contract_duration"));

            printf("  - Contract Type: %s\n", contract_type);
            printf("    - Display Name: %s\n", display_name);
            printf("    - Category: %s\n", category);
            printf("    - Market: %s\n", market);
            printf("    - Submarket: %s\n", submarket);
            printf("    - Expiry Type: %s\n", expiry_type);
            printf("    - Min Duration: %s\n", min_duration);
            printf("    - Max Duration: %s\n", max_duration);
            printf("    --------------------\n");
        }
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_contracts_for_symbol_request(wsi);  // Send contracts for symbol request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_contracts_for_symbol_request(wsi);  // Periodically request contracts
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_contracts_for_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a contracts for symbol request
void send_contracts_for_symbol_request(struct lws *wsi) {
    const char *contracts_for_symbol_msg = "{\"contracts_for\": \"R_50\", \"currency\": \"USD\", \"landing_company\": \"svg\", \"product_type\": \"basic\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], contracts_for_symbol_msg, strlen(contracts_for_symbol_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(contracts_for_symbol_msg), LWS_WRITE_TEXT);
    lwsl_user("Contracts for symbol request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_contracts_for_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "contracts_for"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "contracts_for") == 0) {
        json_t *contracts_for = json_object_get(root, "contracts_for");
        json_t *available_contracts = json_object_get(contracts_for, "available");

        printf("Contracts for Symbol (R_50):\n");
        size_t index;
        json_t *contract;
        json_array_foreach(available_contracts, index, contract) {
            const char *contract_type = json_string_value(json_object_get(contract, "contract_type"));
            const char *display_name = json_string_value(json_object_get(contract, "contract_display"));
            const char *category = json_string_value(json_object_get(contract, "contract_category_display"));
            const char *market = json_string_value(json_object_get(contract, "market"));
            const char *submarket = json_string_value(json_object_get(contract, "submarket"));
            const char *expiry_type = json_string_value(json_object_get(contract, "expiry_type"));
            const char *min_duration = json_string_value(json_object_get(contract, "min_contract_duration"));
            const char *max_duration = json_string_value(json_object_get(contract, "max_contract_duration"));

            printf("  - Contract Type: %s\n", contract_type);
            printf("    - Display Name: %s\n", display_name);
            printf("    - Category: %s\n", category);
            printf("    - Market: %s\n", market);
            printf("    - Submarket: %s\n", submarket);
            printf("    - Expiry Type: %s\n", expiry_type);
            printf("    - Min Duration: %s\n", min_duration);
            printf("    - Max Duration: %s\n", max_duration);
            printf("    --------------------\n");
        }
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_contracts_for_symbol_request(wsi);  // Send contracts for symbol request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_contracts_for_symbol_request(wsi);  // Periodically request contracts
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_contracts_for_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send contracts for symbol request
            await SendContractsForSymbolRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendContractsForSymbolRequest(ClientWebSocket webSocket)
    {
        var contractsForSymbolRequest = new
        {
            contracts_for = "R_50",
            currency = "USD",
            landing_company = "svg",
            product_type = "basic"
        };

        string requestJson = JsonSerializer.Serialize(contractsForSymbolRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[request] Contracts for symbol request sent.");
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[8192];
    var messageBuilder = new StringBuilder();

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            break;
        }

        messageBuilder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));

        if (result.EndOfMessage)
        {
            try
            {
                var data = JsonDocument.Parse(messageBuilder.ToString()).RootElement;
                if (data.TryGetProperty("error", out var error))
                {
                    Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                    break;
                }

                if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "contracts_for")
                {
                    Console.WriteLine("Contracts for Symbol (R_50):");
                    foreach (var contract in data.GetProperty("contracts_for").GetProperty("available").EnumerateArray())
                    {
                        Console.WriteLine($"  - Contract Type: {contract.GetProperty("contract_type").GetString()}");
                        Console.WriteLine($"    - Display Name: {contract.GetProperty("contract_display").GetString()}");
                        Console.WriteLine($"    - Category: {contract.GetProperty("contract_category_display").GetString()}");
                        Console.WriteLine($"    - Market: {contract.GetProperty("market").GetString()}");
                        Console.WriteLine($"    - Submarket: {contract.GetProperty("submarket").GetString()}");
                        Console.WriteLine($"    - Expiry Type: {contract.GetProperty("expiry_type").GetString()}");

                        // Check for optional properties with safe access
                        Console.WriteLine($"    - Min Duration: {(contract.TryGetProperty("min_contract_duration", out var minDuration) ? minDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Max Duration: {(contract.TryGetProperty("max_contract_duration", out var maxDuration) ? maxDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Barrier: {(contract.TryGetProperty("barrier", out var barrier) ? barrier.GetString() : "N/A")}");
                        Console.WriteLine($"    - Sentiment: {(contract.TryGetProperty("sentiment", out var sentiment) ? sentiment.GetString() : "N/A")}");
                        Console.WriteLine("    --------------------");
                    }
                }

                messageBuilder.Clear();
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"[Error] Failed to parse JSON message: {ex.Message}");
            }
        }
    }
}


}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send contracts for symbol request
            await SendContractsForSymbolRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendContractsForSymbolRequest(ClientWebSocket webSocket)
    {
        var contractsForSymbolRequest = new
        {
            contracts_for = "R_50",
            currency = "USD",
            landing_company = "svg",
            product_type = "basic"
        };

        string requestJson = JsonSerializer.Serialize(contractsForSymbolRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[request] Contracts for symbol request sent.");
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[8192];
    var messageBuilder = new StringBuilder();

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            break;
        }

        messageBuilder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));

        if (result.EndOfMessage)
        {
            try
            {
                var data = JsonDocument.Parse(messageBuilder.ToString()).RootElement;
                if (data.TryGetProperty("error", out var error))
                {
                    Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                    break;
                }

                if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "contracts_for")
                {
                    Console.WriteLine("Contracts for Symbol (R_50):");
                    foreach (var contract in data.GetProperty("contracts_for").GetProperty("available").EnumerateArray())
                    {
                        Console.WriteLine($"  - Contract Type: {contract.GetProperty("contract_type").GetString()}");
                        Console.WriteLine($"    - Display Name: {contract.GetProperty("contract_display").GetString()}");
                        Console.WriteLine($"    - Category: {contract.GetProperty("contract_category_display").GetString()}");
                        Console.WriteLine($"    - Market: {contract.GetProperty("market").GetString()}");
                        Console.WriteLine($"    - Submarket: {contract.GetProperty("submarket").GetString()}");
                        Console.WriteLine($"    - Expiry Type: {contract.GetProperty("expiry_type").GetString()}");

                        // Check for optional properties with safe access
                        Console.WriteLine($"    - Min Duration: {(contract.TryGetProperty("min_contract_duration", out var minDuration) ? minDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Max Duration: {(contract.TryGetProperty("max_contract_duration", out var maxDuration) ? maxDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Barrier: {(contract.TryGetProperty("barrier", out var barrier) ? barrier.GetString() : "N/A")}");
                        Console.WriteLine($"    - Sentiment: {(contract.TryGetProperty("sentiment", out var sentiment) ? sentiment.GetString() : "N/A")}");
                        Console.WriteLine("    --------------------");
                    }
                }

                messageBuilder.Clear();
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"[Error] Failed to parse JSON message: {ex.Message}");
            }
        }
    }
}


}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//replace with your app_id
	readLimit    = 65536 // Set a higher read limit, e.g., 64 KB
)

type ContractsForRequest struct {
	ContractsFor   string `json:"contracts_for"`
	Currency       string `json:"currency"`
	LandingCompany string `json:"landing_company"`
	ProductType    string `json:"product_type"`
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("[status] WebSocket connection established.")

	// Set a higher read limit
	conn.SetReadLimit(readLimit)

	// Send contracts for symbol request
	err = sendContractsForSymbolRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send contracts for symbol request: %v", err)
	}

	// Handle incoming messages
	handleResponses(ctx, conn)
}

func sendContractsForSymbolRequest(ctx context.Context, conn *websocket.Conn) error {
	contractsRequest := ContractsForRequest{
		ContractsFor:   "R_50",
		Currency:       "USD",
		LandingCompany: "svg",
		ProductType:    "basic",
	}
	fmt.Println("[request] Sending contracts for symbol request...")
	return wsjson.Write(ctx, conn, contractsRequest)
}

func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}

		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		msgType := response["msg_type"]
		if msgType == "contracts_for" {
			contracts := response["contracts_for"].(map[string]interface{})["available"].([]interface{})
			fmt.Println("Contracts for Symbol (R_50):")
			for _, contract := range contracts {
				contractMap := contract.(map[string]interface{})
				fmt.Printf("  - Contract Type: %v\n", contractMap["contract_type"])
				fmt.Printf("    - Display Name: %v\n", contractMap["contract_display"])
				fmt.Printf("    - Category: %v\n", contractMap["contract_category_display"])
				fmt.Printf("    - Market: %v\n", contractMap["market"])
				fmt.Printf("    - Submarket: %v\n", contractMap["submarket"])
				fmt.Printf("    - Expiry Type: %v\n", contractMap["expiry_type"])
				fmt.Printf("    - Min Duration: %v\n", contractMap["min_contract_duration"])
				fmt.Printf("    - Max Duration: %v\n", contractMap["max_contract_duration"])
				fmt.Printf("    - Barrier: %v\n", contractMap["barrier"])
				fmt.Printf("    - Sentiment: %v\n", contractMap["sentiment"])
				fmt.Println("    --------------------")
			}
		} else {
			fmt.Printf("Received message: %v\n", response)
		}
	}
}
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//replace with your app_id
	readLimit    = 65536 // Set a higher read limit, e.g., 64 KB
)

type ContractsForRequest struct {
	ContractsFor   string `json:"contracts_for"`
	Currency       string `json:"currency"`
	LandingCompany string `json:"landing_company"`
	ProductType    string `json:"product_type"`
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("[status] WebSocket connection established.")

	// Set a higher read limit
	conn.SetReadLimit(readLimit)

	// Send contracts for symbol request
	err = sendContractsForSymbolRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send contracts for symbol request: %v", err)
	}

	// Handle incoming messages
	handleResponses(ctx, conn)
}

func sendContractsForSymbolRequest(ctx context.Context, conn *websocket.Conn) error {
	contractsRequest := ContractsForRequest{
		ContractsFor:   "R_50",
		Currency:       "USD",
		LandingCompany: "svg",
		ProductType:    "basic",
	}
	fmt.Println("[request] Sending contracts for symbol request...")
	return wsjson.Write(ctx, conn, contractsRequest)
}

func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}

		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		msgType := response["msg_type"]
		if msgType == "contracts_for" {
			contracts := response["contracts_for"].(map[string]interface{})["available"].([]interface{})
			fmt.Println("Contracts for Symbol (R_50):")
			for _, contract := range contracts {
				contractMap := contract.(map[string]interface{})
				fmt.Printf("  - Contract Type: %v\n", contractMap["contract_type"])
				fmt.Printf("    - Display Name: %v\n", contractMap["contract_display"])
				fmt.Printf("    - Category: %v\n", contractMap["contract_category_display"])
				fmt.Printf("    - Market: %v\n", contractMap["market"])
				fmt.Printf("    - Submarket: %v\n", contractMap["submarket"])
				fmt.Printf("    - Expiry Type: %v\n", contractMap["expiry_type"])
				fmt.Printf("    - Min Duration: %v\n", contractMap["min_contract_duration"])
				fmt.Printf("    - Max Duration: %v\n", contractMap["max_contract_duration"])
				fmt.Printf("    - Barrier: %v\n", contractMap["barrier"])
				fmt.Printf("    - Sentiment: %v\n", contractMap["sentiment"])
				fmt.Println("    --------------------")
			}
		} else {
			fmt.Printf("Received message: %v\n", response)
		}
	}
}
```

**Details:**
Follow these steps to retrieve the list of available contracts, along with the latest barrier and duration limits for each contract, for a given symbol using the Deriv API:

Import Deriv API: Import the DerivAPIBasic library from Skypack CDN.
WebSocket connection: Create a WebSocket connection to the Deriv API using your app_id.
API initialization: Initialize the DerivAPIBasic instance with the WebSocket connection.
Request object: Define a request object to fetch contracts for a specific symbol (e.g., R_50).
Response handling: Handle the API response:
Parse the data and log any errors.
If the response contains contract data, log it.
Remove the event listener after the response is received.
Trigger request: On a button click, the function sends the request to the API to get the contracts for the symbol.
JavaScript
Java
Perl
PHP
Python
Rust
Swift
C
C#
Go
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app...

---

## üìà 3. TRADING OPERATIONS

### Account setup
**URL:** https://developers.deriv.com/docs/account-setup

**Trading Examples:**
```text
buy
```

```text
proposal
```

```text
buy
```

```text
proposal
```

```text
https://example.com
```

```text
/verify
```

```text
https://example.com/verify
```

**Available Operations:**
- Create a Deriv account
- üìòNote:
- How to add or select your real trading (CR) account
- Step 1
- Open the account switcher
- Step 2
- Manage your accounts
- Step 3
- Choose your currency
- Register your Deriv application
- First-time app registration
- To create additional apps
- Register a new application
- üìòNote
- To update an existing app
- Create an API token
- ‚ùóÔ∏èImportant
- ‚ùóÔ∏èNot recommended
- ‚ö†Ô∏èImportant

**Implementation Details:**
Create a Deriv account
Visit api.deriv.com
Click Sign Up on the top right corner of the page.
Provide your Email Address.
Check your inbox for a verification email and click the link to confirm your account.
After verifying your email, provide your Country of residence, Citizenship, and create a Password.
Your Demo account is now active ‚Äî you can start building and testing your apps right away.
To create a Real account, click Complete my profile.
Choose your Account Currency, fill in your Personal and Address details, and accept the Terms of use to proceed.
Your Real account is now active ‚Äî you‚Äôre eligible to earn markup commissions on your app.
üìò

Note:

If your country of residence is one of the supported countries for Wallets, you will also receive a virtual Wallet (demo) account. Once you complete the real account creation process, a real Wallet account will also be created, based on the currency you select.

Attention Developers ‚Äì Wallet Accounts Can‚Äôt Trade!
If your account type is CRW (Wallet) or VRW (Virtual Wallet), you cannot perform trading transactions via API.
To continue using the API for trading operations (like buy, proposal, etc.), please follow these steps:
1Ô∏è‚É£ C...

---

### Authentication
**URL:** https://developers.deriv.com/docs/authentication

**Trading Examples:**
```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID
```

```text
YOUR_APP_ID
```

```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID&affiliate_token=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
FB58247C-6B33-4677-A6AD-168C2D72323C
```

```text
dynamicworks
```

```text
jqd7qq_iBB18zg8lBvFoLmNd7ZgqdRLk
```

```text
myaffiliates
```

```text
t
```

```text
utm_campaign
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://[YOUR_WEBSITE_URL]/redirect/?acct1=cr799393&token1=a1-f7pnteezo4jzhpxclctizt27hyeot&cur1=usd& acct2=vrtc1859315&token2=a1clwe3vfuuus5kraceykdsoqm4snfq&cur2=usd&acct3=CRW1157&token3=a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC&cur3=usd&acct4=VRW1160&token4=a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV&cur3=usd
```

```text
https://[YOUR_WEBSITE_URL]/redirect/?acct1=cr799393&token1=a1-f7pnteezo4jzhpxclctizt27hyeot&cur1=usd& acct2=vrtc1859315&token2=a1clwe3vfuuus5kraceykdsoqm4snfq&cur2=usd&acct3=CRW1157&token3=a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC&cur3=usd&acct4=VRW1160&token4=a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV&cur3=usd
```

```text
const user_accounts = [
  {
    currency: 'usd',
    token: 'a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC',
    account: 'CRW1157'
  },
  {
    account: 'VRW1160',
    token: 'a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV',
    currency: 'usd',
  },
  {
    account: 'cr799393',
    token: 'a1-f7pnteezo4jzhpxclctizt27hyeot',
    currency: 'usd',
  },
  {
    account: 'vrtc1859315',
    token: 'a1clwe3vfuuus5kraceykdsoqm4snfq',
    currency: 'usd',
  },
];
```

```text
const user_accounts = [
  {
    currency: 'usd',
    token: 'a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC',
    account: 'CRW1157'
  },
  {
    account: 'VRW1160',
    token: 'a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV',
    currency: 'usd',
  },
  {
    account: 'cr799393',
    token: 'a1-f7pnteezo4jzhpxclctizt27hyeot',
    currency: 'usd',
  },
  {
    account: 'vrtc1859315',
    token: 'a1clwe3vfuuus5kraceykdsoqm4snfq',
    currency: 'usd',
  },
];
```

```text
{
  "authorize": "a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC"
}
```

```text
{
  "authorize": "a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC"
}
```

```text
{
  "account_list": [
    {
      "account_category": "wallet",
      "account_type": "doughflow",
      "broker": "CRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "linked_to": [],
      "loginid": "CRW1157"
    },
    {
      "account_category": "wallet",
      "account_type": "virtual",
      "broker": "VRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 1,
      "landing_company_name": "virtual",
      "linked_to": [],
      "loginid": "VRW1160"
    },
    {
      "account_type": "trading",
      "created_at": 1647509550,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "CR799393",
      "trading": {}
    },
    {
      "account_type": "trading",
      "created_at": 1664132232,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "VRTC1859315",
      "trading": {}
    },
  ],
  "balance": 0,
  "country": "aq",
  "currency": "USD",
  "email": "ss@deriv.com",
  "fullname": "Ms QA script ssRPPta",
  "is_virtual": 0,
  "landing_company_fullname": "Deriv (SVG) LLC",
  "landing_company_name": "svg",
  "linked_to": [],
  "local_currencies": {
    "AAD": {
      "fractional_digits": 2
    }
  },
  "loginid": "CRW1157",
  "preferred_language": "EN",
  "scopes": [
    "admin",
    "payments",
    "read",
    "trade",
    "trading_information"
  ],
  "upgradeable_landing_companies": [],
  "user_id": 464
}
```

```text
{
  "account_list": [
    {
      "account_category": "wallet",
      "account_type": "doughflow",
      "broker": "CRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "linked_to": [],
      "loginid": "CRW1157"
    },
    {
      "account_category": "wallet",
      "account_type": "virtual",
      "broker": "VRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 1,
      "landing_company_name": "virtual",
      "linked_to": [],
      "loginid": "VRW1160"
    },
    {
      "account_type": "trading",
      "created_at": 1647509550,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "CR799393",
      "trading": {}
    },
    {
      "account_type": "trading",
      "created_at": 1664132232,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "VRTC1859315",
      "trading": {}
    },
  ],
  "balance": 0,
  "country": "aq",
  "currency": "USD",
  "email": "ss@deriv.com",
  "fullname": "Ms QA script ssRPPta",
  "is_virtual": 0,
  "landing_company_fullname": "Deriv (SVG) LLC",
  "landing_company_name": "svg",
  "linked_to": [],
  "local_currencies": {
    "AAD": {
      "fractional_digits": 2
    }
  },
  "loginid": "CRW1157",
  "preferred_language": "EN",
  "scopes": [
    "admin",
    "payments",
    "read",
    "trade",
    "trading_information"
  ],
  "upgradeable_landing_companies": [],
  "user_id": 464
}
```

**Available Operations:**
- Authentication process
- üìòImportant note:
- Authorisation process

**Implementation Details:**
To unlock the complete functionality of Deriv APIs, you must first authenticate and then authorize your users.

For Deriv APIs, your users must be authenticated and authorized by our OAuth provider and WebSocket Server.

The OAuth provider handles user logins and grants secure access tokens. The WebSocket server then uses these tokens to verify users and facilitate seamless communication with the Deriv API. Together, these components ensure the security and efficiency of your app.

Authentication process

OAuth, short for Open Authorization, is a protocol that enables a client to access server-hosted resources on behalf of the user without exposing their credentials. For more information, refer to OAuth.

This method enables Deriv account holders to log into third-party apps without generating an API token. Consequently, the third-party app does not access the user‚Äôs password or permanent API token, enhancing security.

To authenticate your user:

Make sure the URL is specified correctly in the OAuth Details. To verify this, navigate to the Application manager under the Applications tab in the Dashboard and click the copy icon  to copy the OAuth redirect URL. To change or update th...

---

### MT5 APIs
**URL:** https://developers.deriv.com/docs/mt5

**Available Operations:**
- ‚ùóÔ∏èDeriv MT5 APIs do not support copy trading or subscription features.
- ‚ùóÔ∏èAdditionally, trading on MT5 is not supported via our APIs. For trading purposes,  use the Deriv MT5 application only.

**Implementation Details:**
MT5 APIs facilitate the management and interaction with MetaTrader 5 trading accounts.

They provide functionalities for account creation, password management, retrieving account details, and managing financial transactions like deposits and withdrawals. These APIs are crucial for maintaining and operating MT5 accounts on our trading platforms.

Here are the MT5 APIs we support:

#	API Name	Description	Send	Subscribe	Scope
1	MT5: Deposit	Allows deposits from a Deriv account into an MT5 account.	‚úî	‚úò	Payments
2	MT5: Get Setting	Retrieves MT5 user account settings.	‚úî	‚úò	Read
3	MT5: Accounts List	Retrieves a list of all the MT5 accounts associated with the client.	‚úî	‚úò	Read
4	MT5: New Account	Creates a new MT5 user account, either a demo or real account.	‚úî	‚úò	Admin
5	MT5: Password Change	Changes the password of the MT5 account.	‚úî	‚úò	Admin
6	MT5: Password Check	Validates the main password for the MT5 user.	‚úî	‚úò	Admin
7	MT5: Password Reset	Resets the password for the MT5 account.	‚úî	‚úò	Admin
8	MT5: Withdrawal	Allows withdrawals from an MT5 account to a Deriv account.	‚úî	‚úò	Payments
‚ùóÔ∏è

Deriv MT5 APIs do not support copy trading or subscription features.

To use copy trading, you need to subscribe...

---

### Account APIs
**URL:** https://developers.deriv.com/docs/account-apis

**Trading Examples:**
```text
Maltainvest
```

```text
get_self_exclusion
```

```text
get_account_settings
```

**Implementation Details:**
Account APIs are designed to manage user accounts, settings, and security. They provide functionalities for authorising sessions, managing API tokens, retrieving and updating account information, handling KYC (Know Your Customer) processes, and setting trading and self-exclusion limits.

These APIs ensure secure, compliant, and personalised interactions on the Deriv platforms, empowering users to manage their accounts and trading activities effectively.

#	API Name	Description	Send	Subscribe	Scope
1	API Token	This call manages API tokens.	‚úî	‚úò	Admin
2	Authorize	Authorises the current WebSocket session using a token. This must precede requests that require access to the client account, such as purchasing or selling contracts.	‚úî	‚úò	NA
3	Balance	Retrieves the user account balance.	‚úî	‚úî	Read
4	Document Upload	Requests and uploads KYC documents from the client.	‚úî	‚úò	Admin
5	Account Status	Retrieves the current status of the user account.	‚úî	‚úò	Read
6	Login History	Retrieves a summary of the user‚Äôs login history.	‚úî	‚úò	Read
7	Log Out	Logs the user out of the current session.	‚úî	‚úò	NA
8	Account Limits	Retrieves the user's trading and withdrawal limits.	‚úî	‚úò	Read
9	Get Self-Exclusion	Allows users to ...

---

### Market Data APIs
**URL:** https://developers.deriv.com/docs/market-data-apis

**Implementation Details:**
Market Data APIs provide access to real-time market data and pricing information on Deriv.

They offer functionalities for retrieving active trading symbols, exchange rates, contract details, and price proposals. Additionally, these APIs enable real-time streaming of spot prices and access to historical tick data, helping users make informed trading decisions.

These APIs are crucial for accessing accurate and up-to-date market data, ensuring users can trade efficiently on the Deriv trading platforms.

#	API Name	Description	Send	Subscribe	Scope
1	Active Symbols	Retrieves a list of all currently active symbols (underlying markets available for trading).	‚úî	‚úò	NA
2	Asset Index	Retrieves a list of available underlyings along with their corresponding contract types and duration limits. For logged-in users, only assets available under their landing company will be returned.	‚úî	‚úò	NA
3	Exchange Rates	Retrieves the exchange rate between a base currency and a target currency supported by the system.	‚úî	‚úî	NA
4	Contracts For Symbol	Retrieves the list of available contracts for a given symbol, including the latest barrier and duration limits.	‚úî	‚úò	NA
5	Price Proposal	Retrieves the latest price for...

---

### Reports APIs
**URL:** https://developers.deriv.com/docs/reports-apis

**Implementation Details:**
Reports APIs are designed to monitor and report user account activity. They provide functionalities for retrieving reality check summaries, generating account statements, and subscribing to real-time transaction notifications.

These APIs are essential for ensuring regulatory compliance and giving clients up-to-date insights into their trading activities and account status.

#	API Name	Description	Send	Subscribe	Scope
1	Reality Check	Retrieves a summary of the client‚Äôs trades and account status for the Reality Check feature.

This includes the time elapsed since the session began and the associated profit/loss.	‚úî	‚úò	Read, Trading Information
2	Statement	Retrieves a summary of account transactions according to the specified search criteria.	‚úî	‚úò	Read, Trading Information
3	Transactions Stream	Subscribes to real-time transaction notifications.	‚úî	‚úî	Read, Trading Information

Updated 4 months ago

Did this page help you?
Yes
No...

---

### Trading APIs
**URL:** https://developers.deriv.com/docs/trading-apis

**Trading Examples:**
```text
tokens
```

```text
portfolio
```

```text
buy_contract_for_multiple_accounts
```

**Implementation Details:**
Trading APIs focus on trading and managing contracts.

They include functionalities for buying, selling, and updating contracts, as well as managing copy trading activities. The APIs also allow users to retrieve important trading information such as profit tables, portfolio details, and contract durations.

These APIs are essential for users who actively trade on the platform and need to manage their trading accounts effectively.

#	API Name	Description	Send	Subscribe	Scope
1	Buy Contract: Trade	Buys a contract.	‚úî	‚úò	Trade
2	Buy Contract for Multiple Accounts	Buys a contract for multiple accounts specified by the tokens parameter. Note that although this is an authorized call, the contract is not purchased for the authorized account.	‚úî	‚úò	Trade
3	Cancel a Contract	Cancels a contract using its contract ID.	‚úî	‚úò	Trade
4	Update Contract	Updates the conditions of a contract.	‚úî	‚úò	Trade
5	Update Contract History	Retrieves the update history of a contract.	‚úî	‚úò	Read
6	Copy Trading: Start	Starts copy trader bets.	‚úî	‚úò	Trade
7	Copy Trading: Stop	Stops copy trader bets.	‚úî	‚úò	Trade
8	Copy Trading: List	Retrieves a list of active copiers and/or traders involved in copy trading.	‚úî	‚úò	Admin
9	Copy Trad...

---

### Utilities APIs
**URL:** https://developers.deriv.com/docs/utilities-apis

**Implementation Details:**
Utilities APIs provide essential information and utility functions for the platform‚Äôs operations. They offer functionalities for retrieving economic calendar events, managing real-time message streams, and accessing details about landing companies and server statuses.

Additionally, these APIs include utility features like server time, ping requests, and country/state lists for account management.

These APIs ensure smooth platform operations and deliver up-to-date trading and account management information.

#	API Name	Description	Send	Subscribe	Scope
1	Economic Calendar	Retrieve a list of economic events for a specific currency. If no currency is specified, the list includes all currencies.	‚úî	‚úò	NA
2	Forget	Immediately cancels the real-time stream of messages with a specific ID.	‚úî	‚úò	NA
3	Forget All	Immediately cancels all real-time streams of messages of a given type.	‚úî	‚úò	NA
4	Landing Company	Retrieve the appropriate landing company based on the client‚Äôs country. Different landing companies may be returned for derived contracts (e.g., Synthetic Indices) and financial contracts (e.g., Forex, Stock Indices, Commodities).	‚úî	‚úò	NA
5	Landing Company Details	Provides information about ea...

---

### Mark-up
**URL:** https://developers.deriv.com/docs/mark-up

**Available Operations:**
- üöß‚ö†Ô∏è Markup impacts the user‚Äôs profit. The higher the markup, the lower their payout.
- Other ways to monetize the Deriv API
- Earning Partner Commissions

**Implementation Details:**
If you build a platform or app that allows users to trade manually or via automation using Deriv APIs, you can earn up to 3% markup commission on every contract your users execute.

Example:

Let‚Äôs say a user places a $10 stake, and the potential payout without any markup is $17.20 if the trade wins.

If you set a 2% markup, your commission will be calculated on the potential payout: 2% of $17.20 = $0.34

With this adjusted stake, the user‚Äôs new potential payout becomes: $16.63

üöß

‚ö†Ô∏è Markup impacts the user‚Äôs profit. The higher the markup, the lower their payout.

Another Example:

Stake: USD 25.50

Payout: USD 50

Markup: 2% of USD 50 = USD 1

Client Balance Debited: USD 26.50

Other ways to monetize the Deriv API

You can make money with your Deriv API application in several ways:

Charge for Access
Offer your trading app for a subscription or one-time fee if it provides value to users.

Offer Premium Features
Charge extra for advanced features like real-time market data or advanced charting tools.

Affiliate Marketing
Join Deriv partnership programmes to earn commissions by referring new users to the platform.

Referral Fees
Encourage your users to refer others by offering the...

---

### Error codes
**URL:** https://developers.deriv.com/docs/error-codes

**Available Operations:**
- General
- MT5
- P2P
- Account
- Application
- Cashier
- Trading
- Deriv X

**Implementation Details:**
General
Error Code	Message
AccountShouldBeReal	Only real accounts are allowed to open [_1] real accounts. Demo account cannot open real dxtrader.
AccountTypesMismatch	Transfer between real and virtual accounts is not allowed.
AccountWithDeposit	Change of currency is not allowed for an existing account with previous deposits.
AffiliateNotFound	N/A
AllowCopiersError	Copier can't be a trader.
AlreadyAgeVerified	Your age has already been verified.
AlreadyVerified	This account is already phone number verified.
AmountNotAllowed	The minimum amount for transfers is [_1] [_2] after conversion fees are deducted. Please adjust the amount.
AppGet	Not Found
AppRegister	Not Found
AppUpdate	N/A
AppropriatenessTestFailed	Failed to reach an acceptable trading experience score.
AuthenticateAccount	Please authenticate your [_1] account to proceed with the fund transfer.
AuthenticateAccountCreate	Please verify your [_1] account to proceed with account creation.
AuthorizationRequired	Please log in.
BadSession	The token you used is invalid in this session. Please get a new token and try again.
BalanceExceeded	This deposit will cause your account balance to exceed your account limit of 300000 USD.
Barrie...

---

### Copy trading
**URL:** https://developers.deriv.com/docs/copy-trading

**Trading Examples:**
```text
allow_copiers
```

```text
allow_copiers
```

**Available Operations:**
- ‚ùóÔ∏èCopy trading is available only for Options.  For copy trading on MT5, use MetaQuotes Signals.
- Becoming a trader
- Becoming a copier

**Implementation Details:**
Copy Trading is a popular trend in financial markets. It allows one user, called the Copier, to automatically replicate the trades of another user, known as the Trader. This way, copiers can benefit from the expertise of experienced traders without making all the trading decisions themselves.

‚ùóÔ∏è

Copy trading is available only for Options. For copy trading on MT5, use MetaQuotes Signals.

Becoming a trader

To allow others to copy your trades:

Enable copying: Set the allow_copiers option via the set settings call.This setting allows other users to copy your trades.

Create an API token: Generate a read-only API token and share it with potential copiers. This token lets them track your trades without making any changes.

Track your performance: With allow_copiers enabled, the copytrading statistics call becomes available. This API provides stats on your trading performance, giving potential copiers insight into your trading history.

Becoming a copier

To start copying a Trader‚Äôs actions:

Start copying: Use the copy start call to begin copying a trader‚Äôs moves.

Stop copying: If you want to stop copying trades, simply use the copy stop call.

By following these steps, you can eas...

---

### Affiliates
**URL:** https://developers.deriv.com/docs/affiliates

**Trading Examples:**
```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID&affiliate_token=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID&affiliate_token=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
YOUR_APP_ID
```

```text
YOUR_TOKEN
```

```text
FB58247C-6B33-4677-A6AD-168C2D72323C
```

```text
dynamicworks
```

```text
jqd7qq_iBB18zg8lBvFoLmNd7ZgqdRLk
```

```text
myaffiliates
```

```text
t
```

```text
utm_campaign
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
new_account_virtual
```

```text
new_account_real
```

```text
new_account_maltainvest
```

**Available Operations:**
- How to Become a Deriv Affiliate
- Affiliate Benefits
- Leveraging Deriv API for Affiliate Earnings
- 1. Signing in Users
- üìòImportant note:
- 2. Creating New Accounts Using APIs

**Implementation Details:**
How to Become a Deriv Affiliate

Getting started as a Deriv Affiliate is simple and quick. Follow these steps:

Visit our Partners page and click on "Become a Partner".
Complete the Affiliate application form.
Wait for approval, which typically takes 1‚Äì3 working days.

Pro Tip: The approval process may be faster if your partner account application uses the same email as an existing Deriv account. Don‚Äôt have an account yet? Sign up here.

Affiliate Benefits

As a Deriv Affiliate, you‚Äôll gain access to exclusive advantages, including:

Up to 45% commission on referred clients‚Äô trading activity.

Free educational and marketing resources to support your efforts.

Multilingual support for global reach.

Transparent fee structure with detailed earnings reports.

Dedicated account manager to assist you.

24/7 live chat support for immediate help.

Affiliates can earn commissions when referred clients trade Options on third-party platforms developed using the Deriv API.

Leveraging Deriv API for Affiliate Earnings

To maximize your affiliate commissions through Deriv API, include your affiliate token when:

1. Signing in Users

Redirect users to the OAuth page with your affiliate token and...

---

### Frequently Asked Questions
**URL:** https://developers.deriv.com/docs/frequently-asked-questions

**Trading Examples:**
```text
affiliate_token
```

```text
api_call_limits
```

```text
website_status
```

```text
api_call_limits
```

```text
website_status
```

```text
max_proposal_subscription
```

```text
max_requests_general
```

```text
max_requests_outcome
```

```text
max_requests_pricing
```

```text
website_status
```

**Available Operations:**
- How do you set up copy trading?
- How to add your affiliate token to your app and not miss any clients?
- What are the terms and conditions for API users?
- API Rate Limiting
- How to find the API request limits?
- What is the maximum number of simultaneous or per-minute requests allowed by the Deriv API?
- 2. What happens if I exceed the API request limits?
- 3. Are the API limits the same across all endpoints?
- 4. What best practices do you recommend to avoid hitting API rate limits?
- 5. What if my application needs a higher request volume?
- 6. Is there a way to monitor API request usage in real-time?
- 7. Where can I find more information or get support regarding API limits?

**Implementation Details:**
How do you set up copy trading?

To set up copy trading on Deriv, follow these steps:

Log into your Deriv account: Ensure you‚Äôre logged into your Deriv account.
Access the Copy Trading feature: Read here to understand the developer API setup.
Choose a Trader to Copy: Review the list of available traders and their performance metrics to select a trader that aligns with your investment goals. You can use the Copy Trading Statistics API to view the performance of the selected trader.
Set Your Trading Parameters: Decide how much capital you want to allocate for copying trades and configure your risk management preferences.
Start Copying: Once set up, your account will automatically replicate the trades of your chosen trader. You can monitor and manage this at any time.

For more technical details on API setup for copy trading, Refer to the documentation here: Copy Trading.

How to add your affiliate token to your app and not miss any clients?

When creating new accounts, ensure to include your affiliate_token in the API request. For detailed instructions on creating an account via the API, refer to the Deriv API documentation.

What are the terms and conditions for API users?

The doc...

---

### Create account using API
**URL:** https://developers.deriv.com/docs/create-account-using-api

**Trading Examples:**
```text
type
```

```text
opening_account
```

```text
residence_list
```

```text
verify_email
```

```text
residence_list
```

```text
payout_currencies
```

```text
verify_email
```

```text
{
  "verify_email": "your_email@example.com",
  "type": "account_opening"
}
```

```text
{
  "verify_email": "your_email@example.com",
  "type": "account_opening"
}
```

```text
{
"new_account_virtual":1,
"client_password":"Abcd1234",
"verification_code":"7y0MXLQG",
"type":"dynamic",
"residence":"aq",
"date_first_contact":"2025-07-30",
"signup_device":"desktop",
"req_id":5
}
```

```text
{
"new_account_virtual":1,
"client_password":"Abcd1234",
"verification_code":"7y0MXLQG",
"type":"dynamic",
"residence":"aq",
"date_first_contact":"2025-07-30",
"signup_device":"desktop",
"req_id":5
}
```

```text
{
    "new_account_wallet": 1,
    "account_opening_reason": "Savings",
    "address_city": "Cyberjaya",
    "address_line_1": "Deriv HQ",
    "address_postcode": "63000",
    "address_state": "",
    "citizen": "de",
    "currency": "EUR",
    "date_of_birth": "2007-08-04",
    "employment_status": "Unemployed",
    "salutation": "Mr",
    "fatca_declaration": 0,
    "tax_residence": "de",
    "first_name": "Tay",
    "last_name": "Suisin",
    "phone": "234124124",
    "place_of_birth": "de",
    "residence": "de",
    "account_type": "doughflow",
    "landing_company_short": "maltainvest",
    "non_pep_declaration": 1,
    "tnc_acceptance": 1,
    "financial_assessment": {
        "employment_status": "Unemployed",
        "occupation": "Manager",
        "income_source": "Sale of art, antiques or other high value assets",
        "net_income": "Over $500,000",
        "source_of_wealth": "Proceeds of sale of crypto currency;Sale of art, antiques or high value assets",
        "estimated_worth": "Over $500,000",
        "investment_intention": "Over $500,000",
        "financial_information_version": "v2",
        "cfd_experience": "Over 3 years",
        "cfd_frequency": "40 transactions or more in the past 12 months",
        "cfd_trading_definition": "Place a bet on the price movement.",
        "leverage_impact_trading": "Leverage lets you open larger positions for a fraction of the trade's value.",
        "leverage_trading_high_risk_stop_loss": "Close your trade automatically when the loss is more than or equal to a specific amount.",
        "required_initial_margin": "When opening a Leveraged CFD trade.",
        "risk_tolerance": "Yes",
        "source_of_experience": "I have an academic degree, professional certification, and/or work experience.",
        "trading_experience_financial_instruments": "Over 3 years",
        "trading_frequency_financial_instruments": "40 transactions or more in the past 12 months"
    },
    "tin_skipped": 1,
    "calling_country_code": "49",
    "loginid": "VRW1115",
    "req_id": 18
}
```

```text
{
    "new_account_wallet": 1,
    "account_opening_reason": "Savings",
    "address_city": "Cyberjaya",
    "address_line_1": "Deriv HQ",
    "address_postcode": "63000",
    "address_state": "",
    "citizen": "de",
    "currency": "EUR",
    "date_of_birth": "2007-08-04",
    "employment_status": "Unemployed",
    "salutation": "Mr",
    "fatca_declaration": 0,
    "tax_residence": "de",
    "first_name": "Tay",
    "last_name": "Suisin",
    "phone": "234124124",
    "place_of_birth": "de",
    "residence": "de",
    "account_type": "doughflow",
    "landing_company_short": "maltainvest",
    "non_pep_declaration": 1,
    "tnc_acceptance": 1,
    "financial_assessment": {
        "employment_status": "Unemployed",
        "occupation": "Manager",
        "income_source": "Sale of art, antiques or other high value assets",
        "net_income": "Over $500,000",
        "source_of_wealth": "Proceeds of sale of crypto currency;Sale of art, antiques or high value assets",
        "estimated_worth": "Over $500,000",
        "investment_intention": "Over $500,000",
        "financial_information_version": "v2",
        "cfd_experience": "Over 3 years",
        "cfd_frequency": "40 transactions or more in the past 12 months",
        "cfd_trading_definition": "Place a bet on the price movement.",
        "leverage_impact_trading": "Leverage lets you open larger positions for a fraction of the trade's value.",
        "leverage_trading_high_risk_stop_loss": "Close your trade automatically when the loss is more than or equal to a specific amount.",
        "required_initial_margin": "When opening a Leveraged CFD trade.",
        "risk_tolerance": "Yes",
        "source_of_experience": "I have an academic degree, professional certification, and/or work experience.",
        "trading_experience_financial_instruments": "Over 3 years",
        "trading_frequency_financial_instruments": "40 transactions or more in the past 12 months"
    },
    "tin_skipped": 1,
    "calling_country_code": "49",
    "loginid": "VRW1115",
    "req_id": 18
}
```

```text
{
"new_account_wallet":1,
"currency":"USD",
"first_name":"Tay",
"last_name":"Suisin",
"date_of_birth":"2007-07-27",
"address_line_1":"Deriv HQ",
"address_city":"Cyberjaya",
"address_postcode":"63000",
"fatca_declaration":0,
"residence":"aq",
"non_pep_declaration":1,
"citizen":"aq",
"phone":"123123123",
"place_of_birth":"aq",
"account_opening_reason":"Savings",
"tax_residence":"aq",
"employment_status":"Unemployed",
"tnc_acceptance":1,
"loginid":"VRW1244",
"calling_country_code":"672",
"account_type":"doughflow",
"tin_skipped":1,
"financial_assessment":{
"financial_information_version":"v2"
},
"req_id":19
}
```

```text
{
"new_account_wallet":1,
"currency":"USD",
"first_name":"Tay",
"last_name":"Suisin",
"date_of_birth":"2007-07-27",
"address_line_1":"Deriv HQ",
"address_city":"Cyberjaya",
"address_postcode":"63000",
"fatca_declaration":0,
"residence":"aq",
"non_pep_declaration":1,
"citizen":"aq",
"phone":"123123123",
"place_of_birth":"aq",
"account_opening_reason":"Savings",
"tax_residence":"aq",
"employment_status":"Unemployed",
"tnc_acceptance":1,
"loginid":"VRW1244",
"calling_country_code":"672",
"account_type":"doughflow",
"tin_skipped":1,
"financial_assessment":{
"financial_information_version":"v2"
},
"req_id":19
}
```

```text
affiliate_token
```

```text
utm_campaign
```

```text
affiliate_token
```

```text
utm_campaign
```

**Available Operations:**
- Verify email
- Create a Demo Account
- Create a Real Account
- Provide the Following Details:
- Create wallet accounts via API
- Create a demo wallet account
- Call verify_email endpoint
- 2Ô∏è‚É£ Call new_account_virtual endpoint
- Create a real wallet account
- For EU Residents
- Call new_account_wallet endpoint
- For Non-EU Residents
- Call new_account_wallet endpoint
- üìòNotes
- Earn with Deriv‚Äôs Affiliate Program

**Implementation Details:**
Follow these simple steps to create demo and real accounts using the Deriv API:

Verify email
Make a call to the verify_email endpoint.
Set the type parameter to opening_account to indicate you‚Äôre opening a new account.
You will receive an email containing a verification code at the email address provided in the API call. This code is required for the next steps.


Create a Demo Account

To create a demo account:

Make a call to the new_account_virtual endpoint.
Provide the following information:
Residence: The 2-letter country code. Obtain this from the residence_list call or check the list here.
Verification Code: The email verification code you received from the verify_email call above.

A demo account will be created with a starting balance of USD 10,000.

Create a Real Account

To set up a real account, follow these steps after logging into your demo account:

For users in the EU: Use the new_account_maltainvest endpoint.

For users outside the EU: Use the new_account_real endpoint.

Provide the Following Details:

Residence: The 2-letter country code. Obtain this from the residence_list call or check the list here.

Currency: Set the currency for the account. You can find the...

---

### Trade Options
**URL:** https://developers.deriv.com/docs/trade-using-accumalators

**Implementation Details:**
Options: A financial derivative that gives the buyer the right, but not the obligation, to buy or sell an asset at a set price within a specific period. Options can be used for speculation or hedging.

The types of options supported on Deriv include:

Updated 10 months ago

Did this page help you?
Yes
No...

---

### Rise/Fall
**URL:** https://developers.deriv.com/docs/risefall

**Trading Examples:**
```text
contract_type
```

```text
contract_type
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
Predict if the market price will rise above or fall below the entry price at the end of the contract.

If you select "Rise", you win the Payout if the Exit spot is strictly higher than the Entry spot.

If you select "Fall", you win the Payout if the Exit spot is strictly lower than the Entry spot.

If you select "Allow equals", you win the Payout if Exit spot is higher than or equal to Entry spot for "Rise". Similarly, you win the Payout if Exit spot is lower than or equal to Entry spot for "Fall".

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Rise/Fall options, set the contract_type:

For Rise, use: "PUT"

For Fall, use: "CALL"

If you want to select "Allow Equals" where you win Payoutif Exit spott is also equal to Entry spot, then set the contract_type:
...

---

### Higher/Lower
**URL:** https://developers.deriv.com/docs/higherlower

**Trading Examples:**
```text
contract_type
```

```text
barrier: "+0.37"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
Choose a target price (Barrier) and predict if the market price will be higher or lower than the target at the end of the contract.

If you select "Higher", you win the Payout if the Exit spot is strictly higher than the Barrier.

If you select "Lower", you win the Payout if the Exit spotis strictly lower than the Barrier.

If the Exit spot is equal to the Barrier, you don't win the Payout.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Higher/Lower options:

Use the the contract_type:
For Higher, use: "CALL"
For Lower, use: "PUT"
Set the Barrier. Eg: barrier: "+0.37"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action returns a unique contract_id.

Monitor the Contract Status: Check the contract‚Äôs p...

---

### Ends Between
**URL:** https://developers.deriv.com/docs/ends-between

**Trading Examples:**
```text
contract_type
```

```text
EXPIRYRANGE
```

```text
EXPIRYMISS
```

```text
barrier
```

```text
barrier: "+1.51"
```

```text
barrier2
```

```text
barrier: "-1.51"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow
- üëçAdd +/- to define a barrier offset. For example, +0.005 means a Barrier that's 0.005 higher than the Entry spot.

**Implementation Details:**
Choose a price range (upper and lower barriers) and predict if the market price will end between or end outside the range at the end of the contract.

If you select "Ends Between", you win the Payout if the Exit spot is strictly higher than the Low Barrier AND strictly lower than the High Barrier.

If you select "Ends Outside", you win the Payout if the Exit spot is EITHER strictly higher than the High Barrier, OR strictly lower than the Low Barrier.

If the Exit spot is equal to either the Low Barrier or the High Barrier, you don‚Äôt win the Payout.

Trading Flow

Authorize using your token: Call [authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Ends Between/Outside options, use the following:

Set contract_type:

For Ends Between, use: "EXPIRYRANGE"
For Ends Outside, use: "EXPIRYMISS"

For the High Barrier...

---

### Stays Between
**URL:** https://developers.deriv.com/docs/stays-between

**Trading Examples:**
```text
contract_type
```

```text
RANGE
```

```text
UPORDOWN
```

```text
barrier
```

```text
barrier: "+1.51"
```

```text
barrier2
```

```text
barrier: "-1.51"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow
- üëçAdd +/- to define a barrier offset. For example, +0.005 means a Barrier that's 0.005 higher than the Entry spot.

**Implementation Details:**
Choose a price range (upper and lower barriers) and predict if the market price will stay between or go outside the range during the contract period.

If you select "Stays Between", you win the Payout if the market stays between (does not touch) either the High Barrier or the Low Barrier at any time during the Contract period.

If you select "Goes Outside", you win the Payout if the market touches either the High Barrier or the Low Barrier at any time during the Contract period.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Stays Between/ Goes Outside options, use the following:

Set contract_type:

For Stay Between, use: "RANGE"
For Goes Outside, use: "UPORDOWN"

For the High Barrier Offset: set the barrier Eg: barrier: "+1.51"

For the Low Barrier Offset...

---

### Lookbacks
**URL:** https://developers.deriv.com/docs/lookbacks

**Trading Examples:**
```text
contract_type
```

```text
LBFLOATPUT
```

```text
multiplier: 1
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

```text
contract_type
```

```text
LBHIGHLOW
```

```text
multiplier: 1
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

```text
contract_type
```

```text
LBFLOATCALL
```

```text
multiplier: 1
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- High-Close
- Trading Flow
- High-Low
- Trading Flow
- Close-Low
- Trading Flow

**Implementation Details:**
Choose an amount you want to earn per point of movement. There are three types of lookbacks:

High-Close: The highest market price during the contract period minus the price at the contract end.
High-Low: The highest market price minus the lowest market price during the contract period.
Close-Low: The market price at the contract end minus the lowest market price during the contract period.
High-Close

By purchasing the "High-Close" contract, you'll win the multiplier times the difference between the High and Close over the duration of the contract.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the High-Close Lookback:

Use the contract_type as: "LBFLOATPUT"

Set the multiplier. Eg: Use multiplier: 1

Buy the Contract: Execute the trade by using the buy API with t...

---

### Touch/No Touch
**URL:** https://developers.deriv.com/docs/touchno-touch

**Trading Examples:**
```text
contract_type
```

```text
ONETOUCH
```

```text
NOTOUCH
```

```text
barrier: "+1.37"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
Choose a target price (Barrier) and predict if the market price will touch or not touch the target during the contract period.

If you select "Touch", you win the Payout if the market touches the Barrier at any time during the contract period.

If you select "No Touch", you win the Payout if the market never touches the Barrier at any time during the contract period.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Touch/No Touch options:

Use the the contract_type:

For Touch, use: "ONETOUCH"
For No Touch, use: "NOTOUCH"

Set the Barrier. Eg: barrier: "+1.37"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action returns a unique contract_id.

Monitor the Contract Status: Check the contract‚Äôs progress or...

---

### Only Ups/Only Downs
**URL:** https://developers.deriv.com/docs/only-upsonly-downs

**Trading Examples:**
```text
contract_type
```

```text
RUNHIGH
```

```text
RUNLOW
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
Predict if the market price will go only up or only down during the contract period.

If you select "Only Ups", you win the Payout if consecutive ticks rise successively after the Entry spot. No payout if any tick falls or is equal to any of the previous ticks.

If you select "Only Downs", you win the Payout if consecutive ticks fall successively after the Entry spot. No payout if any tick rises or is equal to any of the previous ticks.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Only Ups/Downs options:

Use the the contract_type:
For Only Ups , use: "RUNHIGH"
For Only Downs, use: "RUNLOW"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action returns a unique contract_id.

Monitor the Contract Statu...

---

### Highest/Lowest Tick
**URL:** https://developers.deriv.com/docs/highestlowest-tick

**Trading Examples:**
```text
contract_type
```

```text
TICKHIGH
```

```text
TICKLOW
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
Predict which of the next 5 ticks will see the highest or lowest market price.

If you select "High Tick", you win the Payout if the selected tick is the highest among the next five ticks.

If you select "Low Tick", you win the Payout if the selected tick is the lowest among the next five ticks.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the High/Low Tick options:

Use the the contract_type:
For High Tick, use: "TICKHIGH"
For Low Tick, use: "TICKLOW"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action returns a unique contract_id.

Monitor the Contract Status: Check the contract‚Äôs progress or outcome using the proposal_open_contract API with the contract_id.

Close the Contract Early (if Needed): If ...

---

### Reset Call/Put
**URL:** https://developers.deriv.com/docs/reset-callput

**Trading Examples:**
```text
contract_type
```

```text
RESETCALL
```

```text
RESETPUT
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
Predict if the market price will be higher (Call) or lower (Put) than the entry price or the reset price at the end of the contract. A 'reset' is triggered if the market moves against your prediction around the midpoint of the contract, setting the reset price to the market‚Äôs current level.




If you select "Reset-Call", you win the Payout if the Exit spot is strictly higher than either the Entry spot or the spot at Reset time.

If you select "Reset-Put", you win the Payout if the Exit spot is strictly lower than either the Entry spot or the spot at Reset time.

If the Exit spot is equal to the Barrier or the new Barrier (if a reset occurs), you don't win the Payout.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Reset Call/Put options:

Use the the contra...

---

### Asian Up/Down
**URL:** https://developers.deriv.com/docs/asian-updown

**Trading Examples:**
```text
contract_type
```

```text
ASIANU
```

```text
ASIAND
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
Asian options settle by comparing the last tick with the average spot over the period.

If you select "Asian Up", you will win the Payout if the last tick is higher than the averageof the ticks.

If you select "Asian Down", you will win the Payout if the last tick is lower than the average of the ticks.

If the last tick is equal to the average of the ticks, you don't win the Payout.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.
Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.
Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Asian Up/Down options, set the the contract_type:
For Up, use: "ASIANU"
For Down, use: "ASIAND"
Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action returns a unique contract_id.
Monitor the Contract Status: Check the contract‚Äôs progress or outcome using the proposal_open_contract...

---

### Digit Matches/Differs
**URL:** https://developers.deriv.com/docs/digit-matchesdiffers

**Trading Examples:**
```text
contract_type
```

```text
DIGITMATCH
```

```text
DIGITDIFF
```

```text
barrier
```

```text
barrier: "9"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
If you select "Matches", you will win the payout if the last digit of the last tick is the same as your prediction.

If you select "Differs", you will win the payout if the last digit of the last tick is not the same as your prediction.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Matches/Differs options, use the following:

Set contract_type:

For Matches, use: "DIGITMATCH"
For Differs, use: "DIGITDIFF"

For the Last Digit Prediction: set the barrier between 0-9. Eg: barrier: "9"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action returns a unique contract_id.

Monitor the Contract Status: Check the contract‚Äôs progress or outcome using the proposal_open_contract API with the contract_id.

Close th...

---

### Digit Even/Odd
**URL:** https://developers.deriv.com/docs/digit-evenodd

**Trading Examples:**
```text
contract_type
```

```text
DIGITEVEN
```

```text
DIGITODD
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
If you select "Even", you will win the Payout if the last digit of the last tick is an even number (i.e., 2, 4, 6, 8, or 0).

If you select "Odd", you will win the Payout if the last digit of the last tick is an odd number (i.e., 1, 3, 5, 7, or 9).

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the digit Even/Odd options, use the following the contract_type:

For Even: "DIGITEVEN"
For Odd: "DIGITODD"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action returns a unique contract_id.

Monitor the Contract Status: Check the contract‚Äôs progress or outcome using the proposal_open_contract API with the contract_id.

Close the Contract Early (if Needed): If you want to exit before the contract‚Äôs expiration, use ...

---

### Digit Over/Under
**URL:** https://developers.deriv.com/docs/digit-overunder

**Trading Examples:**
```text
contract_type
```

```text
DIGITMATCH
```

```text
DIGITUNDER
```

```text
barrier
```

```text
barrier: "6"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
If you select "Over", you will win the Payout if the last digit of the last tick is greater than your prediction.

If you select "Under", you will win the Payout if the last digit of the last tick is less than your prediction.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Digit Over/Under options, use the following

Set contract_type:

For Over, use: "DIGITMATCH"
For Under, use: "DIGITUNDER"

For the Last Digit Prediction: set the barrier between 0-9. Eg: barrier: "6"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action returns a unique contract_id.

Monitor the Contract Status: Check the contract‚Äôs progress or outcome using the proposal_open_contract API with the contract_id.

Close the Contract Ear...

---

### Accumulator Options
**URL:** https://developers.deriv.com/docs/accumulator-options

**Trading Examples:**
```text
contract_type
```

```text
"ACCU"
```

```text
growth_rate: 0.03
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150 }
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
Amplify potential profits with up to 5% compounding growth per tick with Accumulator Options.

Choose a growth rate (1-5%) within a specified price range and predict if the market price will stay within the range. Your Payout grows at a compounding rate for each tick, and the market price stays in the range.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.
Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.
Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the accumulator options,
Use the contract_type: "ACCU"
Growth Rate: You can choose a growth rate with values of 1%(0.01), 2%(0.02), 3%(0.03), 4%(0.04), and 5%(0.05). Eg: Set growth_rate: 0.03
Take Profit: If you select this feature, your trade will be closed automatically when the value of the contract reaches a specific profit.
Eg: Set limit_order as:"

limit_order : { take_profit: 150 }

Buy the Contract: Execute...

---

### Vanilla Options
**URL:** https://developers.deriv.com/docs/vanilla-options

**Trading Examples:**
```text
contract_type
```

```text
"VANILLALONGCALL"
```

```text
"VANILLALONGPUT"
```

```text
barrier: "+0.00"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
Earn a potentially high payout with Vanilla Options if your predictions are right within a timed contract based on market conditions.

Vanilla options allow you to predict an upward (bullish) or downward (bearish) direction of the underlying asset by purchasing a "Call" or a "Put".

If you select "Call", you'll earn a Payout if the Final price is above the Strike price at Expiry. Otherwise, you won't receive a payout.
If you select "Put", you'll earn a Payout if the Final price is below the Strike price at Expiry. Otherwise, you won't receive a payout.

Your Payout is equal to the Payout per point multiplied by the difference between the Final price and the Strike price. You will only earn a profit if your Payout is higher than your initial stake.

You may sell the contract up until 60 seconds before Expiry. If you do, we'll pay you the Contract value.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.
Get Contract Details: Using the contracts_for API, obtain a list of contracts avail...

---

### Turbo Options
**URL:** https://developers.deriv.com/docs/turbo-options

**Trading Examples:**
```text
contract_type
```

```text
"TURBOSLONG"
```

```text
"TURBOSSHORT"
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150 }
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
With Turbo Options, you can earn a payout if your predictions are right and if the spot price does not touch or breach a predetermined barrier.

Turbo options allow you to predict the direction of the underlying asset's movements.

You receive a Payout at Expiry if the spot price never breaches the Barrier during the contract period. If it does, your contract will be terminated early.

If you select "Up", you'll earn a Payout if the spot price never drops below the Barrier.

If you select "Down", you'll earn a Payout if the spot price never rises above the Barrier.

Your payout is equal to the Payout per point multiplied by the distance between the Final price and the Barrier. You will only earn a profit if your Payout is higher than your initial stake.

You may sell the contract up to 15 seconds before expiry. If you do, we'll pay you the Contract value.
If you choose your duration in number of ticks, you won't be able to terminate your contract early.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instrument...

---

### Multipliers
**URL:** https://developers.deriv.com/docs/multipliers

**Trading Examples:**
```text
contract_type
```

```text
"MULTUP"
```

```text
"MULTDOWN"
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150 }
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150, stop_loss:130 }
```

```text
cancellation: 60m
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Available Operations:**
- Trading Flow

**Implementation Details:**
Multiply your potential profit by up to 2,000x if the market moves in your favour. Losses are limited only to your initial capital.

Choose a multiplier (up to 2,000x) and predict if the market price will go up(bullish)or down (bearish) compared to the entry price. Your potential payout grows as the market price moves in your predicted direction, boosted by the multiplier. Losses are limited to the initial amount you put into the contract.

If you select "Up", your total profit/loss will be the percentage increase in the underlying asset price, times the multiplier and stake, minus commissions.
If you select "Down", your total profit/loss will be the percentage decrease in the underlying asset price, times the multiplier and stake, minus commissions.

Your contract will be closed when the Stop out level is reached.

Additional features are available to manage your positions: Take profit, Stop loss and Deal cancellation allow you to adjust your level of risk aversion.

You can close your trade anytime.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fetch Available Instruments: Use the active_symbols...

---

### Keep connection live
**URL:** https://developers.deriv.com/docs/keep-connection-live

**Trading Examples:**
```text
DerivAPIBasic
```

```text
import DerivAPIBasic from 'https://cdn.skypack.dev/@deriv/deriv-api/dist/DerivAPIBasic';
```

```text
app_id
```

```text
wss://ws.derivws.com/websockets/v3?app_id=${app_id}
```

```text
const connection = new WebSocket(
```

```text
);
```

```text
DerivAPIBasic
```

```text
const api = new DerivAPIBasic({ connection });
```

```text
proposal()
```

```text
const proposal = () => {  
  api.subscribe({  
    proposal: 1,  
    subscribe: 1,  
    amount: 10,  
    basis: 'payout',  
    contract_type: 'CALL',  
    currency: 'USD',  
    duration: 1,  
    duration_unit: 'm',  
    symbol: 'R_100',  
    barrier: '+0.1',  
  });  
};
```

```text
const proposal = () => {  
  api.subscribe({  
    proposal: 1,  
    subscribe: 1,  
    amount: 10,  
    basis: 'payout',  
    contract_type: 'CALL',  
    currency: 'USD',  
    duration: 1,  
    duration_unit: 'm',  
    symbol: 'R_100',  
    barrier: '+0.1',  
  });  
};
```

```text
ping()
```

```text
ping
```

```text
setInterval
```

```text
const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000);
};
```

```text
const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000);
};
```

```text
wsResponse()
```

```text
const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error: %s ', data.error.message);
    connection.removeEventListener('message', wsResponse, false);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details: %s', data.proposal.longcode);
    console.log('Ask Price: %s', data.proposal.display_value);
    console.log('Payout: %f', data.proposal.payout);
    console.log('Spot: %f', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};
```

```text
const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error: %s ', data.error.message);
    connection.removeEventListener('message', wsResponse, false);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details: %s', data.proposal.longcode);
    console.log('Ask Price: %s', data.proposal.display_value);
    console.log('Payout: %f', data.proposal.payout);
    console.log('Spot: %f', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};
```

```text
checkSignal()
```

```text
proposal()
```

```text
ping()
```

```text
connection.addEventListener('message', wsResponse)
```

```text
wsResponse()
```

```text
const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};
```

```text
const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};
```

```text
endCall()
```

```text
unsubscribe()
```

```text
proposal()
```

```text
const endCall = () => {
  connection.removeEventListener('message', wsResponse, false);
  proposal().unsubscribe();
};
```

```text
const endCall = () => {
  connection.removeEventListener('message', wsResponse, false);
  proposal().unsubscribe();
};
```

```text
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

const app_id = app_id; // Replace with your app_id if different.
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
const api = new DerivAPIBasic({ connection });

const proposal = () => {
  api.subscribe({
    proposal: 1,
    subscribe: 1,
    amount: 10,
    basis: 'payout',
    contract_type: 'CALL',
    currency: 'USD',
    duration: 1,
    duration_unit: 'm',
    symbol: 'R_100',
    barrier: '+0.1',
  });
};

const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000); // Sends a ping message every 30 seconds
};

const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error:', data.error.message);
    connection.removeEventListener('message', wsResponse);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details:', data.proposal.longcode);
    console.log('Ask Price:', data.proposal.display_value);
    console.log('Payout:', data.proposal.payout);
    console.log('Spot:', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};

const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};

// Browser-specific functionality
if (typeof document !== 'undefined') {
  const keep_alive_button = document.querySelector('#keep_alive');
  const end_call_button = document.querySelector('#end_call');

  keep_alive_button.addEventListener('click', checkSignal);
  end_call_button.addEventListener('click', () => {
    connection.removeEventListener('message', wsResponse);
    proposal().unsubscribe();
  });
} else {
  // For Node.js environment: start the signal check immediately
  checkSignal();
}

/*
Instructions:

1. **Install Node.js**: Ensure you have Node.js installed from https://nodejs.org/.
2. **Install Deriv API Package**: Use npm to install the Deriv API package by running:
npm install @deriv/deriv-api
3. **Save the Code**: Save the code in a file, e.g., `websocket_example.js`.
4. **Run in Node.js**:
- In your terminal, navigate to the directory where you saved the file.
- Run the script using:
  ```
  node websocket_example.js
  ```
5. **Run in a Browser**:
- Include the script in your HTML page, and ensure there are two buttons with IDs `keep_alive` and `end_call`.
- Use the `keep_alive` button to start the signal check and the `end_call` button to unsubscribe from the proposal and stop receiving messages.

Replace the `app_id` in the URL if you have a different app ID.
*/
```

```text
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

const app_id = app_id; // Replace with your app_id if different.
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
const api = new DerivAPIBasic({ connection });

const proposal = () => {
  api.subscribe({
    proposal: 1,
    subscribe: 1,
    amount: 10,
    basis: 'payout',
    contract_type: 'CALL',
    currency: 'USD',
    duration: 1,
    duration_unit: 'm',
    symbol: 'R_100',
    barrier: '+0.1',
  });
};

const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000); // Sends a ping message every 30 seconds
};

const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error:', data.error.message);
    connection.removeEventListener('message', wsResponse);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details:', data.proposal.longcode);
    console.log('Ask Price:', data.proposal.display_value);
    console.log('Payout:', data.proposal.payout);
    console.log('Spot:', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};

const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};

// Browser-specific functionality
if (typeof document !== 'undefined') {
  const keep_alive_button = document.querySelector('#keep_alive');
  const end_call_button = document.querySelector('#end_call');

  keep_alive_button.addEventListener('click', checkSignal);
  end_call_button.addEventListener('click', () => {
    connection.removeEventListener('message', wsResponse);
    proposal().unsubscribe();
  });
} else {
  // For Node.js environment: start the signal check immediately
  checkSignal();
}

/*
Instructions:

1. **Install Node.js**: Ensure you have Node.js installed from https://nodejs.org/.
2. **Install Deriv API Package**: Use npm to install the Deriv API package by running:
npm install @deriv/deriv-api
3. **Save the Code**: Save the code in a file, e.g., `websocket_example.js`.
4. **Run in Node.js**:
- In your terminal, navigate to the directory where you saved the file.
- Run the script using:
  ```
  node websocket_example.js
  ```
5. **Run in a Browser**:
- Include the script in your HTML page, and ensure there are two buttons with IDs `keep_alive` and `end_call`.
- Use the `keep_alive` button to start the signal check and the `end_call` button to unsubscribe from the proposal and stop receiving messages.

Replace the `app_id` in the URL if you have a different app ID.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a proposal subscription request
    func sendProposalSubscription() {
        let proposalRequest = [
            "proposal": 1,
            "subscribe": 1,
            "amount": 10,
            "basis": "payout",
            "contract_type": "CALL",
            "currency": "USD",
            "duration": 1,
            "duration_unit": "m",
            "symbol": "R_100",
            "barrier": "+0.1"
        ] as [String: Any]
        
        if let proposalData = try? JSONSerialization.data(withJSONObject: proposalRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(proposalData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send proposal subscription: \(error.localizedDescription)")
                } else {
                    print("Proposal subscription sent.")
                }
            }
        }
    }
    
    // Function to send a ping message every 30 seconds
    func startPing() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            let pingMessage = URLSessionWebSocketTask.Message.string("{\"ping\": 1}")
            webSocketTask?.send(pingMessage) { error in
                if let error = error {
                    print("[error] Failed to send ping: \(error.localizedDescription)")
                } else {
                    print("Ping sent to keep connection alive.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the proposal and ping response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "proposal", let proposal = data["proposal"] as? [String: Any] {
            print("Details: \(proposal["longcode"] ?? "")")
            print("Ask Price: \(proposal["display_value"] ?? "")")
            print("Payout: \(proposal["payout"] ?? "")")
            print("Spot: \(proposal["spot"] ?? "")")
        } else if data["msg_type"] as? String == "ping" {
            print("[Ping] Ping response received.")
        }
    }
    
    // Start sending the proposal subscription and pinging the server
    sendProposalSubscription()
    startPing()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
 * Instructions to Run:
 * 1. Ensure Swift is installed on your machine.
 * 2. Save this code in a file, for example, `WebSocketClient.swift`.
 * 3. Open a terminal, navigate to the directory where you saved the file, and run:
 *      swift WebSocketClient.swift
 * 4. The script connects to the WebSocket server, sends a proposal subscription, and sends a ping every 30 seconds to keep the connection alive.
 */
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a proposal subscription request
    func sendProposalSubscription() {
        let proposalRequest = [
            "proposal": 1,
            "subscribe": 1,
            "amount": 10,
            "basis": "payout",
            "contract_type": "CALL",
            "currency": "USD",
            "duration": 1,
            "duration_unit": "m",
            "symbol": "R_100",
            "barrier": "+0.1"
        ] as [String: Any]
        
        if let proposalData = try? JSONSerialization.data(withJSONObject: proposalRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(proposalData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send proposal subscription: \(error.localizedDescription)")
                } else {
                    print("Proposal subscription sent.")
                }
            }
        }
    }
    
    // Function to send a ping message every 30 seconds
    func startPing() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            let pingMessage = URLSessionWebSocketTask.Message.string("{\"ping\": 1}")
            webSocketTask?.send(pingMessage) { error in
                if let error = error {
                    print("[error] Failed to send ping: \(error.localizedDescription)")
                } else {
                    print("Ping sent to keep connection alive.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the proposal and ping response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "proposal", let proposal = data["proposal"] as? [String: Any] {
            print("Details: \(proposal["longcode"] ?? "")")
            print("Ask Price: \(proposal["display_value"] ?? "")")
            print("Payout: \(proposal["payout"] ?? "")")
            print("Spot: \(proposal["spot"] ?? "")")
        } else if data["msg_type"] as? String == "ping" {
            print("[Ping] Ping response received.")
        }
    }
    
    // Start sending the proposal subscription and pinging the server
    sendProposalSubscription()
    startPing()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
 * Instructions to Run:
 * 1. Ensure Swift is installed on your machine.
 * 2. Save this code in a file, for example, `WebSocketClient.swift`.
 * 3. Open a terminal, navigate to the directory where you saved the file, and run:
 *      swift WebSocketClient.swift
 * 4. The script connects to the WebSocket server, sends a proposal subscription, and sends a ping every 30 seconds to keep the connection alive.
 */
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{time::interval, sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[open] Connection established");

    // Proposal request JSON
    let proposal_request = json!({
        "proposal": 1,
        "subscribe": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    });

    // Clone `socket` for the ping task and start pinging every 30 seconds
    let ping_socket = Arc::clone(&socket);
    let ping_task = spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            let mut socket = ping_socket.lock().await;
            if socket.send(Message::Text(json!({ "ping": 1 }).to_string())).await.is_ok() {
                println!("[ping] Ping sent to keep connection alive.");
            }
        }
    });

    // Clone `socket` for sending the proposal
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(proposal_request.to_string())).await.is_ok() {
            println!("Proposal subscription sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if let Some(proposal) = data.get("proposal") {
                        println!("Details: {}", proposal["longcode"]);
                        println!("Ask Price: {}", proposal["display_value"]);
                        println!("Payout: {}", proposal["payout"]);
                        println!("Spot: {}", proposal["spot"]);
                    } else if data.get("msg_type").unwrap_or(&json!("")) == "ping" {
                        println!("[Ping] Ping response received.");
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(ping_task, send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{time::interval, sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[open] Connection established");

    // Proposal request JSON
    let proposal_request = json!({
        "proposal": 1,
        "subscribe": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    });

    // Clone `socket` for the ping task and start pinging every 30 seconds
    let ping_socket = Arc::clone(&socket);
    let ping_task = spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            let mut socket = ping_socket.lock().await;
            if socket.send(Message::Text(json!({ "ping": 1 }).to_string())).await.is_ok() {
                println!("[ping] Ping sent to keep connection alive.");
            }
        }
    });

    // Clone `socket` for sending the proposal
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(proposal_request.to_string())).await.is_ok() {
            println!("Proposal subscription sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if let Some(proposal) = data.get("proposal") {
                        println!("Details: {}", proposal["longcode"]);
                        println!("Ask Price: {}", proposal["display_value"]);
                        println!("Payout: {}", proposal["payout"]);
                        println!("Spot: {}", proposal["spot"]);
                    } else if data.get("msg_type").unwrap_or(&json!("")) == "ping" {
                        println!("[Ping] Ping response received.");
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(ping_task, send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a proposal subscription request
    $proposal_request = json_encode([
        "proposal" => 1,
        "subscribe" => 1,
        "amount" => 10,
        "basis" => "payout",
        "contract_type" => "CALL",
        "currency" => "USD",
        "duration" => 1,
        "duration_unit" => "m",
        "symbol" => "R_100",
        "barrier" => "+0.1"
    ]);
    $client->send($proposal_request);
    echo "[sent] Proposal subscription sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "proposal") {
            $proposal = $data["proposal"];
            echo "[proposal] Details: {$proposal['longcode']}\n";
            echo "[proposal] Ask Price: {$proposal['display_value']}\n";
            echo "[proposal] Payout: {$proposal['payout']}\n";
            echo "[proposal] Spot: {$proposal['spot']}\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `websocket_client.php`.
6. Run the code from the command line:

   php websocket_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a proposal subscription request
    $proposal_request = json_encode([
        "proposal" => 1,
        "subscribe" => 1,
        "amount" => 10,
        "basis" => "payout",
        "contract_type" => "CALL",
        "currency" => "USD",
        "duration" => 1,
        "duration_unit" => "m",
        "symbol" => "R_100",
        "barrier" => "+0.1"
    ]);
    $client->send($proposal_request);
    echo "[sent] Proposal subscription sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "proposal") {
            $proposal = $data["proposal"];
            echo "[proposal] Details: {$proposal['longcode']}\n";
            echo "[proposal] Ask Price: {$proposal['display_value']}\n";
            echo "[proposal] Payout: {$proposal['payout']}\n";
            echo "[proposal] Spot: {$proposal['spot']}\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `websocket_client.php`.
6. Run the code from the command line:

   php websocket_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// Define constants
const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//Replace with your app_id
)

// ProposalRequest defines the structure of the proposal subscription request
type ProposalRequest struct {
	Proposal      int    `json:"proposal"`
	Subscribe     int    `json:"subscribe"`
	Amount        int    `json:"amount"`
	Basis         string `json:"basis"`
	ContractType  string `json:"contract_type"`
	Currency      string `json:"currency"`
	Duration      int    `json:"duration"`
	DurationUnit  string `json:"duration_unit"`
	Symbol        string `json:"symbol"`
	Barrier       string `json:"barrier"`
}

func main() {
	// Set up WebSocket connection context
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish a WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("WebSocket connection established.")

	// Send initial proposal subscription request
	err = sendProposalRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send proposal request: %v", err)
	}

	// Start keep-alive ping
	go keepAlivePing(ctx, conn)

	// Handle incoming messages
	handleResponses(ctx, conn)
}

// sendProposalRequest sends a proposal subscription request to the WebSocket server
func sendProposalRequest(ctx context.Context, conn *websocket.Conn) error {
	// Construct proposal subscription request
	proposal := ProposalRequest{
		Proposal:     1,
		Subscribe:    1,
		Amount:       10,
		Basis:        "payout",
		ContractType: "CALL",
		Currency:     "USD",
		Duration:     1,
		DurationUnit: "m",
		Symbol:       "R_100",
		Barrier:      "+0.1",
	}
	fmt.Println("Sending proposal subscription...")

	return wsjson.Write(ctx, conn, proposal)
}

// keepAlivePing sends a ping message every 30 seconds to keep the connection alive
func keepAlivePing(ctx context.Context, conn *websocket.Conn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Send ping message
			pingMsg := map[string]int{"ping": 1}
			err := wsjson.Write(ctx, conn, pingMsg)
			if err != nil {
				log.Printf("Ping failed: %v", err)
				return
			}
			fmt.Println("Ping sent.")
		case <-ctx.Done():
			return
		}
	}
}

// handleResponses listens for and processes messages received from the WebSocket server
func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}
		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		// Process response messages
		msgType := response["msg_type"]
		switch msgType {
		case "proposal":
			// Print proposal details
			proposal := response["proposal"].(map[string]interface{})
			fmt.Printf("Details: %v\n", proposal["longcode"])
			fmt.Printf("Ask Price: %v\n", proposal["display_value"])
			fmt.Printf("Payout: %v\n", proposal["payout"])
			fmt.Printf("Spot: %v\n", proposal["spot"])
		case "ping":
			fmt.Println("[Ping] Ping response received.")
		default:
			fmt.Printf("Received message: %v\n", response)
		}
	}
}

/*
Instructions to run the code locally:

1. Install Go: Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.

2. Save the code:
   - Save this code into a file named `connect.go`.

3. Initialize a Go module:
   - Open a terminal in the directory containing `connect.go`.
   - Run `go mod init app` to initialize a new Go module.
   - Run `go get nhooyr.io/websocket` to install the WebSocket package dependency.

4. Run the code:
   - Execute the code using the command `go run connect.go`.
   - Alternatively, you can build and run the executable:
     ```
     go build -o connect connect.go
     ./connect
     ```
5. Replace `app_id=1089` with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// Define constants
const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//Replace with your app_id
)

// ProposalRequest defines the structure of the proposal subscription request
type ProposalRequest struct {
	Proposal      int    `json:"proposal"`
	Subscribe     int    `json:"subscribe"`
	Amount        int    `json:"amount"`
	Basis         string `json:"basis"`
	ContractType  string `json:"contract_type"`
	Currency      string `json:"currency"`
	Duration      int    `json:"duration"`
	DurationUnit  string `json:"duration_unit"`
	Symbol        string `json:"symbol"`
	Barrier       string `json:"barrier"`
}

func main() {
	// Set up WebSocket connection context
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish a WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("WebSocket connection established.")

	// Send initial proposal subscription request
	err = sendProposalRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send proposal request: %v", err)
	}

	// Start keep-alive ping
	go keepAlivePing(ctx, conn)

	// Handle incoming messages
	handleResponses(ctx, conn)
}

// sendProposalRequest sends a proposal subscription request to the WebSocket server
func sendProposalRequest(ctx context.Context, conn *websocket.Conn) error {
	// Construct proposal subscription request
	proposal := ProposalRequest{
		Proposal:     1,
		Subscribe:    1,
		Amount:       10,
		Basis:        "payout",
		ContractType: "CALL",
		Currency:     "USD",
		Duration:     1,
		DurationUnit: "m",
		Symbol:       "R_100",
		Barrier:      "+0.1",
	}
	fmt.Println("Sending proposal subscription...")

	return wsjson.Write(ctx, conn, proposal)
}

// keepAlivePing sends a ping message every 30 seconds to keep the connection alive
func keepAlivePing(ctx context.Context, conn *websocket.Conn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Send ping message
			pingMsg := map[string]int{"ping": 1}
			err := wsjson.Write(ctx, conn, pingMsg)
			if err != nil {
				log.Printf("Ping failed: %v", err)
				return
			}
			fmt.Println("Ping sent.")
		case <-ctx.Done():
			return
		}
	}
}

// handleResponses listens for and processes messages received from the WebSocket server
func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}
		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		// Process response messages
		msgType := response["msg_type"]
		switch msgType {
		case "proposal":
			// Print proposal details
			proposal := response["proposal"].(map[string]interface{})
			fmt.Printf("Details: %v\n", proposal["longcode"])
			fmt.Printf("Ask Price: %v\n", proposal["display_value"])
			fmt.Printf("Payout: %v\n", proposal["payout"])
			fmt.Printf("Spot: %v\n", proposal["spot"])
		case "ping":
			fmt.Println("[Ping] Ping response received.")
		default:
			fmt.Printf("Received message: %v\n", response)
		}
	}
}

/*
Instructions to run the code locally:

1. Install Go: Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.

2. Save the code:
   - Save this code into a file named `connect.go`.

3. Initialize a Go module:
   - Open a terminal in the directory containing `connect.go`.
   - Run `go mod init app` to initialize a new Go module.
   - Run `go get nhooyr.io/websocket` to install the WebSocket package dependency.

4. Run the code:
   - Execute the code using the command `go run connect.go`.
   - Alternatively, you can build and run the executable:
     ```
     go build -o connect connect.go
     ./connect
     ```
5. Replace `app_id=1089` with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed
    private static readonly int pingInterval = 30000; // Ping every 30 seconds

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("WebSocket connection established.");

            // Send initial proposal subscription request
            await SendProposalSubscription(webSocket);

            // Start a task to send pings to keep connection alive
            Task keepAlivePingTask = KeepAlivePing(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);

            // Ensure the keep-alive ping task finishes
            await keepAlivePingTask;
        }
    }

    private static async Task SendProposalSubscription(ClientWebSocket webSocket)
    {
        var proposalRequest = new
        {
            proposal = 1,
            subscribe = 1,
            amount = 10,
            basis = "payout",
            contract_type = "CALL",
            currency = "USD",
            duration = 1,
            duration_unit = "m",
            symbol = "R_100",
            barrier = "+0.1"
        };

        string requestJson = JsonSerializer.Serialize(proposalRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("Proposal subscription sent.");
    }

    private static async Task KeepAlivePing(ClientWebSocket webSocket)
    {
        while (webSocket.State == WebSocketState.Open)
        {
            await Task.Delay(pingInterval);

            var pingRequest = new { ping = 1 };
            string pingJson = JsonSerializer.Serialize(pingRequest);
            var pingBytes = Encoding.UTF8.GetBytes(pingJson);
            await webSocket.SendAsync(new ArraySegment<byte>(pingBytes), WebSocketMessageType.Text, true, CancellationToken.None);
            Console.WriteLine("Ping sent to keep connection alive.");
        }
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[1024 * 4];

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        else
        {
            string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
            var data = JsonSerializer.Deserialize<JsonElement>(response);

            if (data.TryGetProperty("error", out var error))
            {
                Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                break;
            }

            if (data.TryGetProperty("msg_type", out var msgType))
            {
                if (msgType.GetString() == "proposal")
                {
                    var proposal = data.GetProperty("proposal");

                    // Extract proposal details with type-checking
                    string longcode = proposal.GetProperty("longcode").GetString();
                    Console.WriteLine($"Details: {longcode}");

                    string displayValue = proposal.GetProperty("display_value").GetRawText();
                    Console.WriteLine($"Ask Price: {displayValue}");

                    string payout = proposal.GetProperty("payout").GetRawText();
                    Console.WriteLine($"Payout: {payout}");

                    string spot = proposal.GetProperty("spot").GetRawText();
                    Console.WriteLine($"Spot: {spot}");
                }
                else if (msgType.GetString() == "ping")
                {
                    Console.WriteLine("[Ping] Ping response received.");
                }
            }
        }
    }
}
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed
    private static readonly int pingInterval = 30000; // Ping every 30 seconds

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("WebSocket connection established.");

            // Send initial proposal subscription request
            await SendProposalSubscription(webSocket);

            // Start a task to send pings to keep connection alive
            Task keepAlivePingTask = KeepAlivePing(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);

            // Ensure the keep-alive ping task finishes
            await keepAlivePingTask;
        }
    }

    private static async Task SendProposalSubscription(ClientWebSocket webSocket)
    {
        var proposalRequest = new
        {
            proposal = 1,
            subscribe = 1,
            amount = 10,
            basis = "payout",
            contract_type = "CALL",
            currency = "USD",
            duration = 1,
            duration_unit = "m",
            symbol = "R_100",
            barrier = "+0.1"
        };

        string requestJson = JsonSerializer.Serialize(proposalRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("Proposal subscription sent.");
    }

    private static async Task KeepAlivePing(ClientWebSocket webSocket)
    {
        while (webSocket.State == WebSocketState.Open)
        {
            await Task.Delay(pingInterval);

            var pingRequest = new { ping = 1 };
            string pingJson = JsonSerializer.Serialize(pingRequest);
            var pingBytes = Encoding.UTF8.GetBytes(pingJson);
            await webSocket.SendAsync(new ArraySegment<byte>(pingBytes), WebSocketMessageType.Text, true, CancellationToken.None);
            Console.WriteLine("Ping sent to keep connection alive.");
        }
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[1024 * 4];

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        else
        {
            string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
            var data = JsonSerializer.Deserialize<JsonElement>(response);

            if (data.TryGetProperty("error", out var error))
            {
                Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                break;
            }

            if (data.TryGetProperty("msg_type", out var msgType))
            {
                if (msgType.GetString() == "proposal")
                {
                    var proposal = data.GetProperty("proposal");

                    // Extract proposal details with type-checking
                    string longcode = proposal.GetProperty("longcode").GetString();
                    Console.WriteLine($"Details: {longcode}");

                    string displayValue = proposal.GetProperty("display_value").GetRawText();
                    Console.WriteLine($"Ask Price: {displayValue}");

                    string payout = proposal.GetProperty("payout").GetRawText();
                    Console.WriteLine($"Payout: {payout}");

                    string spot = proposal.GetProperty("spot").GetRawText();
                    Console.WriteLine($"Spot: {spot}");
                }
                else if (msgType.GetString() == "ping")
                {
                    Console.WriteLine("[Ping] Ping response received.");
                }
            }
        }
    }
}
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>
#include <time.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a proposal subscription message
void send_proposal(struct lws *wsi) {
    const char *proposal_msg = "{\"proposal\": 1, \"subscribe\": 1, \"amount\": 10, \"basis\": \"payout\", \"contract_type\": \"CALL\", \"currency\": \"USD\", \"duration\": 1, \"duration_unit\": \"m\", \"symbol\": \"R_100\", \"barrier\": \"+0.1\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], proposal_msg, strlen(proposal_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(proposal_msg), LWS_WRITE_TEXT);
    lwsl_user("Proposal subscription sent\n");
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_proposal(wsi);  // Send proposal on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>
#include <time.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a proposal subscription message
void send_proposal(struct lws *wsi) {
    const char *proposal_msg = "{\"proposal\": 1, \"subscribe\": 1, \"amount\": 10, \"basis\": \"payout\", \"contract_type\": \"CALL\", \"currency\": \"USD\", \"duration\": 1, \"duration_unit\": \"m\", \"symbol\": \"R_100\", \"barrier\": \"+0.1\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], proposal_msg, strlen(proposal_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(proposal_msg), LWS_WRITE_TEXT);
    lwsl_user("Proposal subscription sent\n");
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_proposal(wsi);  // Send proposal on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
import asyncio
from deriv_api import DerivAPI
from deriv_api.subscription_manager import SubscriptionManager

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    # Initialize the SubscriptionManager
    subscription_manager = SubscriptionManager(api)

    # Define the proposal request
    proposal_request = {
        "proposal": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    }

    # Subscribe to the proposal stream
    try:
        proposal_stream = await subscription_manager.subscribe(proposal_request)
        print("Subscribed to proposal stream")

        # Handle incoming messages and print formatted proposal details
        proposal_stream.subscribe(
            on_next=lambda message: print_proposal_details(message),
            on_error=lambda e: print(f"Error: {e}"),
            on_completed=lambda: print("Subscription completed")
        )

        # Function to send a ping every 30 seconds
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop and proposal subscription concurrently
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print proposal details
def print_proposal_details(message):
    data = message.get("proposal", {})
    if data:
        print(f"Details: {data.get('longcode', 'N/A')}")
        print(f"Ask Price: {data.get('display_value', 'N/A')}")
        print(f"Payout: {data.get('payout', 'N/A')}")
        print(f"Spot: {data.get('spot', 'N/A')}")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

"""
Instructions to run this code:

1. **Install the Required Library**:
   - Ensure that `python-deriv-api` is installed. If not, install it using:
     ```
     pip install python-deriv-api
     ```
2. **Save and Run the Code**:
   - Save this code to a file, e.g., `connect.py`.
   - Run the script using:
     ```
     python connect.py
     ```
3. **Configuration**:
   - Replace the `app_id` variable with your actual Deriv app ID if needed.

This script will connect to the Deriv API WebSocket, subscribe to a proposal stream, print proposal details, and send a ping every 30 seconds to keep the connection active. 
"""
```

```text
import asyncio
from deriv_api import DerivAPI
from deriv_api.subscription_manager import SubscriptionManager

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    # Initialize the SubscriptionManager
    subscription_manager = SubscriptionManager(api)

    # Define the proposal request
    proposal_request = {
        "proposal": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    }

    # Subscribe to the proposal stream
    try:
        proposal_stream = await subscription_manager.subscribe(proposal_request)
        print("Subscribed to proposal stream")

        # Handle incoming messages and print formatted proposal details
        proposal_stream.subscribe(
            on_next=lambda message: print_proposal_details(message),
            on_error=lambda e: print(f"Error: {e}"),
            on_completed=lambda: print("Subscription completed")
        )

        # Function to send a ping every 30 seconds
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop and proposal subscription concurrently
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print proposal details
def print_proposal_details(message):
    data = message.get("proposal", {})
    if data:
        print(f"Details: {data.get('longcode', 'N/A')}")
        print(f"Ask Price: {data.get('display_value', 'N/A')}")
        print(f"Payout: {data.get('payout', 'N/A')}")
        print(f"Spot: {data.get('spot', 'N/A')}")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

"""
Instructions to run this code:

1. **Install the Required Library**:
   - Ensure that `python-deriv-api` is installed. If not, install it using:
     ```
     pip install python-deriv-api
     ```
2. **Save and Run the Code**:
   - Save this code to a file, e.g., `connect.py`.
   - Run the script using:
     ```
     python connect.py
     ```
3. **Configuration**:
   - Replace the `app_id` variable with your actual Deriv app ID if needed.

This script will connect to the Deriv API WebSocket, subscribe to a proposal stream, print proposal details, and send a ping every 30 seconds to keep the connection active. 
"""
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Define a ping interval in seconds
my $ping_interval = 30;

# Function to send a proposal subscription request
sub send_proposal {
    my $connection = shift;
    my $proposal_request = encode_json({
        proposal       => 1,
        subscribe      => 1,
        amount         => 10,
        basis          => 'payout',
        contract_type  => 'CALL',
        currency       => 'USD',
        duration       => 1,
        duration_unit  => 'm',
        symbol         => 'R_100',
        barrier        => '+0.1'
    });
    $connection->send($proposal_request);
    say "Proposal subscription sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "WebSocket connection established.";

    # Set up a repeating timer to send ping every 30 seconds
    my $ping_timer = AnyEvent->timer(
        after    => $ping_interval,
        interval => $ping_interval,
        cb       => sub {
            $connection->send(encode_json({ ping => 1 }));
            say "Ping sent to keep connection alive.";
        }
    );

    # Send the initial proposal subscription
    send_proposal($connection);

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;
        my $data = decode_json($message->body);

        # Handle errors
        if ($data->{error}) {
            say "[Error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle proposal messages
        if ($data->{msg_type} && $data->{msg_type} eq 'proposal') {
            my $proposal = $data->{proposal};
            say "Details: $proposal->{longcode}";
            say "Ask Price: $proposal->{display_value}";
            say "Payout: $proposal->{payout}";
            say "Spot: $proposal->{spot}";
        } elsif ($data->{msg_type} && $data->{msg_type} eq 'ping') {
            say "[Ping] Ping response received.";
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
        $ping_timer = undef;  # Stop the ping timer
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Define a ping interval in seconds
my $ping_interval = 30;

# Function to send a proposal subscription request
sub send_proposal {
    my $connection = shift;
    my $proposal_request = encode_json({
        proposal       => 1,
        subscribe      => 1,
        amount         => 10,
        basis          => 'payout',
        contract_type  => 'CALL',
        currency       => 'USD',
        duration       => 1,
        duration_unit  => 'm',
        symbol         => 'R_100',
        barrier        => '+0.1'
    });
    $connection->send($proposal_request);
    say "Proposal subscription sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "WebSocket connection established.";

    # Set up a repeating timer to send ping every 30 seconds
    my $ping_timer = AnyEvent->timer(
        after    => $ping_interval,
        interval => $ping_interval,
        cb       => sub {
            $connection->send(encode_json({ ping => 1 }));
            say "Ping sent to keep connection alive.";
        }
    );

    # Send the initial proposal subscription
    send_proposal($connection);

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;
        my $data = decode_json($message->body);

        # Handle errors
        if ($data->{error}) {
            say "[Error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle proposal messages
        if ($data->{msg_type} && $data->{msg_type} eq 'proposal') {
            my $proposal = $data->{proposal};
            say "Details: $proposal->{longcode}";
            say "Ask Price: $proposal->{display_value}";
            say "Payout: $proposal->{payout}";
            say "Spot: $proposal->{spot}";
        } elsif ($data->{msg_type} && $data->{msg_type} eq 'ping') {
            say "[Ping] Ping response received.";
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
        $ping_timer = undef;  # Stop the ping timer
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

**Available Operations:**
- Import the Deriv API library
- Establish a WebSocket connection
- Create an API object
- Send a proposal subscription
- Send ping to keep the connection alive
- Handle WebSocket responses
- Start the signal processing
- End the WebSocket subscription

**Implementation Details:**
Follow these steps to maintain a live WebSocket connection with the Deriv API:

Import the Deriv API library

Import the DerivAPIBasic library, which provides an interface to interact with the Deriv WebSocket API:

import DerivAPIBasic from 'https://cdn.skypack.dev/@deriv/deriv-api/dist/DerivAPIBasic';

Establish a WebSocket connection

Create a WebSocket connection using your app_id and the API URL:

(wss://ws.derivws.com/websockets/v3?app_id=${app_id}).

This connection will be used to send and receive messages from the Deriv API.

const connection = new WebSocket(wss://ws.derivws.com/websockets/v3?app_id=${app_id});

Create an API object

Create an instance of DerivAPIBasic, passing the WebSocket connection as a parameter.

This object interacts with the API, such as subscribing to proposals and sending pings.

const api = new DerivAPIBasic({ connection });

Send a proposal subscription

The proposal() function subscribes to a proposal and sends details such as the trade amount, currency, contract type, duration, and asset symbol.

After this subscription, the API will send real-time updates about the proposal (market data).

JSON
const proposal = () => {  
  api.subscribe({  
 ...

---

### Get contracts for a symbol
**URL:** https://developers.deriv.com/docs/get-contracts-for-a-symbol

**Trading Examples:**
```text
DerivAPIBasic
```

```text
app_id
```

```text
DerivAPIBasic
```

```text
R_50
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the contracts for symbol response
const handleContractsForSymbolResponse = async (response) => {
  const data = JSON.parse(response.data);

  // Check for errors in the response
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'contracts_for', log the contracts information
  if (data.msg_type === 'contracts_for') {
    const contractsInfo = data.contracts_for;
    console.log('Contracts for Symbol:', contractsInfo);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleContractsForSymbolResponse);
};

// Function to request contracts for a specific symbol
const getContractsForSymbol = async () => {
  const contracts_for_symbol_request = {
    contracts_for: 'R_50',   // Specify the symbol
    currency: 'USD',
    landing_company: 'svg',
    product_type: 'basic',
  };

  connection.addEventListener('message', handleContractsForSymbolResponse); // Add event listener
  await api.contractsFor(contracts_for_symbol_request); // Send the contracts request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const contracts_for_symbol_button = document.querySelector('#contractsForSymbol');
  if (contracts_for_symbol_button) {
    contracts_for_symbol_button.addEventListener('click', getContractsForSymbol);
  }
} else {
  // If running in Node.js, directly call the function
  getContractsForSymbol();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `contracts_for_symbol.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node contracts_for_symbol.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="contractsForSymbol">Get Contracts for Symbol</button>`
 * - Open the HTML file in a browser, and click the button to retrieve contracts for the symbol.
 */
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the contracts for symbol response
const handleContractsForSymbolResponse = async (response) => {
  const data = JSON.parse(response.data);

  // Check for errors in the response
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'contracts_for', log the contracts information
  if (data.msg_type === 'contracts_for') {
    const contractsInfo = data.contracts_for;
    console.log('Contracts for Symbol:', contractsInfo);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleContractsForSymbolResponse);
};

// Function to request contracts for a specific symbol
const getContractsForSymbol = async () => {
  const contracts_for_symbol_request = {
    contracts_for: 'R_50',   // Specify the symbol
    currency: 'USD',
    landing_company: 'svg',
    product_type: 'basic',
  };

  connection.addEventListener('message', handleContractsForSymbolResponse); // Add event listener
  await api.contractsFor(contracts_for_symbol_request); // Send the contracts request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const contracts_for_symbol_button = document.querySelector('#contractsForSymbol');
  if (contracts_for_symbol_button) {
    contracts_for_symbol_button.addEventListener('click', getContractsForSymbol);
  }
} else {
  // If running in Node.js, directly call the function
  getContractsForSymbol();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `contracts_for_symbol.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node contracts_for_symbol.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="contractsForSymbol">Get Contracts for Symbol</button>`
 * - Open the HTML file in a browser, and click the button to retrieve contracts for the symbol.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send contracts for symbol request
                    JsonObject contractsForSymbolRequest = new JsonObject();
                    contractsForSymbolRequest.addProperty("contracts_for", "R_50"); // Specify symbol here
                    contractsForSymbolRequest.addProperty("currency", "USD");
                    contractsForSymbolRequest.addProperty("landing_company", "svg");
                    contractsForSymbolRequest.addProperty("product_type", "basic");
                    send(contractsForSymbolRequest.toString());
                    System.out.println("[sent] Contracts for symbol request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("contracts_for".equals(data.get("msg_type").getAsString())) {
                        JsonObject contractsFor = data.getAsJsonObject("contracts_for");
                        System.out.println("Contracts for Symbol: " + contractsFor);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send contracts for symbol request
                    JsonObject contractsForSymbolRequest = new JsonObject();
                    contractsForSymbolRequest.addProperty("contracts_for", "R_50"); // Specify symbol here
                    contractsForSymbolRequest.addProperty("currency", "USD");
                    contractsForSymbolRequest.addProperty("landing_company", "svg");
                    contractsForSymbolRequest.addProperty("product_type", "basic");
                    send(contractsForSymbolRequest.toString());
                    System.out.println("[sent] Contracts for symbol request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("contracts_for".equals(data.get("msg_type").getAsString())) {
                        JsonObject contractsFor = data.getAsJsonObject("contracts_for");
                        System.out.println("Contracts for Symbol: " + contractsFor);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.
 */
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a contracts for symbol request
sub send_contracts_for_symbol {
    my $connection = shift;
    my $contracts_for_request = encode_json({
        contracts_for => 'R_50',    # Symbol for which contracts are requested
        currency => 'USD',          # Set currency to USD
        landing_company => 'svg',   # Landing company (e.g., svg)
        product_type => 'basic'     # Product type is set to 'basic'
    });
    $connection->send($contracts_for_request);
    say "[request] Contracts for symbol request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send the contracts for symbol request
    send_contracts_for_symbol($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Process contracts_for response
        if ($data->{msg_type} && $data->{msg_type} eq 'contracts_for') {
            say "[contracts] Contracts for Symbol (R_50):";
            foreach my $contract (@{$data->{contracts_for}{available}}) {
                my $contract_type            = $contract->{contract_type} // "N/A";
                my $contract_display         = $contract->{contract_display} // "N/A";
                my $contract_category_display = $contract->{contract_category_display} // "N/A";
                my $market                   = $contract->{market} // "N/A";
                my $submarket                = $contract->{submarket} // "N/A";
                my $expiry_type              = $contract->{expiry_type} // "N/A";
                my $min_duration             = $contract->{min_contract_duration} // "N/A";
                my $max_duration             = $contract->{max_contract_duration} // "N/A";
                my $barrier                  = $contract->{barrier} // "N/A";
                my $sentiment                = $contract->{sentiment} // "N/A";

                # Print contract details
                say "  - Contract Type: $contract_type";
                say "    - Display Name: $contract_display";
                say "    - Category: $contract_category_display";
                say "    - Market: $market";
                say "    - Submarket: $submarket";
                say "    - Expiry Type: $expiry_type";
                say "    - Min Duration: $min_duration";
                say "    - Max Duration: $max_duration";
                say "    - Barrier: $barrier";
                say "    - Sentiment: $sentiment";
                say "    --------------------";
            }
            say "[contracts] End of Contracts Response.";
            $connection->close;  # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `contracts_for_symbol.pl`.
# 4. Run the script using the command:
#      perl contracts_for_symbol.pl
# This script will connect to the Deriv WebSocket API, request contracts for a specific symbol, and print the details.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a contracts for symbol request
sub send_contracts_for_symbol {
    my $connection = shift;
    my $contracts_for_request = encode_json({
        contracts_for => 'R_50',    # Symbol for which contracts are requested
        currency => 'USD',          # Set currency to USD
        landing_company => 'svg',   # Landing company (e.g., svg)
        product_type => 'basic'     # Product type is set to 'basic'
    });
    $connection->send($contracts_for_request);
    say "[request] Contracts for symbol request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send the contracts for symbol request
    send_contracts_for_symbol($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Process contracts_for response
        if ($data->{msg_type} && $data->{msg_type} eq 'contracts_for') {
            say "[contracts] Contracts for Symbol (R_50):";
            foreach my $contract (@{$data->{contracts_for}{available}}) {
                my $contract_type            = $contract->{contract_type} // "N/A";
                my $contract_display         = $contract->{contract_display} // "N/A";
                my $contract_category_display = $contract->{contract_category_display} // "N/A";
                my $market                   = $contract->{market} // "N/A";
                my $submarket                = $contract->{submarket} // "N/A";
                my $expiry_type              = $contract->{expiry_type} // "N/A";
                my $min_duration             = $contract->{min_contract_duration} // "N/A";
                my $max_duration             = $contract->{max_contract_duration} // "N/A";
                my $barrier                  = $contract->{barrier} // "N/A";
                my $sentiment                = $contract->{sentiment} // "N/A";

                # Print contract details
                say "  - Contract Type: $contract_type";
                say "    - Display Name: $contract_display";
                say "    - Category: $contract_category_display";
                say "    - Market: $market";
                say "    - Submarket: $submarket";
                say "    - Expiry Type: $expiry_type";
                say "    - Min Duration: $min_duration";
                say "    - Max Duration: $max_duration";
                say "    - Barrier: $barrier";
                say "    - Sentiment: $sentiment";
                say "    --------------------";
            }
            say "[contracts] End of Contracts Response.";
            $connection->close;  # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `contracts_for_symbol.pl`.
# 4. Run the script using the command:
#      perl contracts_for_symbol.pl
# This script will connect to the Deriv WebSocket API, request contracts for a specific symbol, and print the details.
```

```text
<?php
// Include necessary libraries (you may need to install Ratchet via Composer)
require 'vendor/autoload.php';

use Ratchet\Client\WebSocket;
use Ratchet\Client\Connector;
use React\EventLoop\Factory as LoopFactory;
use React\Socket\Connector as ReactConnector;

// Define the app_id (replace 'your_app_id' with your actual app_id)
$app_id = 'your_app_id';

// Create an event loop to handle WebSocket events
$loop = LoopFactory::create();
$reactConnector = new ReactConnector($loop);
$connector = new Connector($loop, $reactConnector);

// Define the request object for contracts_for API call
$contracts_for_symbol_request = [
    'contracts_for'   => 'R_50',  // Symbol for which contracts are requested
    'currency'        => 'USD',   // Set currency to USD
    'landing_company' => 'svg',   // Landing company
    'product_type'    => 'basic', // Product type is set to 'basic'
];

// Connect to the Deriv WebSocket API
$connector("wss://ws.derivws.com/websockets/v3?app_id=$app_id")
    ->then(function(WebSocket $conn) use ($contracts_for_symbol_request, $loop) {
        // Send the contracts_for request to the WebSocket server
        $conn->send(json_encode($contracts_for_symbol_request));
        echo "Request sent: " . json_encode($contracts_for_symbol_request) . PHP_EOL;

        // Handle messages received from the server
        $conn->on('message', function($message) use ($conn, $loop) {
            // Decode the received message (JSON format)
            $data = json_decode($message, true);

            // Check if there is an error in the response
            if (isset($data['error'])) {
                echo "Error: " . $data['error']['message'] . PHP_EOL;
                $conn->close();
                $loop->stop(); // Stop the event loop
            }

            // If the response is for 'contracts_for', print the contract information
            if (isset($data['msg_type']) && $data['msg_type'] === 'contracts_for') {
                echo "Contracts for symbol: " . json_encode($data['contracts_for'], JSON_PRETTY_PRINT) . PHP_EOL;
                $conn->close(); // Close the WebSocket connection
                $loop->stop();  // Stop the event loop
            }
        });

        // Handle WebSocket connection closing
        $conn->on('close', function($code = null, $reason = null) use ($loop) {
            echo "Connection closed ({$code} - {$reason})" . PHP_EOL;
            $loop->stop(); // Stop the event loop when the connection is closed
        });
    }, function($e) use ($loop) {
        // Handle connection errors
        echo "Could not connect: {$e->getMessage()}" . PHP_EOL;
        $loop->stop();
    });

// Run the event loop to keep the connection alive
$loop->run();
```

```text
<?php
// Include necessary libraries (you may need to install Ratchet via Composer)
require 'vendor/autoload.php';

use Ratchet\Client\WebSocket;
use Ratchet\Client\Connector;
use React\EventLoop\Factory as LoopFactory;
use React\Socket\Connector as ReactConnector;

// Define the app_id (replace 'your_app_id' with your actual app_id)
$app_id = 'your_app_id';

// Create an event loop to handle WebSocket events
$loop = LoopFactory::create();
$reactConnector = new ReactConnector($loop);
$connector = new Connector($loop, $reactConnector);

// Define the request object for contracts_for API call
$contracts_for_symbol_request = [
    'contracts_for'   => 'R_50',  // Symbol for which contracts are requested
    'currency'        => 'USD',   // Set currency to USD
    'landing_company' => 'svg',   // Landing company
    'product_type'    => 'basic', // Product type is set to 'basic'
];

// Connect to the Deriv WebSocket API
$connector("wss://ws.derivws.com/websockets/v3?app_id=$app_id")
    ->then(function(WebSocket $conn) use ($contracts_for_symbol_request, $loop) {
        // Send the contracts_for request to the WebSocket server
        $conn->send(json_encode($contracts_for_symbol_request));
        echo "Request sent: " . json_encode($contracts_for_symbol_request) . PHP_EOL;

        // Handle messages received from the server
        $conn->on('message', function($message) use ($conn, $loop) {
            // Decode the received message (JSON format)
            $data = json_decode($message, true);

            // Check if there is an error in the response
            if (isset($data['error'])) {
                echo "Error: " . $data['error']['message'] . PHP_EOL;
                $conn->close();
                $loop->stop(); // Stop the event loop
            }

            // If the response is for 'contracts_for', print the contract information
            if (isset($data['msg_type']) && $data['msg_type'] === 'contracts_for') {
                echo "Contracts for symbol: " . json_encode($data['contracts_for'], JSON_PRETTY_PRINT) . PHP_EOL;
                $conn->close(); // Close the WebSocket connection
                $loop->stop();  // Stop the event loop
            }
        });

        // Handle WebSocket connection closing
        $conn->on('close', function($code = null, $reason = null) use ($loop) {
            echo "Connection closed ({$code} - {$reason})" . PHP_EOL;
            $loop->stop(); // Stop the event loop when the connection is closed
        });
    }, function($e) use ($loop) {
        // Handle connection errors
        echo "Could not connect: {$e->getMessage()}" . PHP_EOL;
        $loop->stop();
    });

// Run the event loop to keep the connection alive
$loop->run();
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a contracts for symbol request
        contracts_for_symbol_request = {
            "contracts_for": "R_50",
            "currency": "USD",
            "landing_company": "svg",
            "product_type": "basic"
        }
        response = await api.send(contracts_for_symbol_request)
        print("Contracts for symbol request sent")

        # Process the response and print contract details
        print_contracts_for_symbol(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print contract details for a symbol
def print_contracts_for_symbol(response):
    data = response.get("contracts_for", {})
    if data:
        print("Contracts for Symbol (R_50):")
        contracts = data.get("available", [])
        for contract in contracts:
            print(f"  - Contract Type: {contract.get('contract_type')}")
            print(f"    - Display Name: {contract.get('contract_display')}")
            print(f"    - Category: {contract.get('contract_category_display')}")
            print(f"    - Market: {contract.get('market')}")
            print(f"    - Submarket: {contract.get('submarket')}")
            print(f"    - Expiry Type: {contract.get('expiry_type')}")
            print(f"    - Min Duration: {contract.get('min_contract_duration')}")
            print(f"    - Max Duration: {contract.get('max_contract_duration')}")
            print(f"    - Barrier: {contract.get('barrier')}")
            print(f"    - Sentiment: {contract.get('sentiment')}")
            print("    --------------------")
    print("[End of Contracts for Symbol Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `contracts_for_symbol_client.py`.
# 4. Run the code from the command line:
#      python contracts_for_symbol_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request contract details for the symbol "R_50", and send pings every 30 seconds to keep the connection alive.
# The response includes important contract details such as contract type, category, market, durations, and barriers.
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a contracts for symbol request
        contracts_for_symbol_request = {
            "contracts_for": "R_50",
            "currency": "USD",
            "landing_company": "svg",
            "product_type": "basic"
        }
        response = await api.send(contracts_for_symbol_request)
        print("Contracts for symbol request sent")

        # Process the response and print contract details
        print_contracts_for_symbol(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print contract details for a symbol
def print_contracts_for_symbol(response):
    data = response.get("contracts_for", {})
    if data:
        print("Contracts for Symbol (R_50):")
        contracts = data.get("available", [])
        for contract in contracts:
            print(f"  - Contract Type: {contract.get('contract_type')}")
            print(f"    - Display Name: {contract.get('contract_display')}")
            print(f"    - Category: {contract.get('contract_category_display')}")
            print(f"    - Market: {contract.get('market')}")
            print(f"    - Submarket: {contract.get('submarket')}")
            print(f"    - Expiry Type: {contract.get('expiry_type')}")
            print(f"    - Min Duration: {contract.get('min_contract_duration')}")
            print(f"    - Max Duration: {contract.get('max_contract_duration')}")
            print(f"    - Barrier: {contract.get('barrier')}")
            print(f"    - Sentiment: {contract.get('sentiment')}")
            print("    --------------------")
    print("[End of Contracts for Symbol Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `contracts_for_symbol_client.py`.
# 4. Run the code from the command line:
#      python contracts_for_symbol_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request contract details for the symbol "R_50", and send pings every 30 seconds to keep the connection alive.
# The response includes important contract details such as contract type, category, market, durations, and barriers.
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Contracts for symbol request JSON
    let contracts_for_symbol_request = json!({
        "contracts_for": "R_50",
        "currency": "USD",
        "landing_company": "svg",
        "product_type": "basic"
    });

    // Clone `socket` to send the contracts for symbol request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(contracts_for_symbol_request.to_string())).await.is_ok() {
            println!("[request] Contracts for symbol request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "contracts_for" {
                        println!("Contracts for Symbol (R_50):");
                        if let Some(contracts) = data["contracts_for"]["available"].as_array() {
                            for contract in contracts {
                                println!("  - Contract Type: {}", contract["contract_type"]);
                                println!("    - Display Name: {}", contract["contract_display"]);
                                println!("    - Category: {}", contract["contract_category_display"]);
                                println!("    - Market: {}", contract["market"]);
                                println!("    - Submarket: {}", contract["submarket"]);
                                println!("    - Expiry Type: {}", contract["expiry_type"]);
                                println!("    - Min Duration: {}", contract["min_contract_duration"]);
                                println!("    - Max Duration: {}", contract["max_contract_duration"]);
                                println!("    - Barrier: {}", contract["barrier"]);
                                println!("    - Sentiment: {}", contract["sentiment"]);
                                println!("    --------------------");
                            }
                        }
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request contract details for the symbol "R_50", and print out important contract details such as type, category, market, submarket, expiry type, duration, and barrier information.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Contracts for symbol request JSON
    let contracts_for_symbol_request = json!({
        "contracts_for": "R_50",
        "currency": "USD",
        "landing_company": "svg",
        "product_type": "basic"
    });

    // Clone `socket` to send the contracts for symbol request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(contracts_for_symbol_request.to_string())).await.is_ok() {
            println!("[request] Contracts for symbol request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "contracts_for" {
                        println!("Contracts for Symbol (R_50):");
                        if let Some(contracts) = data["contracts_for"]["available"].as_array() {
                            for contract in contracts {
                                println!("  - Contract Type: {}", contract["contract_type"]);
                                println!("    - Display Name: {}", contract["contract_display"]);
                                println!("    - Category: {}", contract["contract_category_display"]);
                                println!("    - Market: {}", contract["market"]);
                                println!("    - Submarket: {}", contract["submarket"]);
                                println!("    - Expiry Type: {}", contract["expiry_type"]);
                                println!("    - Min Duration: {}", contract["min_contract_duration"]);
                                println!("    - Max Duration: {}", contract["max_contract_duration"]);
                                println!("    - Barrier: {}", contract["barrier"]);
                                println!("    - Sentiment: {}", contract["sentiment"]);
                                println!("    --------------------");
                            }
                        }
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request contract details for the symbol "R_50", and print out important contract details such as type, category, market, submarket, expiry type, duration, and barrier information.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a contracts for symbol request
void send_contracts_for_symbol_request(struct lws *wsi) {
    const char *contracts_for_symbol_msg = "{\"contracts_for\": \"R_50\", \"currency\": \"USD\", \"landing_company\": \"svg\", \"product_type\": \"basic\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], contracts_for_symbol_msg, strlen(contracts_for_symbol_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(contracts_for_symbol_msg), LWS_WRITE_TEXT);
    lwsl_user("Contracts for symbol request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_contracts_for_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "contracts_for"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "contracts_for") == 0) {
        json_t *contracts_for = json_object_get(root, "contracts_for");
        json_t *available_contracts = json_object_get(contracts_for, "available");

        printf("Contracts for Symbol (R_50):\n");
        size_t index;
        json_t *contract;
        json_array_foreach(available_contracts, index, contract) {
            const char *contract_type = json_string_value(json_object_get(contract, "contract_type"));
            const char *display_name = json_string_value(json_object_get(contract, "contract_display"));
            const char *category = json_string_value(json_object_get(contract, "contract_category_display"));
            const char *market = json_string_value(json_object_get(contract, "market"));
            const char *submarket = json_string_value(json_object_get(contract, "submarket"));
            const char *expiry_type = json_string_value(json_object_get(contract, "expiry_type"));
            const char *min_duration = json_string_value(json_object_get(contract, "min_contract_duration"));
            const char *max_duration = json_string_value(json_object_get(contract, "max_contract_duration"));

            printf("  - Contract Type: %s\n", contract_type);
            printf("    - Display Name: %s\n", display_name);
            printf("    - Category: %s\n", category);
            printf("    - Market: %s\n", market);
            printf("    - Submarket: %s\n", submarket);
            printf("    - Expiry Type: %s\n", expiry_type);
            printf("    - Min Duration: %s\n", min_duration);
            printf("    - Max Duration: %s\n", max_duration);
            printf("    --------------------\n");
        }
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_contracts_for_symbol_request(wsi);  // Send contracts for symbol request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_contracts_for_symbol_request(wsi);  // Periodically request contracts
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_contracts_for_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a contracts for symbol request
void send_contracts_for_symbol_request(struct lws *wsi) {
    const char *contracts_for_symbol_msg = "{\"contracts_for\": \"R_50\", \"currency\": \"USD\", \"landing_company\": \"svg\", \"product_type\": \"basic\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], contracts_for_symbol_msg, strlen(contracts_for_symbol_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(contracts_for_symbol_msg), LWS_WRITE_TEXT);
    lwsl_user("Contracts for symbol request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_contracts_for_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "contracts_for"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "contracts_for") == 0) {
        json_t *contracts_for = json_object_get(root, "contracts_for");
        json_t *available_contracts = json_object_get(contracts_for, "available");

        printf("Contracts for Symbol (R_50):\n");
        size_t index;
        json_t *contract;
        json_array_foreach(available_contracts, index, contract) {
            const char *contract_type = json_string_value(json_object_get(contract, "contract_type"));
            const char *display_name = json_string_value(json_object_get(contract, "contract_display"));
            const char *category = json_string_value(json_object_get(contract, "contract_category_display"));
            const char *market = json_string_value(json_object_get(contract, "market"));
            const char *submarket = json_string_value(json_object_get(contract, "submarket"));
            const char *expiry_type = json_string_value(json_object_get(contract, "expiry_type"));
            const char *min_duration = json_string_value(json_object_get(contract, "min_contract_duration"));
            const char *max_duration = json_string_value(json_object_get(contract, "max_contract_duration"));

            printf("  - Contract Type: %s\n", contract_type);
            printf("    - Display Name: %s\n", display_name);
            printf("    - Category: %s\n", category);
            printf("    - Market: %s\n", market);
            printf("    - Submarket: %s\n", submarket);
            printf("    - Expiry Type: %s\n", expiry_type);
            printf("    - Min Duration: %s\n", min_duration);
            printf("    - Max Duration: %s\n", max_duration);
            printf("    --------------------\n");
        }
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_contracts_for_symbol_request(wsi);  // Send contracts for symbol request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_contracts_for_symbol_request(wsi);  // Periodically request contracts
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_contracts_for_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send contracts for symbol request
            await SendContractsForSymbolRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendContractsForSymbolRequest(ClientWebSocket webSocket)
    {
        var contractsForSymbolRequest = new
        {
            contracts_for = "R_50",
            currency = "USD",
            landing_company = "svg",
            product_type = "basic"
        };

        string requestJson = JsonSerializer.Serialize(contractsForSymbolRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[request] Contracts for symbol request sent.");
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[8192];
    var messageBuilder = new StringBuilder();

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            break;
        }

        messageBuilder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));

        if (result.EndOfMessage)
        {
            try
            {
                var data = JsonDocument.Parse(messageBuilder.ToString()).RootElement;
                if (data.TryGetProperty("error", out var error))
                {
                    Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                    break;
                }

                if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "contracts_for")
                {
                    Console.WriteLine("Contracts for Symbol (R_50):");
                    foreach (var contract in data.GetProperty("contracts_for").GetProperty("available").EnumerateArray())
                    {
                        Console.WriteLine($"  - Contract Type: {contract.GetProperty("contract_type").GetString()}");
                        Console.WriteLine($"    - Display Name: {contract.GetProperty("contract_display").GetString()}");
                        Console.WriteLine($"    - Category: {contract.GetProperty("contract_category_display").GetString()}");
                        Console.WriteLine($"    - Market: {contract.GetProperty("market").GetString()}");
                        Console.WriteLine($"    - Submarket: {contract.GetProperty("submarket").GetString()}");
                        Console.WriteLine($"    - Expiry Type: {contract.GetProperty("expiry_type").GetString()}");

                        // Check for optional properties with safe access
                        Console.WriteLine($"    - Min Duration: {(contract.TryGetProperty("min_contract_duration", out var minDuration) ? minDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Max Duration: {(contract.TryGetProperty("max_contract_duration", out var maxDuration) ? maxDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Barrier: {(contract.TryGetProperty("barrier", out var barrier) ? barrier.GetString() : "N/A")}");
                        Console.WriteLine($"    - Sentiment: {(contract.TryGetProperty("sentiment", out var sentiment) ? sentiment.GetString() : "N/A")}");
                        Console.WriteLine("    --------------------");
                    }
                }

                messageBuilder.Clear();
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"[Error] Failed to parse JSON message: {ex.Message}");
            }
        }
    }
}


}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send contracts for symbol request
            await SendContractsForSymbolRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendContractsForSymbolRequest(ClientWebSocket webSocket)
    {
        var contractsForSymbolRequest = new
        {
            contracts_for = "R_50",
            currency = "USD",
            landing_company = "svg",
            product_type = "basic"
        };

        string requestJson = JsonSerializer.Serialize(contractsForSymbolRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[request] Contracts for symbol request sent.");
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[8192];
    var messageBuilder = new StringBuilder();

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            break;
        }

        messageBuilder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));

        if (result.EndOfMessage)
        {
            try
            {
                var data = JsonDocument.Parse(messageBuilder.ToString()).RootElement;
                if (data.TryGetProperty("error", out var error))
                {
                    Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                    break;
                }

                if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "contracts_for")
                {
                    Console.WriteLine("Contracts for Symbol (R_50):");
                    foreach (var contract in data.GetProperty("contracts_for").GetProperty("available").EnumerateArray())
                    {
                        Console.WriteLine($"  - Contract Type: {contract.GetProperty("contract_type").GetString()}");
                        Console.WriteLine($"    - Display Name: {contract.GetProperty("contract_display").GetString()}");
                        Console.WriteLine($"    - Category: {contract.GetProperty("contract_category_display").GetString()}");
                        Console.WriteLine($"    - Market: {contract.GetProperty("market").GetString()}");
                        Console.WriteLine($"    - Submarket: {contract.GetProperty("submarket").GetString()}");
                        Console.WriteLine($"    - Expiry Type: {contract.GetProperty("expiry_type").GetString()}");

                        // Check for optional properties with safe access
                        Console.WriteLine($"    - Min Duration: {(contract.TryGetProperty("min_contract_duration", out var minDuration) ? minDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Max Duration: {(contract.TryGetProperty("max_contract_duration", out var maxDuration) ? maxDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Barrier: {(contract.TryGetProperty("barrier", out var barrier) ? barrier.GetString() : "N/A")}");
                        Console.WriteLine($"    - Sentiment: {(contract.TryGetProperty("sentiment", out var sentiment) ? sentiment.GetString() : "N/A")}");
                        Console.WriteLine("    --------------------");
                    }
                }

                messageBuilder.Clear();
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"[Error] Failed to parse JSON message: {ex.Message}");
            }
        }
    }
}


}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//replace with your app_id
	readLimit    = 65536 // Set a higher read limit, e.g., 64 KB
)

type ContractsForRequest struct {
	ContractsFor   string `json:"contracts_for"`
	Currency       string `json:"currency"`
	LandingCompany string `json:"landing_company"`
	ProductType    string `json:"product_type"`
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("[status] WebSocket connection established.")

	// Set a higher read limit
	conn.SetReadLimit(readLimit)

	// Send contracts for symbol request
	err = sendContractsForSymbolRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send contracts for symbol request: %v", err)
	}

	// Handle incoming messages
	handleResponses(ctx, conn)
}

func sendContractsForSymbolRequest(ctx context.Context, conn *websocket.Conn) error {
	contractsRequest := ContractsForRequest{
		ContractsFor:   "R_50",
		Currency:       "USD",
		LandingCompany: "svg",
		ProductType:    "basic",
	}
	fmt.Println("[request] Sending contracts for symbol request...")
	return wsjson.Write(ctx, conn, contractsRequest)
}

func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}

		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		msgType := response["msg_type"]
		if msgType == "contracts_for" {
			contracts := response["contracts_for"].(map[string]interface{})["available"].([]interface{})
			fmt.Println("Contracts for Symbol (R_50):")
			for _, contract := range contracts {
				contractMap := contract.(map[string]interface{})
				fmt.Printf("  - Contract Type: %v\n", contractMap["contract_type"])
				fmt.Printf("    - Display Name: %v\n", contractMap["contract_display"])
				fmt.Printf("    - Category: %v\n", contractMap["contract_category_display"])
				fmt.Printf("    - Market: %v\n", contractMap["market"])
				fmt.Printf("    - Submarket: %v\n", contractMap["submarket"])
				fmt.Printf("    - Expiry Type: %v\n", contractMap["expiry_type"])
				fmt.Printf("    - Min Duration: %v\n", contractMap["min_contract_duration"])
				fmt.Printf("    - Max Duration: %v\n", contractMap["max_contract_duration"])
				fmt.Printf("    - Barrier: %v\n", contractMap["barrier"])
				fmt.Printf("    - Sentiment: %v\n", contractMap["sentiment"])
				fmt.Println("    --------------------")
			}
		} else {
			fmt.Printf("Received message: %v\n", response)
		}
	}
}
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//replace with your app_id
	readLimit    = 65536 // Set a higher read limit, e.g., 64 KB
)

type ContractsForRequest struct {
	ContractsFor   string `json:"contracts_for"`
	Currency       string `json:"currency"`
	LandingCompany string `json:"landing_company"`
	ProductType    string `json:"product_type"`
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("[status] WebSocket connection established.")

	// Set a higher read limit
	conn.SetReadLimit(readLimit)

	// Send contracts for symbol request
	err = sendContractsForSymbolRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send contracts for symbol request: %v", err)
	}

	// Handle incoming messages
	handleResponses(ctx, conn)
}

func sendContractsForSymbolRequest(ctx context.Context, conn *websocket.Conn) error {
	contractsRequest := ContractsForRequest{
		ContractsFor:   "R_50",
		Currency:       "USD",
		LandingCompany: "svg",
		ProductType:    "basic",
	}
	fmt.Println("[request] Sending contracts for symbol request...")
	return wsjson.Write(ctx, conn, contractsRequest)
}

func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}

		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		msgType := response["msg_type"]
		if msgType == "contracts_for" {
			contracts := response["contracts_for"].(map[string]interface{})["available"].([]interface{})
			fmt.Println("Contracts for Symbol (R_50):")
			for _, contract := range contracts {
				contractMap := contract.(map[string]interface{})
				fmt.Printf("  - Contract Type: %v\n", contractMap["contract_type"])
				fmt.Printf("    - Display Name: %v\n", contractMap["contract_display"])
				fmt.Printf("    - Category: %v\n", contractMap["contract_category_display"])
				fmt.Printf("    - Market: %v\n", contractMap["market"])
				fmt.Printf("    - Submarket: %v\n", contractMap["submarket"])
				fmt.Printf("    - Expiry Type: %v\n", contractMap["expiry_type"])
				fmt.Printf("    - Min Duration: %v\n", contractMap["min_contract_duration"])
				fmt.Printf("    - Max Duration: %v\n", contractMap["max_contract_duration"])
				fmt.Printf("    - Barrier: %v\n", contractMap["barrier"])
				fmt.Printf("    - Sentiment: %v\n", contractMap["sentiment"])
				fmt.Println("    --------------------")
			}
		} else {
			fmt.Printf("Received message: %v\n", response)
		}
	}
}
```

**Implementation Details:**
Follow these steps to retrieve the list of available contracts, along with the latest barrier and duration limits for each contract, for a given symbol using the Deriv API:

Import Deriv API: Import the DerivAPIBasic library from Skypack CDN.
WebSocket connection: Create a WebSocket connection to the Deriv API using your app_id.
API initialization: Initialize the DerivAPIBasic instance with the WebSocket connection.
Request object: Define a request object to fetch contracts for a specific symbol (e.g., R_50).
Response handling: Handle the API response:
Parse the data and log any errors.
If the response contains contract data, log it.
Remove the event listener after the response is received.
Trigger request: On a button click, the function sends the request to the API to get the contracts for the symbol.
JavaScript
Java
Perl
PHP
Python
Rust
Swift
C
C#
Go
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
cons...

---

## üìä 4. MARKET DATA & SYMBOLS

### Getting started with Deriv APIs
**URL:** https://developers.deriv.com/docs/getting-started

**Content:**
Quick start

This guide will help you seamlessly integrate our API into your applications, providing access to real-time market data, trading functionalities, account information, and more. The possibilities are limitless.

While Deriv‚Äôs API is powerful and flexible, using it effectively does require some programming knowledge.

It‚Äôs important to note that Deriv does not provide a programmer. You‚Äôll need to work with a trusted
developer on your own or handle the development yourself if you have programming expertise.

However, everything you need to build a manual or automated trading platform is available through the Deriv API.

Updated 3 months ago

Did this page help you?
Yes
No...

---

### Account setup
**URL:** https://developers.deriv.com/docs/account-setup

**Data Fetching Examples:**
```text
buy
```

```text
proposal
```

```text
buy
```

```text
proposal
```

```text
https://example.com
```

```text
/verify
```

```text
https://example.com/verify
```

**Content:**
Create a Deriv account
Visit api.deriv.com
Click Sign Up on the top right corner of the page.
Provide your Email Address.
Check your inbox for a verification email and click the link to confirm your account.
After verifying your email, provide your Country of residence, Citizenship, and create a Password.
Your Demo account is now active ‚Äî you can start building and testing your apps right away.
To create a Real account, click Complete my profile.
Choose your Account Currency, fill in your Personal and Address details, and accept the Terms of use to proceed.
Your Real account is now active ‚Äî you‚Äôre eligible to earn markup commissions on your app.
üìò

Note:

If your country of residence is one of the supported countries for Wallets, you will also receive a virtual Wallet (demo) account. Once you complete the real account creation process, a real Wallet account will also be created, based on the currency you select.

Attention Developers ‚Äì Wallet Accounts Can‚Äôt Trade!
If your account type...

---

### Market Data APIs
**URL:** https://developers.deriv.com/docs/market-data-apis

**Content:**
Market Data APIs provide access to real-time market data and pricing information on Deriv.

They offer functionalities for retrieving active trading symbols, exchange rates, contract details, and price proposals. Additionally, these APIs enable real-time streaming of spot prices and access to historical tick data, helping users make informed trading decisions.

These APIs are crucial for accessing accurate and up-to-date market data, ensuring users can trade efficiently on the Deriv trading platforms.

#	API Name	Description	Send	Subscribe	Scope
1	Active Symbols	Retrieves a list of all currently active symbols (underlying markets available for trading).	‚úî	‚úò	NA
2	Asset Index	Retrieves a list of available underlyings along with their corresponding contract types and duration limits. For logged-in users, only assets available under their landing company will be returned.	‚úî	‚úò	NA
3	Exchange Rates	Retrieves the exchange rate between a base currency and a target currency supported by the syst...

---

### Utilities APIs
**URL:** https://developers.deriv.com/docs/utilities-apis

**Content:**
Utilities APIs provide essential information and utility functions for the platform‚Äôs operations. They offer functionalities for retrieving economic calendar events, managing real-time message streams, and accessing details about landing companies and server statuses.

Additionally, these APIs include utility features like server time, ping requests, and country/state lists for account management.

These APIs ensure smooth platform operations and deliver up-to-date trading and account management information.

#	API Name	Description	Send	Subscribe	Scope
1	Economic Calendar	Retrieve a list of economic events for a specific currency. If no currency is specified, the list includes all currencies.	‚úî	‚úò	NA
2	Forget	Immediately cancels the real-time stream of messages with a specific ID.	‚úî	‚úò	NA
3	Forget All	Immediately cancels all real-time streams of messages of a given type.	‚úî	‚úò	NA
4	Landing Company	Retrieve the appropriate landing company based on the client‚Äôs country. Different landing com...

---

### Mark-up
**URL:** https://developers.deriv.com/docs/mark-up

**Content:**
If you build a platform or app that allows users to trade manually or via automation using Deriv APIs, you can earn up to 3% markup commission on every contract your users execute.

Example:

Let‚Äôs say a user places a $10 stake, and the potential payout without any markup is $17.20 if the trade wins.

If you set a 2% markup, your commission will be calculated on the potential payout: 2% of $17.20 = $0.34

With this adjusted stake, the user‚Äôs new potential payout becomes: $16.63

üöß

‚ö†Ô∏è Markup impacts the user‚Äôs profit. The higher the markup, the lower their payout.

Another Example:

Stake: USD 25.50

Payout: USD 50

Markup: 2% of USD 50 = USD 1

Client Balance Debited: USD 26.50

Other ways to monetize the Deriv API

You can make money with your Deriv API application in several ways:

Charge for Access
Offer your trading app for a subscription or one-time fee if it provides value to users.

Offer Premium Features
Charge extra for advanced features like real-time market data or advance...

---

### Error codes
**URL:** https://developers.deriv.com/docs/error-codes

**Content:**
General
Error Code	Message
AccountShouldBeReal	Only real accounts are allowed to open [_1] real accounts. Demo account cannot open real dxtrader.
AccountTypesMismatch	Transfer between real and virtual accounts is not allowed.
AccountWithDeposit	Change of currency is not allowed for an existing account with previous deposits.
AffiliateNotFound	N/A
AllowCopiersError	Copier can't be a trader.
AlreadyAgeVerified	Your age has already been verified.
AlreadyVerified	This account is already phone number verified.
AmountNotAllowed	The minimum amount for transfers is [_1] [_2] after conversion fees are deducted. Please adjust the amount.
AppGet	Not Found
AppRegister	Not Found
AppUpdate	N/A
AppropriatenessTestFailed	Failed to reach an acceptable trading experience score.
AuthenticateAccount	Please authenticate your [_1] account to proceed with the fund transfer.
AuthenticateAccountCreate	Please verify your [_1] account to proceed with account creation.
AuthorizationRequired	Please log in.
BadSess...

---

### Copy trading
**URL:** https://developers.deriv.com/docs/copy-trading

**Data Fetching Examples:**
```text
allow_copiers
```

```text
allow_copiers
```

**Content:**
Copy Trading is a popular trend in financial markets. It allows one user, called the Copier, to automatically replicate the trades of another user, known as the Trader. This way, copiers can benefit from the expertise of experienced traders without making all the trading decisions themselves.

‚ùóÔ∏è

Copy trading is available only for Options. For copy trading on MT5, use MetaQuotes Signals.

Becoming a trader

To allow others to copy your trades:

Enable copying: Set the allow_copiers option via the set settings call.This setting allows other users to copy your trades.

Create an API token: Generate a read-only API token and share it with potential copiers. This token lets them track your trades without making any changes.

Track your performance: With allow_copiers enabled, the copytrading statistics call becomes available. This API provides stats on your trading performance, giving potential copiers insight into your trading history.

Becoming a copier

To start copying a Trader‚Äôs acti...

---

### Affiliates
**URL:** https://developers.deriv.com/docs/affiliates

**Data Fetching Examples:**
```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID&affiliate_token=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID&affiliate_token=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
YOUR_APP_ID
```

```text
YOUR_TOKEN
```

```text
FB58247C-6B33-4677-A6AD-168C2D72323C
```

```text
dynamicworks
```

```text
jqd7qq_iBB18zg8lBvFoLmNd7ZgqdRLk
```

```text
myaffiliates
```

```text
t
```

```text
utm_campaign
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
new_account_virtual
```

```text
new_account_real
```

```text
new_account_maltainvest
```

**Content:**
How to Become a Deriv Affiliate

Getting started as a Deriv Affiliate is simple and quick. Follow these steps:

Visit our Partners page and click on "Become a Partner".
Complete the Affiliate application form.
Wait for approval, which typically takes 1‚Äì3 working days.

Pro Tip: The approval process may be faster if your partner account application uses the same email as an existing Deriv account. Don‚Äôt have an account yet? Sign up here.

Affiliate Benefits

As a Deriv Affiliate, you‚Äôll gain access to exclusive advantages, including:

Up to 45% commission on referred clients‚Äô trading activity.

Free educational and marketing resources to support your efforts.

Multilingual support for global reach.

Transparent fee structure with detailed earnings reports.

Dedicated account manager to assist you.

24/7 live chat support for immediate help.

Affiliates can earn commissions when referred clients trade Options on third-party platforms developed using the Deriv API.

Leveraging Deriv API f...

---

### Create account using API
**URL:** https://developers.deriv.com/docs/create-account-using-api

**Data Fetching Examples:**
```text
type
```

```text
opening_account
```

```text
residence_list
```

```text
verify_email
```

```text
residence_list
```

```text
payout_currencies
```

```text
verify_email
```

```text
{
  "verify_email": "your_email@example.com",
  "type": "account_opening"
}
```

```text
{
  "verify_email": "your_email@example.com",
  "type": "account_opening"
}
```

```text
{
"new_account_virtual":1,
"client_password":"Abcd1234",
"verification_code":"7y0MXLQG",
"type":"dynamic",
"residence":"aq",
"date_first_contact":"2025-07-30",
"signup_device":"desktop",
"req_id":5
}
```

```text
{
"new_account_virtual":1,
"client_password":"Abcd1234",
"verification_code":"7y0MXLQG",
"type":"dynamic",
"residence":"aq",
"date_first_contact":"2025-07-30",
"signup_device":"desktop",
"req_id":5
}
```

```text
{
    "new_account_wallet": 1,
    "account_opening_reason": "Savings",
    "address_city": "Cyberjaya",
    "address_line_1": "Deriv HQ",
    "address_postcode": "63000",
    "address_state": "",
    "citizen": "de",
    "currency": "EUR",
    "date_of_birth": "2007-08-04",
    "employment_status": "Unemployed",
    "salutation": "Mr",
    "fatca_declaration": 0,
    "tax_residence": "de",
    "first_name": "Tay",
    "last_name": "Suisin",
    "phone": "234124124",
    "place_of_birth": "de",
    "residence": "de",
    "account_type": "doughflow",
    "landing_company_short": "maltainvest",
    "non_pep_declaration": 1,
    "tnc_acceptance": 1,
    "financial_assessment": {
        "employment_status": "Unemployed",
        "occupation": "Manager",
        "income_source": "Sale of art, antiques or other high value assets",
        "net_income": "Over $500,000",
        "source_of_wealth": "Proceeds of sale of crypto currency;Sale of art, antiques or high value assets",
        "estimated_worth": "Over $500,000",
        "investment_intention": "Over $500,000",
        "financial_information_version": "v2",
        "cfd_experience": "Over 3 years",
        "cfd_frequency": "40 transactions or more in the past 12 months",
        "cfd_trading_definition": "Place a bet on the price movement.",
        "leverage_impact_trading": "Leverage lets you open larger positions for a fraction of the trade's value.",
        "leverage_trading_high_risk_stop_loss": "Close your trade automatically when the loss is more than or equal to a specific amount.",
        "required_initial_margin": "When opening a Leveraged CFD trade.",
        "risk_tolerance": "Yes",
        "source_of_experience": "I have an academic degree, professional certification, and/or work experience.",
        "trading_experience_financial_instruments": "Over 3 years",
        "trading_frequency_financial_instruments": "40 transactions or more in the past 12 months"
    },
    "tin_skipped": 1,
    "calling_country_code": "49",
    "loginid": "VRW1115",
    "req_id": 18
}
```

```text
{
    "new_account_wallet": 1,
    "account_opening_reason": "Savings",
    "address_city": "Cyberjaya",
    "address_line_1": "Deriv HQ",
    "address_postcode": "63000",
    "address_state": "",
    "citizen": "de",
    "currency": "EUR",
    "date_of_birth": "2007-08-04",
    "employment_status": "Unemployed",
    "salutation": "Mr",
    "fatca_declaration": 0,
    "tax_residence": "de",
    "first_name": "Tay",
    "last_name": "Suisin",
    "phone": "234124124",
    "place_of_birth": "de",
    "residence": "de",
    "account_type": "doughflow",
    "landing_company_short": "maltainvest",
    "non_pep_declaration": 1,
    "tnc_acceptance": 1,
    "financial_assessment": {
        "employment_status": "Unemployed",
        "occupation": "Manager",
        "income_source": "Sale of art, antiques or other high value assets",
        "net_income": "Over $500,000",
        "source_of_wealth": "Proceeds of sale of crypto currency;Sale of art, antiques or high value assets",
        "estimated_worth": "Over $500,000",
        "investment_intention": "Over $500,000",
        "financial_information_version": "v2",
        "cfd_experience": "Over 3 years",
        "cfd_frequency": "40 transactions or more in the past 12 months",
        "cfd_trading_definition": "Place a bet on the price movement.",
        "leverage_impact_trading": "Leverage lets you open larger positions for a fraction of the trade's value.",
        "leverage_trading_high_risk_stop_loss": "Close your trade automatically when the loss is more than or equal to a specific amount.",
        "required_initial_margin": "When opening a Leveraged CFD trade.",
        "risk_tolerance": "Yes",
        "source_of_experience": "I have an academic degree, professional certification, and/or work experience.",
        "trading_experience_financial_instruments": "Over 3 years",
        "trading_frequency_financial_instruments": "40 transactions or more in the past 12 months"
    },
    "tin_skipped": 1,
    "calling_country_code": "49",
    "loginid": "VRW1115",
    "req_id": 18
}
```

```text
{
"new_account_wallet":1,
"currency":"USD",
"first_name":"Tay",
"last_name":"Suisin",
"date_of_birth":"2007-07-27",
"address_line_1":"Deriv HQ",
"address_city":"Cyberjaya",
"address_postcode":"63000",
"fatca_declaration":0,
"residence":"aq",
"non_pep_declaration":1,
"citizen":"aq",
"phone":"123123123",
"place_of_birth":"aq",
"account_opening_reason":"Savings",
"tax_residence":"aq",
"employment_status":"Unemployed",
"tnc_acceptance":1,
"loginid":"VRW1244",
"calling_country_code":"672",
"account_type":"doughflow",
"tin_skipped":1,
"financial_assessment":{
"financial_information_version":"v2"
},
"req_id":19
}
```

```text
{
"new_account_wallet":1,
"currency":"USD",
"first_name":"Tay",
"last_name":"Suisin",
"date_of_birth":"2007-07-27",
"address_line_1":"Deriv HQ",
"address_city":"Cyberjaya",
"address_postcode":"63000",
"fatca_declaration":0,
"residence":"aq",
"non_pep_declaration":1,
"citizen":"aq",
"phone":"123123123",
"place_of_birth":"aq",
"account_opening_reason":"Savings",
"tax_residence":"aq",
"employment_status":"Unemployed",
"tnc_acceptance":1,
"loginid":"VRW1244",
"calling_country_code":"672",
"account_type":"doughflow",
"tin_skipped":1,
"financial_assessment":{
"financial_information_version":"v2"
},
"req_id":19
}
```

```text
affiliate_token
```

```text
utm_campaign
```

```text
affiliate_token
```

```text
utm_campaign
```

**Content:**
Follow these simple steps to create demo and real accounts using the Deriv API:

Verify email
Make a call to the verify_email endpoint.
Set the type parameter to opening_account to indicate you‚Äôre opening a new account.
You will receive an email containing a verification code at the email address provided in the API call. This code is required for the next steps.


Create a Demo Account

To create a demo account:

Make a call to the new_account_virtual endpoint.
Provide the following information:
Residence: The 2-letter country code. Obtain this from the residence_list call or check the list here.
Verification Code: The email verification code you received from the verify_email call above.

A demo account will be created with a starting balance of USD 10,000.

Create a Real Account

To set up a real account, follow these steps after logging into your demo account:

For users in the EU: Use the new_account_maltainvest endpoint.

For users outside the EU: Use the new_account_real endpoin...

---

### Trade Options
**URL:** https://developers.deriv.com/docs/trade-using-accumalators

**Content:**
Options: A financial derivative that gives the buyer the right, but not the obligation, to buy or sell an asset at a set price within a specific period. Options can be used for speculation or hedging.

The types of options supported on Deriv include:

Updated 10 months ago

Did this page help you?
Yes
No...

---

### Rise/Fall
**URL:** https://developers.deriv.com/docs/risefall

**Data Fetching Examples:**
```text
contract_type
```

```text
contract_type
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Predict if the market price will rise above or fall below the entry price at the end of the contract.

If you select "Rise", you win the Payout if the Exit spot is strictly higher than the Entry spot.

If you select "Fall", you win the Payout if the Exit spot is strictly lower than the Entry spot.

If you select "Allow equals", you win the Payout if Exit spot is higher than or equal to Entry spot for "Rise". Similarly, you win the Payout if Exit spot is lower than or equal to Entry spot for "Fall".

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Rise/Fall option...

---

### Higher/Lower
**URL:** https://developers.deriv.com/docs/higherlower

**Data Fetching Examples:**
```text
contract_type
```

```text
barrier: "+0.37"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Choose a target price (Barrier) and predict if the market price will be higher or lower than the target at the end of the contract.

If you select "Higher", you win the Payout if the Exit spot is strictly higher than the Barrier.

If you select "Lower", you win the Payout if the Exit spotis strictly lower than the Barrier.

If the Exit spot is equal to the Barrier, you don't win the Payout.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Higher/Lower options:

Use the the contract_type:
For Higher, use: "CALL"
For Lower, use: "PUT"
Set the Barrier. Eg: barrier: ...

---

### Ends Between
**URL:** https://developers.deriv.com/docs/ends-between

**Data Fetching Examples:**
```text
contract_type
```

```text
EXPIRYRANGE
```

```text
EXPIRYMISS
```

```text
barrier
```

```text
barrier: "+1.51"
```

```text
barrier2
```

```text
barrier: "-1.51"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Choose a price range (upper and lower barriers) and predict if the market price will end between or end outside the range at the end of the contract.

If you select "Ends Between", you win the Payout if the Exit spot is strictly higher than the Low Barrier AND strictly lower than the High Barrier.

If you select "Ends Outside", you win the Payout if the Exit spot is EITHER strictly higher than the High Barrier, OR strictly lower than the Low Barrier.

If the Exit spot is equal to either the Low Barrier or the High Barrier, you don‚Äôt win the Payout.

Trading Flow

Authorize using your token: Call [authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an...

---

### Stays Between
**URL:** https://developers.deriv.com/docs/stays-between

**Data Fetching Examples:**
```text
contract_type
```

```text
RANGE
```

```text
UPORDOWN
```

```text
barrier
```

```text
barrier: "+1.51"
```

```text
barrier2
```

```text
barrier: "-1.51"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Choose a price range (upper and lower barriers) and predict if the market price will stay between or go outside the range during the contract period.

If you select "Stays Between", you win the Payout if the market stays between (does not touch) either the High Barrier or the Low Barrier at any time during the Contract period.

If you select "Goes Outside", you win the Payout if the market touches either the High Barrier or the Low Barrier at any time during the Contract period.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Stays Between/ Goes Outside options,...

---

### Lookbacks
**URL:** https://developers.deriv.com/docs/lookbacks

**Data Fetching Examples:**
```text
contract_type
```

```text
LBFLOATPUT
```

```text
multiplier: 1
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

```text
contract_type
```

```text
LBHIGHLOW
```

```text
multiplier: 1
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

```text
contract_type
```

```text
LBFLOATCALL
```

```text
multiplier: 1
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Choose an amount you want to earn per point of movement. There are three types of lookbacks:

High-Close: The highest market price during the contract period minus the price at the contract end.
High-Low: The highest market price minus the lowest market price during the contract period.
Close-Low: The market price at the contract end minus the lowest market price during the contract period.
High-Close

By purchasing the "High-Close" contract, you'll win the multiplier times the difference between the High and Close over the duration of the contract.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID ...

---

### Touch/No Touch
**URL:** https://developers.deriv.com/docs/touchno-touch

**Data Fetching Examples:**
```text
contract_type
```

```text
ONETOUCH
```

```text
NOTOUCH
```

```text
barrier: "+1.37"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Choose a target price (Barrier) and predict if the market price will touch or not touch the target during the contract period.

If you select "Touch", you win the Payout if the market touches the Barrier at any time during the contract period.

If you select "No Touch", you win the Payout if the market never touches the Barrier at any time during the contract period.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Touch/No Touch options:

Use the the contract_type:

For Touch, use: "ONETOUCH"
For No Touch, use: "NOTOUCH"

Set the Barrier. Eg: barrier: "+1.37"

B...

---

### Only Ups/Only Downs
**URL:** https://developers.deriv.com/docs/only-upsonly-downs

**Data Fetching Examples:**
```text
contract_type
```

```text
RUNHIGH
```

```text
RUNLOW
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Predict if the market price will go only up or only down during the contract period.

If you select "Only Ups", you win the Payout if consecutive ticks rise successively after the Entry spot. No payout if any tick falls or is equal to any of the previous ticks.

If you select "Only Downs", you win the Payout if consecutive ticks fall successively after the Entry spot. No payout if any tick rises or is equal to any of the previous ticks.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Only Ups/Downs options:

Use the the contract_type:
For Only Ups , use: "RUNHIG...

---

### Highest/Lowest Tick
**URL:** https://developers.deriv.com/docs/highestlowest-tick

**Data Fetching Examples:**
```text
contract_type
```

```text
TICKHIGH
```

```text
TICKLOW
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Predict which of the next 5 ticks will see the highest or lowest market price.

If you select "High Tick", you win the Payout if the selected tick is the highest among the next five ticks.

If you select "Low Tick", you win the Payout if the selected tick is the lowest among the next five ticks.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the High/Low Tick options:

Use the the contract_type:
For High Tick, use: "TICKHIGH"
For Low Tick, use: "TICKLOW"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action re...

---

### Reset Call/Put
**URL:** https://developers.deriv.com/docs/reset-callput

**Data Fetching Examples:**
```text
contract_type
```

```text
RESETCALL
```

```text
RESETPUT
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Predict if the market price will be higher (Call) or lower (Put) than the entry price or the reset price at the end of the contract. A 'reset' is triggered if the market moves against your prediction around the midpoint of the contract, setting the reset price to the market‚Äôs current level.




If you select "Reset-Call", you win the Payout if the Exit spot is strictly higher than either the Entry spot or the spot at Reset time.

If you select "Reset-Put", you win the Payout if the Exit spot is strictly lower than either the Entry spot or the spot at Reset time.

If the Exit spot is equal to the Barrier or the new Barrier (if a reset occurs), you don't win the Payout.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of ...

---

### Asian Up/Down
**URL:** https://developers.deriv.com/docs/asian-updown

**Data Fetching Examples:**
```text
contract_type
```

```text
ASIANU
```

```text
ASIAND
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Asian options settle by comparing the last tick with the average spot over the period.

If you select "Asian Up", you will win the Payout if the last tick is higher than the averageof the ticks.

If you select "Asian Down", you will win the Payout if the last tick is lower than the average of the ticks.

If the last tick is equal to the average of the ticks, you don't win the Payout.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.
Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.
Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Asian Up/Down options, set the the contract_type:
For Up, use: "ASIANU"
For Down, use: "ASIAND"
Buy the Contract: Execute the trade by us...

---

### Digit Matches/Differs
**URL:** https://developers.deriv.com/docs/digit-matchesdiffers

**Data Fetching Examples:**
```text
contract_type
```

```text
DIGITMATCH
```

```text
DIGITDIFF
```

```text
barrier
```

```text
barrier: "9"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
If you select "Matches", you will win the payout if the last digit of the last tick is the same as your prediction.

If you select "Differs", you will win the payout if the last digit of the last tick is not the same as your prediction.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Matches/Differs options, use the following:

Set contract_type:

For Matches, use: "DIGITMATCH"
For Differs, use: "DIGITDIFF"

For the Last Digit Prediction: set the barrier between 0-9. Eg: barrier: "9"

Buy the Contract: Execute the trade by using the buy API with the ID from the ...

---

### Digit Even/Odd
**URL:** https://developers.deriv.com/docs/digit-evenodd

**Data Fetching Examples:**
```text
contract_type
```

```text
DIGITEVEN
```

```text
DIGITODD
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
If you select "Even", you will win the Payout if the last digit of the last tick is an even number (i.e., 2, 4, 6, 8, or 0).

If you select "Odd", you will win the Payout if the last digit of the last tick is an odd number (i.e., 1, 3, 5, 7, or 9).

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the digit Even/Odd options, use the following the contract_type:

For Even: "DIGITEVEN"
For Odd: "DIGITODD"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal response. This action returns a unique contract_id.

Monitor the Contract Statu...

---

### Digit Over/Under
**URL:** https://developers.deriv.com/docs/digit-overunder

**Data Fetching Examples:**
```text
contract_type
```

```text
DIGITMATCH
```

```text
DIGITUNDER
```

```text
barrier
```

```text
barrier: "6"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
If you select "Over", you will win the Payout if the last digit of the last tick is greater than your prediction.

If you select "Under", you will win the Payout if the last digit of the last tick is less than your prediction.

Trading Flow

Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.

Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.

Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.

Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the Digit Over/Under options, use the following

Set contract_type:

For Over, use: "DIGITMATCH"
For Under, use: "DIGITUNDER"

For the Last Digit Prediction: set the barrier between 0-9. Eg: barrier: "6"

Buy the Contract: Execute the trade by using the buy API with the ID from the proposal respo...

---

### Accumulator Options
**URL:** https://developers.deriv.com/docs/accumulator-options

**Data Fetching Examples:**
```text
contract_type
```

```text
"ACCU"
```

```text
growth_rate: 0.03
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150 }
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Amplify potential profits with up to 5% compounding growth per tick with Accumulator Options.

Choose a growth rate (1-5%) within a specified price range and predict if the market price will stay within the range. Your Payout grows at a compounding rate for each tick, and the market price stays in the range.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fetch Available Instruments: Use the active_symbols API to retrieve a list of all trading instruments offered on Deriv.
Get Contract Details: Using the contracts_for API, obtain a list of contracts available for a specific instrument.
Request a Price: Use the proposal API to get a quote. This will return an ID for the proposed trade.
For the accumulator options,
Use the contract_type: "ACCU"
Growth Rate: You can choose a growth rate with values of 1%(0.01), 2%(0.02), 3%(0.03), 4%(0.04), and 5%(0.05). Eg: Set growth_rate: 0.03
Take Profit: If you select...

---

### Vanilla Options
**URL:** https://developers.deriv.com/docs/vanilla-options

**Data Fetching Examples:**
```text
contract_type
```

```text
"VANILLALONGCALL"
```

```text
"VANILLALONGPUT"
```

```text
barrier: "+0.00"
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Earn a potentially high payout with Vanilla Options if your predictions are right within a timed contract based on market conditions.

Vanilla options allow you to predict an upward (bullish) or downward (bearish) direction of the underlying asset by purchasing a "Call" or a "Put".

If you select "Call", you'll earn a Payout if the Final price is above the Strike price at Expiry. Otherwise, you won't receive a payout.
If you select "Put", you'll earn a Payout if the Final price is below the Strike price at Expiry. Otherwise, you won't receive a payout.

Your Payout is equal to the Payout per point multiplied by the difference between the Final price and the Strike price. You will only earn a profit if your Payout is higher than your initial stake.

You may sell the contract up until 60 seconds before Expiry. If you do, we'll pay you the Contract value.

Trading Flow
Authorize using your token: Call authorize API using your token. Ensure that the token has the trading scope enabled.
Fet...

---

### Turbo Options
**URL:** https://developers.deriv.com/docs/turbo-options

**Data Fetching Examples:**
```text
contract_type
```

```text
"TURBOSLONG"
```

```text
"TURBOSSHORT"
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150 }
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
With Turbo Options, you can earn a payout if your predictions are right and if the spot price does not touch or breach a predetermined barrier.

Turbo options allow you to predict the direction of the underlying asset's movements.

You receive a Payout at Expiry if the spot price never breaches the Barrier during the contract period. If it does, your contract will be terminated early.

If you select "Up", you'll earn a Payout if the spot price never drops below the Barrier.

If you select "Down", you'll earn a Payout if the spot price never rises above the Barrier.

Your payout is equal to the Payout per point multiplied by the distance between the Final price and the Barrier. You will only earn a profit if your Payout is higher than your initial stake.

You may sell the contract up to 15 seconds before expiry. If you do, we'll pay you the Contract value.
If you choose your duration in number of ticks, you won't be able to terminate your contract early.

Trading Flow
Authorize using yo...

---

### Multipliers
**URL:** https://developers.deriv.com/docs/multipliers

**Data Fetching Examples:**
```text
contract_type
```

```text
"MULTUP"
```

```text
"MULTDOWN"
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150 }
```

```text
limit_order
```

```text
limit_order : {       take_profit: 150, stop_loss:130 }
```

```text
cancellation: 60m
```

```text
contract_id
```

```text
contract_id
```

```text
contract_id
```

**Content:**
Multiply your potential profit by up to 2,000x if the market moves in your favour. Losses are limited only to your initial capital.

Choose a multiplier (up to 2,000x) and predict if the market price will go up(bullish)or down (bearish) compared to the entry price. Your potential payout grows as the market price moves in your predicted direction, boosted by the multiplier. Losses are limited to the initial amount you put into the contract.

If you select "Up", your total profit/loss will be the percentage increase in the underlying asset price, times the multiplier and stake, minus commissions.
If you select "Down", your total profit/loss will be the percentage decrease in the underlying asset price, times the multiplier and stake, minus commissions.

Your contract will be closed when the Stop out level is reached.

Additional features are available to manage your positions: Take profit, Stop loss and Deal cancellation allow you to adjust your level of risk aversion.

You can close you...

---

### Keep connection live
**URL:** https://developers.deriv.com/docs/keep-connection-live

**Data Fetching Examples:**
```text
DerivAPIBasic
```

```text
import DerivAPIBasic from 'https://cdn.skypack.dev/@deriv/deriv-api/dist/DerivAPIBasic';
```

```text
app_id
```

```text
wss://ws.derivws.com/websockets/v3?app_id=${app_id}
```

```text
const connection = new WebSocket(
```

```text
);
```

```text
DerivAPIBasic
```

```text
const api = new DerivAPIBasic({ connection });
```

```text
proposal()
```

```text
const proposal = () => {  
  api.subscribe({  
    proposal: 1,  
    subscribe: 1,  
    amount: 10,  
    basis: 'payout',  
    contract_type: 'CALL',  
    currency: 'USD',  
    duration: 1,  
    duration_unit: 'm',  
    symbol: 'R_100',  
    barrier: '+0.1',  
  });  
};
```

```text
const proposal = () => {  
  api.subscribe({  
    proposal: 1,  
    subscribe: 1,  
    amount: 10,  
    basis: 'payout',  
    contract_type: 'CALL',  
    currency: 'USD',  
    duration: 1,  
    duration_unit: 'm',  
    symbol: 'R_100',  
    barrier: '+0.1',  
  });  
};
```

```text
ping()
```

```text
ping
```

```text
setInterval
```

```text
const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000);
};
```

```text
const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000);
};
```

```text
wsResponse()
```

```text
const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error: %s ', data.error.message);
    connection.removeEventListener('message', wsResponse, false);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details: %s', data.proposal.longcode);
    console.log('Ask Price: %s', data.proposal.display_value);
    console.log('Payout: %f', data.proposal.payout);
    console.log('Spot: %f', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};
```

```text
const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error: %s ', data.error.message);
    connection.removeEventListener('message', wsResponse, false);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details: %s', data.proposal.longcode);
    console.log('Ask Price: %s', data.proposal.display_value);
    console.log('Payout: %f', data.proposal.payout);
    console.log('Spot: %f', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};
```

```text
checkSignal()
```

```text
proposal()
```

```text
ping()
```

```text
connection.addEventListener('message', wsResponse)
```

```text
wsResponse()
```

```text
const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};
```

```text
const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};
```

```text
endCall()
```

```text
unsubscribe()
```

```text
proposal()
```

```text
const endCall = () => {
  connection.removeEventListener('message', wsResponse, false);
  proposal().unsubscribe();
};
```

```text
const endCall = () => {
  connection.removeEventListener('message', wsResponse, false);
  proposal().unsubscribe();
};
```

```text
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

const app_id = app_id; // Replace with your app_id if different.
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
const api = new DerivAPIBasic({ connection });

const proposal = () => {
  api.subscribe({
    proposal: 1,
    subscribe: 1,
    amount: 10,
    basis: 'payout',
    contract_type: 'CALL',
    currency: 'USD',
    duration: 1,
    duration_unit: 'm',
    symbol: 'R_100',
    barrier: '+0.1',
  });
};

const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000); // Sends a ping message every 30 seconds
};

const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error:', data.error.message);
    connection.removeEventListener('message', wsResponse);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details:', data.proposal.longcode);
    console.log('Ask Price:', data.proposal.display_value);
    console.log('Payout:', data.proposal.payout);
    console.log('Spot:', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};

const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};

// Browser-specific functionality
if (typeof document !== 'undefined') {
  const keep_alive_button = document.querySelector('#keep_alive');
  const end_call_button = document.querySelector('#end_call');

  keep_alive_button.addEventListener('click', checkSignal);
  end_call_button.addEventListener('click', () => {
    connection.removeEventListener('message', wsResponse);
    proposal().unsubscribe();
  });
} else {
  // For Node.js environment: start the signal check immediately
  checkSignal();
}

/*
Instructions:

1. **Install Node.js**: Ensure you have Node.js installed from https://nodejs.org/.
2. **Install Deriv API Package**: Use npm to install the Deriv API package by running:
npm install @deriv/deriv-api
3. **Save the Code**: Save the code in a file, e.g., `websocket_example.js`.
4. **Run in Node.js**:
- In your terminal, navigate to the directory where you saved the file.
- Run the script using:
  ```
  node websocket_example.js
  ```
5. **Run in a Browser**:
- Include the script in your HTML page, and ensure there are two buttons with IDs `keep_alive` and `end_call`.
- Use the `keep_alive` button to start the signal check and the `end_call` button to unsubscribe from the proposal and stop receiving messages.

Replace the `app_id` in the URL if you have a different app ID.
*/
```

```text
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

const app_id = app_id; // Replace with your app_id if different.
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
const api = new DerivAPIBasic({ connection });

const proposal = () => {
  api.subscribe({
    proposal: 1,
    subscribe: 1,
    amount: 10,
    basis: 'payout',
    contract_type: 'CALL',
    currency: 'USD',
    duration: 1,
    duration_unit: 'm',
    symbol: 'R_100',
    barrier: '+0.1',
  });
};

const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000); // Sends a ping message every 30 seconds
};

const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error:', data.error.message);
    connection.removeEventListener('message', wsResponse);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details:', data.proposal.longcode);
    console.log('Ask Price:', data.proposal.display_value);
    console.log('Payout:', data.proposal.payout);
    console.log('Spot:', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};

const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};

// Browser-specific functionality
if (typeof document !== 'undefined') {
  const keep_alive_button = document.querySelector('#keep_alive');
  const end_call_button = document.querySelector('#end_call');

  keep_alive_button.addEventListener('click', checkSignal);
  end_call_button.addEventListener('click', () => {
    connection.removeEventListener('message', wsResponse);
    proposal().unsubscribe();
  });
} else {
  // For Node.js environment: start the signal check immediately
  checkSignal();
}

/*
Instructions:

1. **Install Node.js**: Ensure you have Node.js installed from https://nodejs.org/.
2. **Install Deriv API Package**: Use npm to install the Deriv API package by running:
npm install @deriv/deriv-api
3. **Save the Code**: Save the code in a file, e.g., `websocket_example.js`.
4. **Run in Node.js**:
- In your terminal, navigate to the directory where you saved the file.
- Run the script using:
  ```
  node websocket_example.js
  ```
5. **Run in a Browser**:
- Include the script in your HTML page, and ensure there are two buttons with IDs `keep_alive` and `end_call`.
- Use the `keep_alive` button to start the signal check and the `end_call` button to unsubscribe from the proposal and stop receiving messages.

Replace the `app_id` in the URL if you have a different app ID.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a proposal subscription request
    func sendProposalSubscription() {
        let proposalRequest = [
            "proposal": 1,
            "subscribe": 1,
            "amount": 10,
            "basis": "payout",
            "contract_type": "CALL",
            "currency": "USD",
            "duration": 1,
            "duration_unit": "m",
            "symbol": "R_100",
            "barrier": "+0.1"
        ] as [String: Any]
        
        if let proposalData = try? JSONSerialization.data(withJSONObject: proposalRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(proposalData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send proposal subscription: \(error.localizedDescription)")
                } else {
                    print("Proposal subscription sent.")
                }
            }
        }
    }
    
    // Function to send a ping message every 30 seconds
    func startPing() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            let pingMessage = URLSessionWebSocketTask.Message.string("{\"ping\": 1}")
            webSocketTask?.send(pingMessage) { error in
                if let error = error {
                    print("[error] Failed to send ping: \(error.localizedDescription)")
                } else {
                    print("Ping sent to keep connection alive.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the proposal and ping response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "proposal", let proposal = data["proposal"] as? [String: Any] {
            print("Details: \(proposal["longcode"] ?? "")")
            print("Ask Price: \(proposal["display_value"] ?? "")")
            print("Payout: \(proposal["payout"] ?? "")")
            print("Spot: \(proposal["spot"] ?? "")")
        } else if data["msg_type"] as? String == "ping" {
            print("[Ping] Ping response received.")
        }
    }
    
    // Start sending the proposal subscription and pinging the server
    sendProposalSubscription()
    startPing()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
 * Instructions to Run:
 * 1. Ensure Swift is installed on your machine.
 * 2. Save this code in a file, for example, `WebSocketClient.swift`.
 * 3. Open a terminal, navigate to the directory where you saved the file, and run:
 *      swift WebSocketClient.swift
 * 4. The script connects to the WebSocket server, sends a proposal subscription, and sends a ping every 30 seconds to keep the connection alive.
 */
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a proposal subscription request
    func sendProposalSubscription() {
        let proposalRequest = [
            "proposal": 1,
            "subscribe": 1,
            "amount": 10,
            "basis": "payout",
            "contract_type": "CALL",
            "currency": "USD",
            "duration": 1,
            "duration_unit": "m",
            "symbol": "R_100",
            "barrier": "+0.1"
        ] as [String: Any]
        
        if let proposalData = try? JSONSerialization.data(withJSONObject: proposalRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(proposalData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send proposal subscription: \(error.localizedDescription)")
                } else {
                    print("Proposal subscription sent.")
                }
            }
        }
    }
    
    // Function to send a ping message every 30 seconds
    func startPing() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            let pingMessage = URLSessionWebSocketTask.Message.string("{\"ping\": 1}")
            webSocketTask?.send(pingMessage) { error in
                if let error = error {
                    print("[error] Failed to send ping: \(error.localizedDescription)")
                } else {
                    print("Ping sent to keep connection alive.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the proposal and ping response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "proposal", let proposal = data["proposal"] as? [String: Any] {
            print("Details: \(proposal["longcode"] ?? "")")
            print("Ask Price: \(proposal["display_value"] ?? "")")
            print("Payout: \(proposal["payout"] ?? "")")
            print("Spot: \(proposal["spot"] ?? "")")
        } else if data["msg_type"] as? String == "ping" {
            print("[Ping] Ping response received.")
        }
    }
    
    // Start sending the proposal subscription and pinging the server
    sendProposalSubscription()
    startPing()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
 * Instructions to Run:
 * 1. Ensure Swift is installed on your machine.
 * 2. Save this code in a file, for example, `WebSocketClient.swift`.
 * 3. Open a terminal, navigate to the directory where you saved the file, and run:
 *      swift WebSocketClient.swift
 * 4. The script connects to the WebSocket server, sends a proposal subscription, and sends a ping every 30 seconds to keep the connection alive.
 */
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{time::interval, sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[open] Connection established");

    // Proposal request JSON
    let proposal_request = json!({
        "proposal": 1,
        "subscribe": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    });

    // Clone `socket` for the ping task and start pinging every 30 seconds
    let ping_socket = Arc::clone(&socket);
    let ping_task = spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            let mut socket = ping_socket.lock().await;
            if socket.send(Message::Text(json!({ "ping": 1 }).to_string())).await.is_ok() {
                println!("[ping] Ping sent to keep connection alive.");
            }
        }
    });

    // Clone `socket` for sending the proposal
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(proposal_request.to_string())).await.is_ok() {
            println!("Proposal subscription sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if let Some(proposal) = data.get("proposal") {
                        println!("Details: {}", proposal["longcode"]);
                        println!("Ask Price: {}", proposal["display_value"]);
                        println!("Payout: {}", proposal["payout"]);
                        println!("Spot: {}", proposal["spot"]);
                    } else if data.get("msg_type").unwrap_or(&json!("")) == "ping" {
                        println!("[Ping] Ping response received.");
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(ping_task, send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{time::interval, sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[open] Connection established");

    // Proposal request JSON
    let proposal_request = json!({
        "proposal": 1,
        "subscribe": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    });

    // Clone `socket` for the ping task and start pinging every 30 seconds
    let ping_socket = Arc::clone(&socket);
    let ping_task = spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            let mut socket = ping_socket.lock().await;
            if socket.send(Message::Text(json!({ "ping": 1 }).to_string())).await.is_ok() {
                println!("[ping] Ping sent to keep connection alive.");
            }
        }
    });

    // Clone `socket` for sending the proposal
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(proposal_request.to_string())).await.is_ok() {
            println!("Proposal subscription sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if let Some(proposal) = data.get("proposal") {
                        println!("Details: {}", proposal["longcode"]);
                        println!("Ask Price: {}", proposal["display_value"]);
                        println!("Payout: {}", proposal["payout"]);
                        println!("Spot: {}", proposal["spot"]);
                    } else if data.get("msg_type").unwrap_or(&json!("")) == "ping" {
                        println!("[Ping] Ping response received.");
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(ping_task, send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a proposal subscription request
    $proposal_request = json_encode([
        "proposal" => 1,
        "subscribe" => 1,
        "amount" => 10,
        "basis" => "payout",
        "contract_type" => "CALL",
        "currency" => "USD",
        "duration" => 1,
        "duration_unit" => "m",
        "symbol" => "R_100",
        "barrier" => "+0.1"
    ]);
    $client->send($proposal_request);
    echo "[sent] Proposal subscription sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "proposal") {
            $proposal = $data["proposal"];
            echo "[proposal] Details: {$proposal['longcode']}\n";
            echo "[proposal] Ask Price: {$proposal['display_value']}\n";
            echo "[proposal] Payout: {$proposal['payout']}\n";
            echo "[proposal] Spot: {$proposal['spot']}\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `websocket_client.php`.
6. Run the code from the command line:

   php websocket_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a proposal subscription request
    $proposal_request = json_encode([
        "proposal" => 1,
        "subscribe" => 1,
        "amount" => 10,
        "basis" => "payout",
        "contract_type" => "CALL",
        "currency" => "USD",
        "duration" => 1,
        "duration_unit" => "m",
        "symbol" => "R_100",
        "barrier" => "+0.1"
    ]);
    $client->send($proposal_request);
    echo "[sent] Proposal subscription sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "proposal") {
            $proposal = $data["proposal"];
            echo "[proposal] Details: {$proposal['longcode']}\n";
            echo "[proposal] Ask Price: {$proposal['display_value']}\n";
            echo "[proposal] Payout: {$proposal['payout']}\n";
            echo "[proposal] Spot: {$proposal['spot']}\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `websocket_client.php`.
6. Run the code from the command line:

   php websocket_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// Define constants
const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//Replace with your app_id
)

// ProposalRequest defines the structure of the proposal subscription request
type ProposalRequest struct {
	Proposal      int    `json:"proposal"`
	Subscribe     int    `json:"subscribe"`
	Amount        int    `json:"amount"`
	Basis         string `json:"basis"`
	ContractType  string `json:"contract_type"`
	Currency      string `json:"currency"`
	Duration      int    `json:"duration"`
	DurationUnit  string `json:"duration_unit"`
	Symbol        string `json:"symbol"`
	Barrier       string `json:"barrier"`
}

func main() {
	// Set up WebSocket connection context
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish a WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("WebSocket connection established.")

	// Send initial proposal subscription request
	err = sendProposalRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send proposal request: %v", err)
	}

	// Start keep-alive ping
	go keepAlivePing(ctx, conn)

	// Handle incoming messages
	handleResponses(ctx, conn)
}

// sendProposalRequest sends a proposal subscription request to the WebSocket server
func sendProposalRequest(ctx context.Context, conn *websocket.Conn) error {
	// Construct proposal subscription request
	proposal := ProposalRequest{
		Proposal:     1,
		Subscribe:    1,
		Amount:       10,
		Basis:        "payout",
		ContractType: "CALL",
		Currency:     "USD",
		Duration:     1,
		DurationUnit: "m",
		Symbol:       "R_100",
		Barrier:      "+0.1",
	}
	fmt.Println("Sending proposal subscription...")

	return wsjson.Write(ctx, conn, proposal)
}

// keepAlivePing sends a ping message every 30 seconds to keep the connection alive
func keepAlivePing(ctx context.Context, conn *websocket.Conn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Send ping message
			pingMsg := map[string]int{"ping": 1}
			err := wsjson.Write(ctx, conn, pingMsg)
			if err != nil {
				log.Printf("Ping failed: %v", err)
				return
			}
			fmt.Println("Ping sent.")
		case <-ctx.Done():
			return
		}
	}
}

// handleResponses listens for and processes messages received from the WebSocket server
func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}
		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		// Process response messages
		msgType := response["msg_type"]
		switch msgType {
		case "proposal":
			// Print proposal details
			proposal := response["proposal"].(map[string]interface{})
			fmt.Printf("Details: %v\n", proposal["longcode"])
			fmt.Printf("Ask Price: %v\n", proposal["display_value"])
			fmt.Printf("Payout: %v\n", proposal["payout"])
			fmt.Printf("Spot: %v\n", proposal["spot"])
		case "ping":
			fmt.Println("[Ping] Ping response received.")
		default:
			fmt.Printf("Received message: %v\n", response)
		}
	}
}

/*
Instructions to run the code locally:

1. Install Go: Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.

2. Save the code:
   - Save this code into a file named `connect.go`.

3. Initialize a Go module:
   - Open a terminal in the directory containing `connect.go`.
   - Run `go mod init app` to initialize a new Go module.
   - Run `go get nhooyr.io/websocket` to install the WebSocket package dependency.

4. Run the code:
   - Execute the code using the command `go run connect.go`.
   - Alternatively, you can build and run the executable:
     ```
     go build -o connect connect.go
     ./connect
     ```
5. Replace `app_id=1089` with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// Define constants
const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//Replace with your app_id
)

// ProposalRequest defines the structure of the proposal subscription request
type ProposalRequest struct {
	Proposal      int    `json:"proposal"`
	Subscribe     int    `json:"subscribe"`
	Amount        int    `json:"amount"`
	Basis         string `json:"basis"`
	ContractType  string `json:"contract_type"`
	Currency      string `json:"currency"`
	Duration      int    `json:"duration"`
	DurationUnit  string `json:"duration_unit"`
	Symbol        string `json:"symbol"`
	Barrier       string `json:"barrier"`
}

func main() {
	// Set up WebSocket connection context
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish a WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("WebSocket connection established.")

	// Send initial proposal subscription request
	err = sendProposalRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send proposal request: %v", err)
	}

	// Start keep-alive ping
	go keepAlivePing(ctx, conn)

	// Handle incoming messages
	handleResponses(ctx, conn)
}

// sendProposalRequest sends a proposal subscription request to the WebSocket server
func sendProposalRequest(ctx context.Context, conn *websocket.Conn) error {
	// Construct proposal subscription request
	proposal := ProposalRequest{
		Proposal:     1,
		Subscribe:    1,
		Amount:       10,
		Basis:        "payout",
		ContractType: "CALL",
		Currency:     "USD",
		Duration:     1,
		DurationUnit: "m",
		Symbol:       "R_100",
		Barrier:      "+0.1",
	}
	fmt.Println("Sending proposal subscription...")

	return wsjson.Write(ctx, conn, proposal)
}

// keepAlivePing sends a ping message every 30 seconds to keep the connection alive
func keepAlivePing(ctx context.Context, conn *websocket.Conn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Send ping message
			pingMsg := map[string]int{"ping": 1}
			err := wsjson.Write(ctx, conn, pingMsg)
			if err != nil {
				log.Printf("Ping failed: %v", err)
				return
			}
			fmt.Println("Ping sent.")
		case <-ctx.Done():
			return
		}
	}
}

// handleResponses listens for and processes messages received from the WebSocket server
func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}
		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		// Process response messages
		msgType := response["msg_type"]
		switch msgType {
		case "proposal":
			// Print proposal details
			proposal := response["proposal"].(map[string]interface{})
			fmt.Printf("Details: %v\n", proposal["longcode"])
			fmt.Printf("Ask Price: %v\n", proposal["display_value"])
			fmt.Printf("Payout: %v\n", proposal["payout"])
			fmt.Printf("Spot: %v\n", proposal["spot"])
		case "ping":
			fmt.Println("[Ping] Ping response received.")
		default:
			fmt.Printf("Received message: %v\n", response)
		}
	}
}

/*
Instructions to run the code locally:

1. Install Go: Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.

2. Save the code:
   - Save this code into a file named `connect.go`.

3. Initialize a Go module:
   - Open a terminal in the directory containing `connect.go`.
   - Run `go mod init app` to initialize a new Go module.
   - Run `go get nhooyr.io/websocket` to install the WebSocket package dependency.

4. Run the code:
   - Execute the code using the command `go run connect.go`.
   - Alternatively, you can build and run the executable:
     ```
     go build -o connect connect.go
     ./connect
     ```
5. Replace `app_id=1089` with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed
    private static readonly int pingInterval = 30000; // Ping every 30 seconds

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("WebSocket connection established.");

            // Send initial proposal subscription request
            await SendProposalSubscription(webSocket);

            // Start a task to send pings to keep connection alive
            Task keepAlivePingTask = KeepAlivePing(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);

            // Ensure the keep-alive ping task finishes
            await keepAlivePingTask;
        }
    }

    private static async Task SendProposalSubscription(ClientWebSocket webSocket)
    {
        var proposalRequest = new
        {
            proposal = 1,
            subscribe = 1,
            amount = 10,
            basis = "payout",
            contract_type = "CALL",
            currency = "USD",
            duration = 1,
            duration_unit = "m",
            symbol = "R_100",
            barrier = "+0.1"
        };

        string requestJson = JsonSerializer.Serialize(proposalRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("Proposal subscription sent.");
    }

    private static async Task KeepAlivePing(ClientWebSocket webSocket)
    {
        while (webSocket.State == WebSocketState.Open)
        {
            await Task.Delay(pingInterval);

            var pingRequest = new { ping = 1 };
            string pingJson = JsonSerializer.Serialize(pingRequest);
            var pingBytes = Encoding.UTF8.GetBytes(pingJson);
            await webSocket.SendAsync(new ArraySegment<byte>(pingBytes), WebSocketMessageType.Text, true, CancellationToken.None);
            Console.WriteLine("Ping sent to keep connection alive.");
        }
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[1024 * 4];

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        else
        {
            string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
            var data = JsonSerializer.Deserialize<JsonElement>(response);

            if (data.TryGetProperty("error", out var error))
            {
                Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                break;
            }

            if (data.TryGetProperty("msg_type", out var msgType))
            {
                if (msgType.GetString() == "proposal")
                {
                    var proposal = data.GetProperty("proposal");

                    // Extract proposal details with type-checking
                    string longcode = proposal.GetProperty("longcode").GetString();
                    Console.WriteLine($"Details: {longcode}");

                    string displayValue = proposal.GetProperty("display_value").GetRawText();
                    Console.WriteLine($"Ask Price: {displayValue}");

                    string payout = proposal.GetProperty("payout").GetRawText();
                    Console.WriteLine($"Payout: {payout}");

                    string spot = proposal.GetProperty("spot").GetRawText();
                    Console.WriteLine($"Spot: {spot}");
                }
                else if (msgType.GetString() == "ping")
                {
                    Console.WriteLine("[Ping] Ping response received.");
                }
            }
        }
    }
}
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed
    private static readonly int pingInterval = 30000; // Ping every 30 seconds

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("WebSocket connection established.");

            // Send initial proposal subscription request
            await SendProposalSubscription(webSocket);

            // Start a task to send pings to keep connection alive
            Task keepAlivePingTask = KeepAlivePing(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);

            // Ensure the keep-alive ping task finishes
            await keepAlivePingTask;
        }
    }

    private static async Task SendProposalSubscription(ClientWebSocket webSocket)
    {
        var proposalRequest = new
        {
            proposal = 1,
            subscribe = 1,
            amount = 10,
            basis = "payout",
            contract_type = "CALL",
            currency = "USD",
            duration = 1,
            duration_unit = "m",
            symbol = "R_100",
            barrier = "+0.1"
        };

        string requestJson = JsonSerializer.Serialize(proposalRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("Proposal subscription sent.");
    }

    private static async Task KeepAlivePing(ClientWebSocket webSocket)
    {
        while (webSocket.State == WebSocketState.Open)
        {
            await Task.Delay(pingInterval);

            var pingRequest = new { ping = 1 };
            string pingJson = JsonSerializer.Serialize(pingRequest);
            var pingBytes = Encoding.UTF8.GetBytes(pingJson);
            await webSocket.SendAsync(new ArraySegment<byte>(pingBytes), WebSocketMessageType.Text, true, CancellationToken.None);
            Console.WriteLine("Ping sent to keep connection alive.");
        }
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[1024 * 4];

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        else
        {
            string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
            var data = JsonSerializer.Deserialize<JsonElement>(response);

            if (data.TryGetProperty("error", out var error))
            {
                Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                break;
            }

            if (data.TryGetProperty("msg_type", out var msgType))
            {
                if (msgType.GetString() == "proposal")
                {
                    var proposal = data.GetProperty("proposal");

                    // Extract proposal details with type-checking
                    string longcode = proposal.GetProperty("longcode").GetString();
                    Console.WriteLine($"Details: {longcode}");

                    string displayValue = proposal.GetProperty("display_value").GetRawText();
                    Console.WriteLine($"Ask Price: {displayValue}");

                    string payout = proposal.GetProperty("payout").GetRawText();
                    Console.WriteLine($"Payout: {payout}");

                    string spot = proposal.GetProperty("spot").GetRawText();
                    Console.WriteLine($"Spot: {spot}");
                }
                else if (msgType.GetString() == "ping")
                {
                    Console.WriteLine("[Ping] Ping response received.");
                }
            }
        }
    }
}
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>
#include <time.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a proposal subscription message
void send_proposal(struct lws *wsi) {
    const char *proposal_msg = "{\"proposal\": 1, \"subscribe\": 1, \"amount\": 10, \"basis\": \"payout\", \"contract_type\": \"CALL\", \"currency\": \"USD\", \"duration\": 1, \"duration_unit\": \"m\", \"symbol\": \"R_100\", \"barrier\": \"+0.1\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], proposal_msg, strlen(proposal_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(proposal_msg), LWS_WRITE_TEXT);
    lwsl_user("Proposal subscription sent\n");
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_proposal(wsi);  // Send proposal on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>
#include <time.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a proposal subscription message
void send_proposal(struct lws *wsi) {
    const char *proposal_msg = "{\"proposal\": 1, \"subscribe\": 1, \"amount\": 10, \"basis\": \"payout\", \"contract_type\": \"CALL\", \"currency\": \"USD\", \"duration\": 1, \"duration_unit\": \"m\", \"symbol\": \"R_100\", \"barrier\": \"+0.1\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], proposal_msg, strlen(proposal_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(proposal_msg), LWS_WRITE_TEXT);
    lwsl_user("Proposal subscription sent\n");
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_proposal(wsi);  // Send proposal on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
import asyncio
from deriv_api import DerivAPI
from deriv_api.subscription_manager import SubscriptionManager

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    # Initialize the SubscriptionManager
    subscription_manager = SubscriptionManager(api)

    # Define the proposal request
    proposal_request = {
        "proposal": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    }

    # Subscribe to the proposal stream
    try:
        proposal_stream = await subscription_manager.subscribe(proposal_request)
        print("Subscribed to proposal stream")

        # Handle incoming messages and print formatted proposal details
        proposal_stream.subscribe(
            on_next=lambda message: print_proposal_details(message),
            on_error=lambda e: print(f"Error: {e}"),
            on_completed=lambda: print("Subscription completed")
        )

        # Function to send a ping every 30 seconds
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop and proposal subscription concurrently
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print proposal details
def print_proposal_details(message):
    data = message.get("proposal", {})
    if data:
        print(f"Details: {data.get('longcode', 'N/A')}")
        print(f"Ask Price: {data.get('display_value', 'N/A')}")
        print(f"Payout: {data.get('payout', 'N/A')}")
        print(f"Spot: {data.get('spot', 'N/A')}")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

"""
Instructions to run this code:

1. **Install the Required Library**:
   - Ensure that `python-deriv-api` is installed. If not, install it using:
     ```
     pip install python-deriv-api
     ```
2. **Save and Run the Code**:
   - Save this code to a file, e.g., `connect.py`.
   - Run the script using:
     ```
     python connect.py
     ```
3. **Configuration**:
   - Replace the `app_id` variable with your actual Deriv app ID if needed.

This script will connect to the Deriv API WebSocket, subscribe to a proposal stream, print proposal details, and send a ping every 30 seconds to keep the connection active. 
"""
```

```text
import asyncio
from deriv_api import DerivAPI
from deriv_api.subscription_manager import SubscriptionManager

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    # Initialize the SubscriptionManager
    subscription_manager = SubscriptionManager(api)

    # Define the proposal request
    proposal_request = {
        "proposal": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    }

    # Subscribe to the proposal stream
    try:
        proposal_stream = await subscription_manager.subscribe(proposal_request)
        print("Subscribed to proposal stream")

        # Handle incoming messages and print formatted proposal details
        proposal_stream.subscribe(
            on_next=lambda message: print_proposal_details(message),
            on_error=lambda e: print(f"Error: {e}"),
            on_completed=lambda: print("Subscription completed")
        )

        # Function to send a ping every 30 seconds
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop and proposal subscription concurrently
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print proposal details
def print_proposal_details(message):
    data = message.get("proposal", {})
    if data:
        print(f"Details: {data.get('longcode', 'N/A')}")
        print(f"Ask Price: {data.get('display_value', 'N/A')}")
        print(f"Payout: {data.get('payout', 'N/A')}")
        print(f"Spot: {data.get('spot', 'N/A')}")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

"""
Instructions to run this code:

1. **Install the Required Library**:
   - Ensure that `python-deriv-api` is installed. If not, install it using:
     ```
     pip install python-deriv-api
     ```
2. **Save and Run the Code**:
   - Save this code to a file, e.g., `connect.py`.
   - Run the script using:
     ```
     python connect.py
     ```
3. **Configuration**:
   - Replace the `app_id` variable with your actual Deriv app ID if needed.

This script will connect to the Deriv API WebSocket, subscribe to a proposal stream, print proposal details, and send a ping every 30 seconds to keep the connection active. 
"""
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Define a ping interval in seconds
my $ping_interval = 30;

# Function to send a proposal subscription request
sub send_proposal {
    my $connection = shift;
    my $proposal_request = encode_json({
        proposal       => 1,
        subscribe      => 1,
        amount         => 10,
        basis          => 'payout',
        contract_type  => 'CALL',
        currency       => 'USD',
        duration       => 1,
        duration_unit  => 'm',
        symbol         => 'R_100',
        barrier        => '+0.1'
    });
    $connection->send($proposal_request);
    say "Proposal subscription sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "WebSocket connection established.";

    # Set up a repeating timer to send ping every 30 seconds
    my $ping_timer = AnyEvent->timer(
        after    => $ping_interval,
        interval => $ping_interval,
        cb       => sub {
            $connection->send(encode_json({ ping => 1 }));
            say "Ping sent to keep connection alive.";
        }
    );

    # Send the initial proposal subscription
    send_proposal($connection);

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;
        my $data = decode_json($message->body);

        # Handle errors
        if ($data->{error}) {
            say "[Error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle proposal messages
        if ($data->{msg_type} && $data->{msg_type} eq 'proposal') {
            my $proposal = $data->{proposal};
            say "Details: $proposal->{longcode}";
            say "Ask Price: $proposal->{display_value}";
            say "Payout: $proposal->{payout}";
            say "Spot: $proposal->{spot}";
        } elsif ($data->{msg_type} && $data->{msg_type} eq 'ping') {
            say "[Ping] Ping response received.";
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
        $ping_timer = undef;  # Stop the ping timer
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Define a ping interval in seconds
my $ping_interval = 30;

# Function to send a proposal subscription request
sub send_proposal {
    my $connection = shift;
    my $proposal_request = encode_json({
        proposal       => 1,
        subscribe      => 1,
        amount         => 10,
        basis          => 'payout',
        contract_type  => 'CALL',
        currency       => 'USD',
        duration       => 1,
        duration_unit  => 'm',
        symbol         => 'R_100',
        barrier        => '+0.1'
    });
    $connection->send($proposal_request);
    say "Proposal subscription sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "WebSocket connection established.";

    # Set up a repeating timer to send ping every 30 seconds
    my $ping_timer = AnyEvent->timer(
        after    => $ping_interval,
        interval => $ping_interval,
        cb       => sub {
            $connection->send(encode_json({ ping => 1 }));
            say "Ping sent to keep connection alive.";
        }
    );

    # Send the initial proposal subscription
    send_proposal($connection);

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;
        my $data = decode_json($message->body);

        # Handle errors
        if ($data->{error}) {
            say "[Error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle proposal messages
        if ($data->{msg_type} && $data->{msg_type} eq 'proposal') {
            my $proposal = $data->{proposal};
            say "Details: $proposal->{longcode}";
            say "Ask Price: $proposal->{display_value}";
            say "Payout: $proposal->{payout}";
            say "Spot: $proposal->{spot}";
        } elsif ($data->{msg_type} && $data->{msg_type} eq 'ping') {
            say "[Ping] Ping response received.";
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
        $ping_timer = undef;  # Stop the ping timer
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

**Content:**
Follow these steps to maintain a live WebSocket connection with the Deriv API:

Import the Deriv API library

Import the DerivAPIBasic library, which provides an interface to interact with the Deriv WebSocket API:

import DerivAPIBasic from 'https://cdn.skypack.dev/@deriv/deriv-api/dist/DerivAPIBasic';

Establish a WebSocket connection

Create a WebSocket connection using your app_id and the API URL:

(wss://ws.derivws.com/websockets/v3?app_id=${app_id}).

This connection will be used to send and receive messages from the Deriv API.

const connection = new WebSocket(wss://ws.derivws.com/websockets/v3?app_id=${app_id});

Create an API object

Create an instance of DerivAPIBasic, passing the WebSocket connection as a parameter.

This object interacts with the API, such as subscribing to proposals and sending pings.

const api = new DerivAPIBasic({ connection });

Send a proposal subscription

The proposal() function subscribes to a proposal and sends details such as the trade amount, cur...

---

### Get contracts for a symbol
**URL:** https://developers.deriv.com/docs/get-contracts-for-a-symbol

**Data Fetching Examples:**
```text
DerivAPIBasic
```

```text
app_id
```

```text
DerivAPIBasic
```

```text
R_50
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the contracts for symbol response
const handleContractsForSymbolResponse = async (response) => {
  const data = JSON.parse(response.data);

  // Check for errors in the response
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'contracts_for', log the contracts information
  if (data.msg_type === 'contracts_for') {
    const contractsInfo = data.contracts_for;
    console.log('Contracts for Symbol:', contractsInfo);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleContractsForSymbolResponse);
};

// Function to request contracts for a specific symbol
const getContractsForSymbol = async () => {
  const contracts_for_symbol_request = {
    contracts_for: 'R_50',   // Specify the symbol
    currency: 'USD',
    landing_company: 'svg',
    product_type: 'basic',
  };

  connection.addEventListener('message', handleContractsForSymbolResponse); // Add event listener
  await api.contractsFor(contracts_for_symbol_request); // Send the contracts request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const contracts_for_symbol_button = document.querySelector('#contractsForSymbol');
  if (contracts_for_symbol_button) {
    contracts_for_symbol_button.addEventListener('click', getContractsForSymbol);
  }
} else {
  // If running in Node.js, directly call the function
  getContractsForSymbol();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `contracts_for_symbol.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node contracts_for_symbol.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="contractsForSymbol">Get Contracts for Symbol</button>`
 * - Open the HTML file in a browser, and click the button to retrieve contracts for the symbol.
 */
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the contracts for symbol response
const handleContractsForSymbolResponse = async (response) => {
  const data = JSON.parse(response.data);

  // Check for errors in the response
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'contracts_for', log the contracts information
  if (data.msg_type === 'contracts_for') {
    const contractsInfo = data.contracts_for;
    console.log('Contracts for Symbol:', contractsInfo);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleContractsForSymbolResponse);
};

// Function to request contracts for a specific symbol
const getContractsForSymbol = async () => {
  const contracts_for_symbol_request = {
    contracts_for: 'R_50',   // Specify the symbol
    currency: 'USD',
    landing_company: 'svg',
    product_type: 'basic',
  };

  connection.addEventListener('message', handleContractsForSymbolResponse); // Add event listener
  await api.contractsFor(contracts_for_symbol_request); // Send the contracts request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const contracts_for_symbol_button = document.querySelector('#contractsForSymbol');
  if (contracts_for_symbol_button) {
    contracts_for_symbol_button.addEventListener('click', getContractsForSymbol);
  }
} else {
  // If running in Node.js, directly call the function
  getContractsForSymbol();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `contracts_for_symbol.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node contracts_for_symbol.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="contractsForSymbol">Get Contracts for Symbol</button>`
 * - Open the HTML file in a browser, and click the button to retrieve contracts for the symbol.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send contracts for symbol request
                    JsonObject contractsForSymbolRequest = new JsonObject();
                    contractsForSymbolRequest.addProperty("contracts_for", "R_50"); // Specify symbol here
                    contractsForSymbolRequest.addProperty("currency", "USD");
                    contractsForSymbolRequest.addProperty("landing_company", "svg");
                    contractsForSymbolRequest.addProperty("product_type", "basic");
                    send(contractsForSymbolRequest.toString());
                    System.out.println("[sent] Contracts for symbol request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("contracts_for".equals(data.get("msg_type").getAsString())) {
                        JsonObject contractsFor = data.getAsJsonObject("contracts_for");
                        System.out.println("Contracts for Symbol: " + contractsFor);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send contracts for symbol request
                    JsonObject contractsForSymbolRequest = new JsonObject();
                    contractsForSymbolRequest.addProperty("contracts_for", "R_50"); // Specify symbol here
                    contractsForSymbolRequest.addProperty("currency", "USD");
                    contractsForSymbolRequest.addProperty("landing_company", "svg");
                    contractsForSymbolRequest.addProperty("product_type", "basic");
                    send(contractsForSymbolRequest.toString());
                    System.out.println("[sent] Contracts for symbol request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("contracts_for".equals(data.get("msg_type").getAsString())) {
                        JsonObject contractsFor = data.getAsJsonObject("contracts_for");
                        System.out.println("Contracts for Symbol: " + contractsFor);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.
 */
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a contracts for symbol request
sub send_contracts_for_symbol {
    my $connection = shift;
    my $contracts_for_request = encode_json({
        contracts_for => 'R_50',    # Symbol for which contracts are requested
        currency => 'USD',          # Set currency to USD
        landing_company => 'svg',   # Landing company (e.g., svg)
        product_type => 'basic'     # Product type is set to 'basic'
    });
    $connection->send($contracts_for_request);
    say "[request] Contracts for symbol request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send the contracts for symbol request
    send_contracts_for_symbol($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Process contracts_for response
        if ($data->{msg_type} && $data->{msg_type} eq 'contracts_for') {
            say "[contracts] Contracts for Symbol (R_50):";
            foreach my $contract (@{$data->{contracts_for}{available}}) {
                my $contract_type            = $contract->{contract_type} // "N/A";
                my $contract_display         = $contract->{contract_display} // "N/A";
                my $contract_category_display = $contract->{contract_category_display} // "N/A";
                my $market                   = $contract->{market} // "N/A";
                my $submarket                = $contract->{submarket} // "N/A";
                my $expiry_type              = $contract->{expiry_type} // "N/A";
                my $min_duration             = $contract->{min_contract_duration} // "N/A";
                my $max_duration             = $contract->{max_contract_duration} // "N/A";
                my $barrier                  = $contract->{barrier} // "N/A";
                my $sentiment                = $contract->{sentiment} // "N/A";

                # Print contract details
                say "  - Contract Type: $contract_type";
                say "    - Display Name: $contract_display";
                say "    - Category: $contract_category_display";
                say "    - Market: $market";
                say "    - Submarket: $submarket";
                say "    - Expiry Type: $expiry_type";
                say "    - Min Duration: $min_duration";
                say "    - Max Duration: $max_duration";
                say "    - Barrier: $barrier";
                say "    - Sentiment: $sentiment";
                say "    --------------------";
            }
            say "[contracts] End of Contracts Response.";
            $connection->close;  # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `contracts_for_symbol.pl`.
# 4. Run the script using the command:
#      perl contracts_for_symbol.pl
# This script will connect to the Deriv WebSocket API, request contracts for a specific symbol, and print the details.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a contracts for symbol request
sub send_contracts_for_symbol {
    my $connection = shift;
    my $contracts_for_request = encode_json({
        contracts_for => 'R_50',    # Symbol for which contracts are requested
        currency => 'USD',          # Set currency to USD
        landing_company => 'svg',   # Landing company (e.g., svg)
        product_type => 'basic'     # Product type is set to 'basic'
    });
    $connection->send($contracts_for_request);
    say "[request] Contracts for symbol request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send the contracts for symbol request
    send_contracts_for_symbol($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Process contracts_for response
        if ($data->{msg_type} && $data->{msg_type} eq 'contracts_for') {
            say "[contracts] Contracts for Symbol (R_50):";
            foreach my $contract (@{$data->{contracts_for}{available}}) {
                my $contract_type            = $contract->{contract_type} // "N/A";
                my $contract_display         = $contract->{contract_display} // "N/A";
                my $contract_category_display = $contract->{contract_category_display} // "N/A";
                my $market                   = $contract->{market} // "N/A";
                my $submarket                = $contract->{submarket} // "N/A";
                my $expiry_type              = $contract->{expiry_type} // "N/A";
                my $min_duration             = $contract->{min_contract_duration} // "N/A";
                my $max_duration             = $contract->{max_contract_duration} // "N/A";
                my $barrier                  = $contract->{barrier} // "N/A";
                my $sentiment                = $contract->{sentiment} // "N/A";

                # Print contract details
                say "  - Contract Type: $contract_type";
                say "    - Display Name: $contract_display";
                say "    - Category: $contract_category_display";
                say "    - Market: $market";
                say "    - Submarket: $submarket";
                say "    - Expiry Type: $expiry_type";
                say "    - Min Duration: $min_duration";
                say "    - Max Duration: $max_duration";
                say "    - Barrier: $barrier";
                say "    - Sentiment: $sentiment";
                say "    --------------------";
            }
            say "[contracts] End of Contracts Response.";
            $connection->close;  # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `contracts_for_symbol.pl`.
# 4. Run the script using the command:
#      perl contracts_for_symbol.pl
# This script will connect to the Deriv WebSocket API, request contracts for a specific symbol, and print the details.
```

```text
<?php
// Include necessary libraries (you may need to install Ratchet via Composer)
require 'vendor/autoload.php';

use Ratchet\Client\WebSocket;
use Ratchet\Client\Connector;
use React\EventLoop\Factory as LoopFactory;
use React\Socket\Connector as ReactConnector;

// Define the app_id (replace 'your_app_id' with your actual app_id)
$app_id = 'your_app_id';

// Create an event loop to handle WebSocket events
$loop = LoopFactory::create();
$reactConnector = new ReactConnector($loop);
$connector = new Connector($loop, $reactConnector);

// Define the request object for contracts_for API call
$contracts_for_symbol_request = [
    'contracts_for'   => 'R_50',  // Symbol for which contracts are requested
    'currency'        => 'USD',   // Set currency to USD
    'landing_company' => 'svg',   // Landing company
    'product_type'    => 'basic', // Product type is set to 'basic'
];

// Connect to the Deriv WebSocket API
$connector("wss://ws.derivws.com/websockets/v3?app_id=$app_id")
    ->then(function(WebSocket $conn) use ($contracts_for_symbol_request, $loop) {
        // Send the contracts_for request to the WebSocket server
        $conn->send(json_encode($contracts_for_symbol_request));
        echo "Request sent: " . json_encode($contracts_for_symbol_request) . PHP_EOL;

        // Handle messages received from the server
        $conn->on('message', function($message) use ($conn, $loop) {
            // Decode the received message (JSON format)
            $data = json_decode($message, true);

            // Check if there is an error in the response
            if (isset($data['error'])) {
                echo "Error: " . $data['error']['message'] . PHP_EOL;
                $conn->close();
                $loop->stop(); // Stop the event loop
            }

            // If the response is for 'contracts_for', print the contract information
            if (isset($data['msg_type']) && $data['msg_type'] === 'contracts_for') {
                echo "Contracts for symbol: " . json_encode($data['contracts_for'], JSON_PRETTY_PRINT) . PHP_EOL;
                $conn->close(); // Close the WebSocket connection
                $loop->stop();  // Stop the event loop
            }
        });

        // Handle WebSocket connection closing
        $conn->on('close', function($code = null, $reason = null) use ($loop) {
            echo "Connection closed ({$code} - {$reason})" . PHP_EOL;
            $loop->stop(); // Stop the event loop when the connection is closed
        });
    }, function($e) use ($loop) {
        // Handle connection errors
        echo "Could not connect: {$e->getMessage()}" . PHP_EOL;
        $loop->stop();
    });

// Run the event loop to keep the connection alive
$loop->run();
```

```text
<?php
// Include necessary libraries (you may need to install Ratchet via Composer)
require 'vendor/autoload.php';

use Ratchet\Client\WebSocket;
use Ratchet\Client\Connector;
use React\EventLoop\Factory as LoopFactory;
use React\Socket\Connector as ReactConnector;

// Define the app_id (replace 'your_app_id' with your actual app_id)
$app_id = 'your_app_id';

// Create an event loop to handle WebSocket events
$loop = LoopFactory::create();
$reactConnector = new ReactConnector($loop);
$connector = new Connector($loop, $reactConnector);

// Define the request object for contracts_for API call
$contracts_for_symbol_request = [
    'contracts_for'   => 'R_50',  // Symbol for which contracts are requested
    'currency'        => 'USD',   // Set currency to USD
    'landing_company' => 'svg',   // Landing company
    'product_type'    => 'basic', // Product type is set to 'basic'
];

// Connect to the Deriv WebSocket API
$connector("wss://ws.derivws.com/websockets/v3?app_id=$app_id")
    ->then(function(WebSocket $conn) use ($contracts_for_symbol_request, $loop) {
        // Send the contracts_for request to the WebSocket server
        $conn->send(json_encode($contracts_for_symbol_request));
        echo "Request sent: " . json_encode($contracts_for_symbol_request) . PHP_EOL;

        // Handle messages received from the server
        $conn->on('message', function($message) use ($conn, $loop) {
            // Decode the received message (JSON format)
            $data = json_decode($message, true);

            // Check if there is an error in the response
            if (isset($data['error'])) {
                echo "Error: " . $data['error']['message'] . PHP_EOL;
                $conn->close();
                $loop->stop(); // Stop the event loop
            }

            // If the response is for 'contracts_for', print the contract information
            if (isset($data['msg_type']) && $data['msg_type'] === 'contracts_for') {
                echo "Contracts for symbol: " . json_encode($data['contracts_for'], JSON_PRETTY_PRINT) . PHP_EOL;
                $conn->close(); // Close the WebSocket connection
                $loop->stop();  // Stop the event loop
            }
        });

        // Handle WebSocket connection closing
        $conn->on('close', function($code = null, $reason = null) use ($loop) {
            echo "Connection closed ({$code} - {$reason})" . PHP_EOL;
            $loop->stop(); // Stop the event loop when the connection is closed
        });
    }, function($e) use ($loop) {
        // Handle connection errors
        echo "Could not connect: {$e->getMessage()}" . PHP_EOL;
        $loop->stop();
    });

// Run the event loop to keep the connection alive
$loop->run();
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a contracts for symbol request
        contracts_for_symbol_request = {
            "contracts_for": "R_50",
            "currency": "USD",
            "landing_company": "svg",
            "product_type": "basic"
        }
        response = await api.send(contracts_for_symbol_request)
        print("Contracts for symbol request sent")

        # Process the response and print contract details
        print_contracts_for_symbol(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print contract details for a symbol
def print_contracts_for_symbol(response):
    data = response.get("contracts_for", {})
    if data:
        print("Contracts for Symbol (R_50):")
        contracts = data.get("available", [])
        for contract in contracts:
            print(f"  - Contract Type: {contract.get('contract_type')}")
            print(f"    - Display Name: {contract.get('contract_display')}")
            print(f"    - Category: {contract.get('contract_category_display')}")
            print(f"    - Market: {contract.get('market')}")
            print(f"    - Submarket: {contract.get('submarket')}")
            print(f"    - Expiry Type: {contract.get('expiry_type')}")
            print(f"    - Min Duration: {contract.get('min_contract_duration')}")
            print(f"    - Max Duration: {contract.get('max_contract_duration')}")
            print(f"    - Barrier: {contract.get('barrier')}")
            print(f"    - Sentiment: {contract.get('sentiment')}")
            print("    --------------------")
    print("[End of Contracts for Symbol Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `contracts_for_symbol_client.py`.
# 4. Run the code from the command line:
#      python contracts_for_symbol_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request contract details for the symbol "R_50", and send pings every 30 seconds to keep the connection alive.
# The response includes important contract details such as contract type, category, market, durations, and barriers.
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a contracts for symbol request
        contracts_for_symbol_request = {
            "contracts_for": "R_50",
            "currency": "USD",
            "landing_company": "svg",
            "product_type": "basic"
        }
        response = await api.send(contracts_for_symbol_request)
        print("Contracts for symbol request sent")

        # Process the response and print contract details
        print_contracts_for_symbol(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print contract details for a symbol
def print_contracts_for_symbol(response):
    data = response.get("contracts_for", {})
    if data:
        print("Contracts for Symbol (R_50):")
        contracts = data.get("available", [])
        for contract in contracts:
            print(f"  - Contract Type: {contract.get('contract_type')}")
            print(f"    - Display Name: {contract.get('contract_display')}")
            print(f"    - Category: {contract.get('contract_category_display')}")
            print(f"    - Market: {contract.get('market')}")
            print(f"    - Submarket: {contract.get('submarket')}")
            print(f"    - Expiry Type: {contract.get('expiry_type')}")
            print(f"    - Min Duration: {contract.get('min_contract_duration')}")
            print(f"    - Max Duration: {contract.get('max_contract_duration')}")
            print(f"    - Barrier: {contract.get('barrier')}")
            print(f"    - Sentiment: {contract.get('sentiment')}")
            print("    --------------------")
    print("[End of Contracts for Symbol Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `contracts_for_symbol_client.py`.
# 4. Run the code from the command line:
#      python contracts_for_symbol_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request contract details for the symbol "R_50", and send pings every 30 seconds to keep the connection alive.
# The response includes important contract details such as contract type, category, market, durations, and barriers.
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Contracts for symbol request JSON
    let contracts_for_symbol_request = json!({
        "contracts_for": "R_50",
        "currency": "USD",
        "landing_company": "svg",
        "product_type": "basic"
    });

    // Clone `socket` to send the contracts for symbol request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(contracts_for_symbol_request.to_string())).await.is_ok() {
            println!("[request] Contracts for symbol request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "contracts_for" {
                        println!("Contracts for Symbol (R_50):");
                        if let Some(contracts) = data["contracts_for"]["available"].as_array() {
                            for contract in contracts {
                                println!("  - Contract Type: {}", contract["contract_type"]);
                                println!("    - Display Name: {}", contract["contract_display"]);
                                println!("    - Category: {}", contract["contract_category_display"]);
                                println!("    - Market: {}", contract["market"]);
                                println!("    - Submarket: {}", contract["submarket"]);
                                println!("    - Expiry Type: {}", contract["expiry_type"]);
                                println!("    - Min Duration: {}", contract["min_contract_duration"]);
                                println!("    - Max Duration: {}", contract["max_contract_duration"]);
                                println!("    - Barrier: {}", contract["barrier"]);
                                println!("    - Sentiment: {}", contract["sentiment"]);
                                println!("    --------------------");
                            }
                        }
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request contract details for the symbol "R_50", and print out important contract details such as type, category, market, submarket, expiry type, duration, and barrier information.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Contracts for symbol request JSON
    let contracts_for_symbol_request = json!({
        "contracts_for": "R_50",
        "currency": "USD",
        "landing_company": "svg",
        "product_type": "basic"
    });

    // Clone `socket` to send the contracts for symbol request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(contracts_for_symbol_request.to_string())).await.is_ok() {
            println!("[request] Contracts for symbol request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "contracts_for" {
                        println!("Contracts for Symbol (R_50):");
                        if let Some(contracts) = data["contracts_for"]["available"].as_array() {
                            for contract in contracts {
                                println!("  - Contract Type: {}", contract["contract_type"]);
                                println!("    - Display Name: {}", contract["contract_display"]);
                                println!("    - Category: {}", contract["contract_category_display"]);
                                println!("    - Market: {}", contract["market"]);
                                println!("    - Submarket: {}", contract["submarket"]);
                                println!("    - Expiry Type: {}", contract["expiry_type"]);
                                println!("    - Min Duration: {}", contract["min_contract_duration"]);
                                println!("    - Max Duration: {}", contract["max_contract_duration"]);
                                println!("    - Barrier: {}", contract["barrier"]);
                                println!("    - Sentiment: {}", contract["sentiment"]);
                                println!("    --------------------");
                            }
                        }
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request contract details for the symbol "R_50", and print out important contract details such as type, category, market, submarket, expiry type, duration, and barrier information.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a contracts for symbol request
void send_contracts_for_symbol_request(struct lws *wsi) {
    const char *contracts_for_symbol_msg = "{\"contracts_for\": \"R_50\", \"currency\": \"USD\", \"landing_company\": \"svg\", \"product_type\": \"basic\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], contracts_for_symbol_msg, strlen(contracts_for_symbol_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(contracts_for_symbol_msg), LWS_WRITE_TEXT);
    lwsl_user("Contracts for symbol request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_contracts_for_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "contracts_for"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "contracts_for") == 0) {
        json_t *contracts_for = json_object_get(root, "contracts_for");
        json_t *available_contracts = json_object_get(contracts_for, "available");

        printf("Contracts for Symbol (R_50):\n");
        size_t index;
        json_t *contract;
        json_array_foreach(available_contracts, index, contract) {
            const char *contract_type = json_string_value(json_object_get(contract, "contract_type"));
            const char *display_name = json_string_value(json_object_get(contract, "contract_display"));
            const char *category = json_string_value(json_object_get(contract, "contract_category_display"));
            const char *market = json_string_value(json_object_get(contract, "market"));
            const char *submarket = json_string_value(json_object_get(contract, "submarket"));
            const char *expiry_type = json_string_value(json_object_get(contract, "expiry_type"));
            const char *min_duration = json_string_value(json_object_get(contract, "min_contract_duration"));
            const char *max_duration = json_string_value(json_object_get(contract, "max_contract_duration"));

            printf("  - Contract Type: %s\n", contract_type);
            printf("    - Display Name: %s\n", display_name);
            printf("    - Category: %s\n", category);
            printf("    - Market: %s\n", market);
            printf("    - Submarket: %s\n", submarket);
            printf("    - Expiry Type: %s\n", expiry_type);
            printf("    - Min Duration: %s\n", min_duration);
            printf("    - Max Duration: %s\n", max_duration);
            printf("    --------------------\n");
        }
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_contracts_for_symbol_request(wsi);  // Send contracts for symbol request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_contracts_for_symbol_request(wsi);  // Periodically request contracts
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_contracts_for_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a contracts for symbol request
void send_contracts_for_symbol_request(struct lws *wsi) {
    const char *contracts_for_symbol_msg = "{\"contracts_for\": \"R_50\", \"currency\": \"USD\", \"landing_company\": \"svg\", \"product_type\": \"basic\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], contracts_for_symbol_msg, strlen(contracts_for_symbol_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(contracts_for_symbol_msg), LWS_WRITE_TEXT);
    lwsl_user("Contracts for symbol request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_contracts_for_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "contracts_for"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "contracts_for") == 0) {
        json_t *contracts_for = json_object_get(root, "contracts_for");
        json_t *available_contracts = json_object_get(contracts_for, "available");

        printf("Contracts for Symbol (R_50):\n");
        size_t index;
        json_t *contract;
        json_array_foreach(available_contracts, index, contract) {
            const char *contract_type = json_string_value(json_object_get(contract, "contract_type"));
            const char *display_name = json_string_value(json_object_get(contract, "contract_display"));
            const char *category = json_string_value(json_object_get(contract, "contract_category_display"));
            const char *market = json_string_value(json_object_get(contract, "market"));
            const char *submarket = json_string_value(json_object_get(contract, "submarket"));
            const char *expiry_type = json_string_value(json_object_get(contract, "expiry_type"));
            const char *min_duration = json_string_value(json_object_get(contract, "min_contract_duration"));
            const char *max_duration = json_string_value(json_object_get(contract, "max_contract_duration"));

            printf("  - Contract Type: %s\n", contract_type);
            printf("    - Display Name: %s\n", display_name);
            printf("    - Category: %s\n", category);
            printf("    - Market: %s\n", market);
            printf("    - Submarket: %s\n", submarket);
            printf("    - Expiry Type: %s\n", expiry_type);
            printf("    - Min Duration: %s\n", min_duration);
            printf("    - Max Duration: %s\n", max_duration);
            printf("    --------------------\n");
        }
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_contracts_for_symbol_request(wsi);  // Send contracts for symbol request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_contracts_for_symbol_request(wsi);  // Periodically request contracts
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_contracts_for_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send contracts for symbol request
            await SendContractsForSymbolRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendContractsForSymbolRequest(ClientWebSocket webSocket)
    {
        var contractsForSymbolRequest = new
        {
            contracts_for = "R_50",
            currency = "USD",
            landing_company = "svg",
            product_type = "basic"
        };

        string requestJson = JsonSerializer.Serialize(contractsForSymbolRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[request] Contracts for symbol request sent.");
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[8192];
    var messageBuilder = new StringBuilder();

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            break;
        }

        messageBuilder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));

        if (result.EndOfMessage)
        {
            try
            {
                var data = JsonDocument.Parse(messageBuilder.ToString()).RootElement;
                if (data.TryGetProperty("error", out var error))
                {
                    Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                    break;
                }

                if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "contracts_for")
                {
                    Console.WriteLine("Contracts for Symbol (R_50):");
                    foreach (var contract in data.GetProperty("contracts_for").GetProperty("available").EnumerateArray())
                    {
                        Console.WriteLine($"  - Contract Type: {contract.GetProperty("contract_type").GetString()}");
                        Console.WriteLine($"    - Display Name: {contract.GetProperty("contract_display").GetString()}");
                        Console.WriteLine($"    - Category: {contract.GetProperty("contract_category_display").GetString()}");
                        Console.WriteLine($"    - Market: {contract.GetProperty("market").GetString()}");
                        Console.WriteLine($"    - Submarket: {contract.GetProperty("submarket").GetString()}");
                        Console.WriteLine($"    - Expiry Type: {contract.GetProperty("expiry_type").GetString()}");

                        // Check for optional properties with safe access
                        Console.WriteLine($"    - Min Duration: {(contract.TryGetProperty("min_contract_duration", out var minDuration) ? minDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Max Duration: {(contract.TryGetProperty("max_contract_duration", out var maxDuration) ? maxDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Barrier: {(contract.TryGetProperty("barrier", out var barrier) ? barrier.GetString() : "N/A")}");
                        Console.WriteLine($"    - Sentiment: {(contract.TryGetProperty("sentiment", out var sentiment) ? sentiment.GetString() : "N/A")}");
                        Console.WriteLine("    --------------------");
                    }
                }

                messageBuilder.Clear();
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"[Error] Failed to parse JSON message: {ex.Message}");
            }
        }
    }
}


}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send contracts for symbol request
            await SendContractsForSymbolRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendContractsForSymbolRequest(ClientWebSocket webSocket)
    {
        var contractsForSymbolRequest = new
        {
            contracts_for = "R_50",
            currency = "USD",
            landing_company = "svg",
            product_type = "basic"
        };

        string requestJson = JsonSerializer.Serialize(contractsForSymbolRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[request] Contracts for symbol request sent.");
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[8192];
    var messageBuilder = new StringBuilder();

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            break;
        }

        messageBuilder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));

        if (result.EndOfMessage)
        {
            try
            {
                var data = JsonDocument.Parse(messageBuilder.ToString()).RootElement;
                if (data.TryGetProperty("error", out var error))
                {
                    Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                    break;
                }

                if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "contracts_for")
                {
                    Console.WriteLine("Contracts for Symbol (R_50):");
                    foreach (var contract in data.GetProperty("contracts_for").GetProperty("available").EnumerateArray())
                    {
                        Console.WriteLine($"  - Contract Type: {contract.GetProperty("contract_type").GetString()}");
                        Console.WriteLine($"    - Display Name: {contract.GetProperty("contract_display").GetString()}");
                        Console.WriteLine($"    - Category: {contract.GetProperty("contract_category_display").GetString()}");
                        Console.WriteLine($"    - Market: {contract.GetProperty("market").GetString()}");
                        Console.WriteLine($"    - Submarket: {contract.GetProperty("submarket").GetString()}");
                        Console.WriteLine($"    - Expiry Type: {contract.GetProperty("expiry_type").GetString()}");

                        // Check for optional properties with safe access
                        Console.WriteLine($"    - Min Duration: {(contract.TryGetProperty("min_contract_duration", out var minDuration) ? minDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Max Duration: {(contract.TryGetProperty("max_contract_duration", out var maxDuration) ? maxDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Barrier: {(contract.TryGetProperty("barrier", out var barrier) ? barrier.GetString() : "N/A")}");
                        Console.WriteLine($"    - Sentiment: {(contract.TryGetProperty("sentiment", out var sentiment) ? sentiment.GetString() : "N/A")}");
                        Console.WriteLine("    --------------------");
                    }
                }

                messageBuilder.Clear();
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"[Error] Failed to parse JSON message: {ex.Message}");
            }
        }
    }
}


}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//replace with your app_id
	readLimit    = 65536 // Set a higher read limit, e.g., 64 KB
)

type ContractsForRequest struct {
	ContractsFor   string `json:"contracts_for"`
	Currency       string `json:"currency"`
	LandingCompany string `json:"landing_company"`
	ProductType    string `json:"product_type"`
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("[status] WebSocket connection established.")

	// Set a higher read limit
	conn.SetReadLimit(readLimit)

	// Send contracts for symbol request
	err = sendContractsForSymbolRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send contracts for symbol request: %v", err)
	}

	// Handle incoming messages
	handleResponses(ctx, conn)
}

func sendContractsForSymbolRequest(ctx context.Context, conn *websocket.Conn) error {
	contractsRequest := ContractsForRequest{
		ContractsFor:   "R_50",
		Currency:       "USD",
		LandingCompany: "svg",
		ProductType:    "basic",
	}
	fmt.Println("[request] Sending contracts for symbol request...")
	return wsjson.Write(ctx, conn, contractsRequest)
}

func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}

		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		msgType := response["msg_type"]
		if msgType == "contracts_for" {
			contracts := response["contracts_for"].(map[string]interface{})["available"].([]interface{})
			fmt.Println("Contracts for Symbol (R_50):")
			for _, contract := range contracts {
				contractMap := contract.(map[string]interface{})
				fmt.Printf("  - Contract Type: %v\n", contractMap["contract_type"])
				fmt.Printf("    - Display Name: %v\n", contractMap["contract_display"])
				fmt.Printf("    - Category: %v\n", contractMap["contract_category_display"])
				fmt.Printf("    - Market: %v\n", contractMap["market"])
				fmt.Printf("    - Submarket: %v\n", contractMap["submarket"])
				fmt.Printf("    - Expiry Type: %v\n", contractMap["expiry_type"])
				fmt.Printf("    - Min Duration: %v\n", contractMap["min_contract_duration"])
				fmt.Printf("    - Max Duration: %v\n", contractMap["max_contract_duration"])
				fmt.Printf("    - Barrier: %v\n", contractMap["barrier"])
				fmt.Printf("    - Sentiment: %v\n", contractMap["sentiment"])
				fmt.Println("    --------------------")
			}
		} else {
			fmt.Printf("Received message: %v\n", response)
		}
	}
}
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//replace with your app_id
	readLimit    = 65536 // Set a higher read limit, e.g., 64 KB
)

type ContractsForRequest struct {
	ContractsFor   string `json:"contracts_for"`
	Currency       string `json:"currency"`
	LandingCompany string `json:"landing_company"`
	ProductType    string `json:"product_type"`
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("[status] WebSocket connection established.")

	// Set a higher read limit
	conn.SetReadLimit(readLimit)

	// Send contracts for symbol request
	err = sendContractsForSymbolRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send contracts for symbol request: %v", err)
	}

	// Handle incoming messages
	handleResponses(ctx, conn)
}

func sendContractsForSymbolRequest(ctx context.Context, conn *websocket.Conn) error {
	contractsRequest := ContractsForRequest{
		ContractsFor:   "R_50",
		Currency:       "USD",
		LandingCompany: "svg",
		ProductType:    "basic",
	}
	fmt.Println("[request] Sending contracts for symbol request...")
	return wsjson.Write(ctx, conn, contractsRequest)
}

func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}

		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		msgType := response["msg_type"]
		if msgType == "contracts_for" {
			contracts := response["contracts_for"].(map[string]interface{})["available"].([]interface{})
			fmt.Println("Contracts for Symbol (R_50):")
			for _, contract := range contracts {
				contractMap := contract.(map[string]interface{})
				fmt.Printf("  - Contract Type: %v\n", contractMap["contract_type"])
				fmt.Printf("    - Display Name: %v\n", contractMap["contract_display"])
				fmt.Printf("    - Category: %v\n", contractMap["contract_category_display"])
				fmt.Printf("    - Market: %v\n", contractMap["market"])
				fmt.Printf("    - Submarket: %v\n", contractMap["submarket"])
				fmt.Printf("    - Expiry Type: %v\n", contractMap["expiry_type"])
				fmt.Printf("    - Min Duration: %v\n", contractMap["min_contract_duration"])
				fmt.Printf("    - Max Duration: %v\n", contractMap["max_contract_duration"])
				fmt.Printf("    - Barrier: %v\n", contractMap["barrier"])
				fmt.Printf("    - Sentiment: %v\n", contractMap["sentiment"])
				fmt.Println("    --------------------")
			}
		} else {
			fmt.Printf("Received message: %v\n", response)
		}
	}
}
```

**Content:**
Follow these steps to retrieve the list of available contracts, along with the latest barrier and duration limits for each contract, for a given symbol using the Deriv API:

Import Deriv API: Import the DerivAPIBasic library from Skypack CDN.
WebSocket connection: Create a WebSocket connection to the Deriv API using your app_id.
API initialization: Initialize the DerivAPIBasic instance with the WebSocket connection.
Request object: Define a request object to fetch contracts for a specific symbol (e.g., R_50).
Response handling: Handle the API response:
Parse the data and log any errors.
If the response contains contract data, log it.
Remove the event listener after the response is received.
Trigger request: On a button click, the function sends the request to the API to get the contracts for the symbol.
JavaScript
Java
Perl
PHP
Python
Rust
Swift
C
C#
Go
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app...

---

## üë§ 5. ACCOUNT MANAGEMENT

### Account setup
**URL:** https://developers.deriv.com/docs/account-setup

**Account Operations:**
```text
buy
```

```text
proposal
```

```text
buy
```

```text
proposal
```

```text
https://example.com
```

```text
/verify
```

```text
https://example.com/verify
```

**Details:**
Create a Deriv account
Visit api.deriv.com
Click Sign Up on the top right corner of the page.
Provide your Email Address.
Check your inbox for a verification email and click the link to confirm your account.
After verifying your email, provide your Country of residence, Citizenship, and create a Password.
Your Demo account is now active ‚Äî you can start building and testing your apps right away.
To create a Real account, click Complete my profile.
Choose your Account Currency, fill in your Personal and Address details, and accept the Terms of use to proceed.
Your Real account is now active ‚Äî you‚Äôre eligible to earn markup commissions on your app.
üìò

Note:

If your country of residence is one of the supported countries for Wallets, you will also receive a virtual Wallet (demo) account. Once you complete the real account creation process, a real Wallet account will also be created, based on the currency you select.

Attention Developers ‚Äì Wallet Accounts Can‚Äôt Trade!
If your account type...

---

### Authentication
**URL:** https://developers.deriv.com/docs/authentication

**Account Operations:**
```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID
```

```text
YOUR_APP_ID
```

```text
https://oauth.deriv.com/oauth2/authorize?app_id=YOUR_APP_ID&affiliate_token=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
FB58247C-6B33-4677-A6AD-168C2D72323C
```

```text
dynamicworks
```

```text
jqd7qq_iBB18zg8lBvFoLmNd7ZgqdRLk
```

```text
myaffiliates
```

```text
t
```

```text
utm_campaign
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://hub.deriv.com/tradershub/signup?t=YOUR_TOKEN&utm_campaign=YOUR_CAMPAIGN
```

```text
https://[YOUR_WEBSITE_URL]/redirect/?acct1=cr799393&token1=a1-f7pnteezo4jzhpxclctizt27hyeot&cur1=usd& acct2=vrtc1859315&token2=a1clwe3vfuuus5kraceykdsoqm4snfq&cur2=usd&acct3=CRW1157&token3=a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC&cur3=usd&acct4=VRW1160&token4=a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV&cur3=usd
```

```text
https://[YOUR_WEBSITE_URL]/redirect/?acct1=cr799393&token1=a1-f7pnteezo4jzhpxclctizt27hyeot&cur1=usd& acct2=vrtc1859315&token2=a1clwe3vfuuus5kraceykdsoqm4snfq&cur2=usd&acct3=CRW1157&token3=a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC&cur3=usd&acct4=VRW1160&token4=a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV&cur3=usd
```

```text
const user_accounts = [
  {
    currency: 'usd',
    token: 'a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC',
    account: 'CRW1157'
  },
  {
    account: 'VRW1160',
    token: 'a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV',
    currency: 'usd',
  },
  {
    account: 'cr799393',
    token: 'a1-f7pnteezo4jzhpxclctizt27hyeot',
    currency: 'usd',
  },
  {
    account: 'vrtc1859315',
    token: 'a1clwe3vfuuus5kraceykdsoqm4snfq',
    currency: 'usd',
  },
];
```

```text
const user_accounts = [
  {
    currency: 'usd',
    token: 'a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC',
    account: 'CRW1157'
  },
  {
    account: 'VRW1160',
    token: 'a1-yUqdjiIN0t6ICRc4eIMHDr1i6uKSV',
    currency: 'usd',
  },
  {
    account: 'cr799393',
    token: 'a1-f7pnteezo4jzhpxclctizt27hyeot',
    currency: 'usd',
  },
  {
    account: 'vrtc1859315',
    token: 'a1clwe3vfuuus5kraceykdsoqm4snfq',
    currency: 'usd',
  },
];
```

```text
{
  "authorize": "a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC"
}
```

```text
{
  "authorize": "a1-Yxh5gJS8m406Jopon5JlvKNRsxLMC"
}
```

```text
{
  "account_list": [
    {
      "account_category": "wallet",
      "account_type": "doughflow",
      "broker": "CRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "linked_to": [],
      "loginid": "CRW1157"
    },
    {
      "account_category": "wallet",
      "account_type": "virtual",
      "broker": "VRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 1,
      "landing_company_name": "virtual",
      "linked_to": [],
      "loginid": "VRW1160"
    },
    {
      "account_type": "trading",
      "created_at": 1647509550,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "CR799393",
      "trading": {}
    },
    {
      "account_type": "trading",
      "created_at": 1664132232,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "VRTC1859315",
      "trading": {}
    },
  ],
  "balance": 0,
  "country": "aq",
  "currency": "USD",
  "email": "ss@deriv.com",
  "fullname": "Ms QA script ssRPPta",
  "is_virtual": 0,
  "landing_company_fullname": "Deriv (SVG) LLC",
  "landing_company_name": "svg",
  "linked_to": [],
  "local_currencies": {
    "AAD": {
      "fractional_digits": 2
    }
  },
  "loginid": "CRW1157",
  "preferred_language": "EN",
  "scopes": [
    "admin",
    "payments",
    "read",
    "trade",
    "trading_information"
  ],
  "upgradeable_landing_companies": [],
  "user_id": 464
}
```

```text
{
  "account_list": [
    {
      "account_category": "wallet",
      "account_type": "doughflow",
      "broker": "CRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "linked_to": [],
      "loginid": "CRW1157"
    },
    {
      "account_category": "wallet",
      "account_type": "virtual",
      "broker": "VRW",
      "created_at": 1753955451,
      "currency": "USD",
      "currency_type": "fiat",
      "is_disabled": 0,
      "is_virtual": 1,
      "landing_company_name": "virtual",
      "linked_to": [],
      "loginid": "VRW1160"
    },
    {
      "account_type": "trading",
      "created_at": 1647509550,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "CR799393",
      "trading": {}
    },
    {
      "account_type": "trading",
      "created_at": 1664132232,
      "currency": "USD",
      "is_disabled": 0,
      "is_virtual": 0,
      "landing_company_name": "svg",
      "loginid": "VRTC1859315",
      "trading": {}
    },
  ],
  "balance": 0,
  "country": "aq",
  "currency": "USD",
  "email": "ss@deriv.com",
  "fullname": "Ms QA script ssRPPta",
  "is_virtual": 0,
  "landing_company_fullname": "Deriv (SVG) LLC",
  "landing_company_name": "svg",
  "linked_to": [],
  "local_currencies": {
    "AAD": {
      "fractional_digits": 2
    }
  },
  "loginid": "CRW1157",
  "preferred_language": "EN",
  "scopes": [
    "admin",
    "payments",
    "read",
    "trade",
    "trading_information"
  ],
  "upgradeable_landing_companies": [],
  "user_id": 464
}
```

**Details:**
To unlock the complete functionality of Deriv APIs, you must first authenticate and then authorize your users.

For Deriv APIs, your users must be authenticated and authorized by our OAuth provider and WebSocket Server.

The OAuth provider handles user logins and grants secure access tokens. The WebSocket server then uses these tokens to verify users and facilitate seamless communication with the Deriv API. Together, these components ensure the security and efficiency of your app.

Authentication process

OAuth, short for Open Authorization, is a protocol that enables a client to access server-hosted resources on behalf of the user without exposing their credentials. For more information, refer to OAuth.

This method enables Deriv account holders to log into third-party apps without generating an API token. Consequently, the third-party app does not access the user‚Äôs password or permanent API token, enhancing security.

To authenticate your user:

Make sure the URL is specified correct...

---

### Account APIs
**URL:** https://developers.deriv.com/docs/account-apis

**Account Operations:**
```text
Maltainvest
```

```text
get_self_exclusion
```

```text
get_account_settings
```

**Details:**
Account APIs are designed to manage user accounts, settings, and security. They provide functionalities for authorising sessions, managing API tokens, retrieving and updating account information, handling KYC (Know Your Customer) processes, and setting trading and self-exclusion limits.

These APIs ensure secure, compliant, and personalised interactions on the Deriv platforms, empowering users to manage their accounts and trading activities effectively.

#	API Name	Description	Send	Subscribe	Scope
1	API Token	This call manages API tokens.	‚úî	‚úò	Admin
2	Authorize	Authorises the current WebSocket session using a token. This must precede requests that require access to the client account, such as purchasing or selling contracts.	‚úî	‚úò	NA
3	Balance	Retrieves the user account balance.	‚úî	‚úî	Read
4	Document Upload	Requests and uploads KYC documents from the client.	‚úî	‚úò	Admin
5	Account Status	Retrieves the current status of the user account.	‚úî	‚úò	Read
6	Login History	Retrieves a summary of the user‚Äô...

---

### Market Data APIs
**URL:** https://developers.deriv.com/docs/market-data-apis

**Details:**
Market Data APIs provide access to real-time market data and pricing information on Deriv.

They offer functionalities for retrieving active trading symbols, exchange rates, contract details, and price proposals. Additionally, these APIs enable real-time streaming of spot prices and access to historical tick data, helping users make informed trading decisions.

These APIs are crucial for accessing accurate and up-to-date market data, ensuring users can trade efficiently on the Deriv trading platforms.

#	API Name	Description	Send	Subscribe	Scope
1	Active Symbols	Retrieves a list of all currently active symbols (underlying markets available for trading).	‚úî	‚úò	NA
2	Asset Index	Retrieves a list of available underlyings along with their corresponding contract types and duration limits. For logged-in users, only assets available under their landing company will be returned.	‚úî	‚úò	NA
3	Exchange Rates	Retrieves the exchange rate between a base currency and a target currency supported by the syst...

---

### Reports APIs
**URL:** https://developers.deriv.com/docs/reports-apis

**Details:**
Reports APIs are designed to monitor and report user account activity. They provide functionalities for retrieving reality check summaries, generating account statements, and subscribing to real-time transaction notifications.

These APIs are essential for ensuring regulatory compliance and giving clients up-to-date insights into their trading activities and account status.

#	API Name	Description	Send	Subscribe	Scope
1	Reality Check	Retrieves a summary of the client‚Äôs trades and account status for the Reality Check feature.

This includes the time elapsed since the session began and the associated profit/loss.	‚úî	‚úò	Read, Trading Information
2	Statement	Retrieves a summary of account transactions according to the specified search criteria.	‚úî	‚úò	Read, Trading Information
3	Transactions Stream	Subscribes to real-time transaction notifications.	‚úî	‚úî	Read, Trading Information

Updated 4 months ago

Did this page help you?
Yes
No...

---

### Trading APIs
**URL:** https://developers.deriv.com/docs/trading-apis

**Account Operations:**
```text
tokens
```

```text
portfolio
```

```text
buy_contract_for_multiple_accounts
```

**Details:**
Trading APIs focus on trading and managing contracts.

They include functionalities for buying, selling, and updating contracts, as well as managing copy trading activities. The APIs also allow users to retrieve important trading information such as profit tables, portfolio details, and contract durations.

These APIs are essential for users who actively trade on the platform and need to manage their trading accounts effectively.

#	API Name	Description	Send	Subscribe	Scope
1	Buy Contract: Trade	Buys a contract.	‚úî	‚úò	Trade
2	Buy Contract for Multiple Accounts	Buys a contract for multiple accounts specified by the tokens parameter. Note that although this is an authorized call, the contract is not purchased for the authorized account.	‚úî	‚úò	Trade
3	Cancel a Contract	Cancels a contract using its contract ID.	‚úî	‚úò	Trade
4	Update Contract	Updates the conditions of a contract.	‚úî	‚úò	Trade
5	Update Contract History	Retrieves the update history of a contract.	‚úî	‚úò	Read
6	Copy Trading: Start	Starts c...

---

### Mark-up
**URL:** https://developers.deriv.com/docs/mark-up

**Details:**
If you build a platform or app that allows users to trade manually or via automation using Deriv APIs, you can earn up to 3% markup commission on every contract your users execute.

Example:

Let‚Äôs say a user places a $10 stake, and the potential payout without any markup is $17.20 if the trade wins.

If you set a 2% markup, your commission will be calculated on the potential payout: 2% of $17.20 = $0.34

With this adjusted stake, the user‚Äôs new potential payout becomes: $16.63

üöß

‚ö†Ô∏è Markup impacts the user‚Äôs profit. The higher the markup, the lower their payout.

Another Example:

Stake: USD 25.50

Payout: USD 50

Markup: 2% of USD 50 = USD 1

Client Balance Debited: USD 26.50

Other ways to monetize the Deriv API

You can make money with your Deriv API application in several ways:

Charge for Access
Offer your trading app for a subscription or one-time fee if it provides value to users.

Offer Premium Features
Charge extra for advanced features like real-time market data or advance...

---

### Error codes
**URL:** https://developers.deriv.com/docs/error-codes

**Details:**
General
Error Code	Message
AccountShouldBeReal	Only real accounts are allowed to open [_1] real accounts. Demo account cannot open real dxtrader.
AccountTypesMismatch	Transfer between real and virtual accounts is not allowed.
AccountWithDeposit	Change of currency is not allowed for an existing account with previous deposits.
AffiliateNotFound	N/A
AllowCopiersError	Copier can't be a trader.
AlreadyAgeVerified	Your age has already been verified.
AlreadyVerified	This account is already phone number verified.
AmountNotAllowed	The minimum amount for transfers is [_1] [_2] after conversion fees are deducted. Please adjust the amount.
AppGet	Not Found
AppRegister	Not Found
AppUpdate	N/A
AppropriatenessTestFailed	Failed to reach an acceptable trading experience score.
AuthenticateAccount	Please authenticate your [_1] account to proceed with the fund transfer.
AuthenticateAccountCreate	Please verify your [_1] account to proceed with account creation.
AuthorizationRequired	Please log in.
BadSess...

---

### Create account using API
**URL:** https://developers.deriv.com/docs/create-account-using-api

**Account Operations:**
```text
type
```

```text
opening_account
```

```text
residence_list
```

```text
verify_email
```

```text
residence_list
```

```text
payout_currencies
```

```text
verify_email
```

```text
{
  "verify_email": "your_email@example.com",
  "type": "account_opening"
}
```

```text
{
  "verify_email": "your_email@example.com",
  "type": "account_opening"
}
```

```text
{
"new_account_virtual":1,
"client_password":"Abcd1234",
"verification_code":"7y0MXLQG",
"type":"dynamic",
"residence":"aq",
"date_first_contact":"2025-07-30",
"signup_device":"desktop",
"req_id":5
}
```

```text
{
"new_account_virtual":1,
"client_password":"Abcd1234",
"verification_code":"7y0MXLQG",
"type":"dynamic",
"residence":"aq",
"date_first_contact":"2025-07-30",
"signup_device":"desktop",
"req_id":5
}
```

```text
{
    "new_account_wallet": 1,
    "account_opening_reason": "Savings",
    "address_city": "Cyberjaya",
    "address_line_1": "Deriv HQ",
    "address_postcode": "63000",
    "address_state": "",
    "citizen": "de",
    "currency": "EUR",
    "date_of_birth": "2007-08-04",
    "employment_status": "Unemployed",
    "salutation": "Mr",
    "fatca_declaration": 0,
    "tax_residence": "de",
    "first_name": "Tay",
    "last_name": "Suisin",
    "phone": "234124124",
    "place_of_birth": "de",
    "residence": "de",
    "account_type": "doughflow",
    "landing_company_short": "maltainvest",
    "non_pep_declaration": 1,
    "tnc_acceptance": 1,
    "financial_assessment": {
        "employment_status": "Unemployed",
        "occupation": "Manager",
        "income_source": "Sale of art, antiques or other high value assets",
        "net_income": "Over $500,000",
        "source_of_wealth": "Proceeds of sale of crypto currency;Sale of art, antiques or high value assets",
        "estimated_worth": "Over $500,000",
        "investment_intention": "Over $500,000",
        "financial_information_version": "v2",
        "cfd_experience": "Over 3 years",
        "cfd_frequency": "40 transactions or more in the past 12 months",
        "cfd_trading_definition": "Place a bet on the price movement.",
        "leverage_impact_trading": "Leverage lets you open larger positions for a fraction of the trade's value.",
        "leverage_trading_high_risk_stop_loss": "Close your trade automatically when the loss is more than or equal to a specific amount.",
        "required_initial_margin": "When opening a Leveraged CFD trade.",
        "risk_tolerance": "Yes",
        "source_of_experience": "I have an academic degree, professional certification, and/or work experience.",
        "trading_experience_financial_instruments": "Over 3 years",
        "trading_frequency_financial_instruments": "40 transactions or more in the past 12 months"
    },
    "tin_skipped": 1,
    "calling_country_code": "49",
    "loginid": "VRW1115",
    "req_id": 18
}
```

```text
{
    "new_account_wallet": 1,
    "account_opening_reason": "Savings",
    "address_city": "Cyberjaya",
    "address_line_1": "Deriv HQ",
    "address_postcode": "63000",
    "address_state": "",
    "citizen": "de",
    "currency": "EUR",
    "date_of_birth": "2007-08-04",
    "employment_status": "Unemployed",
    "salutation": "Mr",
    "fatca_declaration": 0,
    "tax_residence": "de",
    "first_name": "Tay",
    "last_name": "Suisin",
    "phone": "234124124",
    "place_of_birth": "de",
    "residence": "de",
    "account_type": "doughflow",
    "landing_company_short": "maltainvest",
    "non_pep_declaration": 1,
    "tnc_acceptance": 1,
    "financial_assessment": {
        "employment_status": "Unemployed",
        "occupation": "Manager",
        "income_source": "Sale of art, antiques or other high value assets",
        "net_income": "Over $500,000",
        "source_of_wealth": "Proceeds of sale of crypto currency;Sale of art, antiques or high value assets",
        "estimated_worth": "Over $500,000",
        "investment_intention": "Over $500,000",
        "financial_information_version": "v2",
        "cfd_experience": "Over 3 years",
        "cfd_frequency": "40 transactions or more in the past 12 months",
        "cfd_trading_definition": "Place a bet on the price movement.",
        "leverage_impact_trading": "Leverage lets you open larger positions for a fraction of the trade's value.",
        "leverage_trading_high_risk_stop_loss": "Close your trade automatically when the loss is more than or equal to a specific amount.",
        "required_initial_margin": "When opening a Leveraged CFD trade.",
        "risk_tolerance": "Yes",
        "source_of_experience": "I have an academic degree, professional certification, and/or work experience.",
        "trading_experience_financial_instruments": "Over 3 years",
        "trading_frequency_financial_instruments": "40 transactions or more in the past 12 months"
    },
    "tin_skipped": 1,
    "calling_country_code": "49",
    "loginid": "VRW1115",
    "req_id": 18
}
```

```text
{
"new_account_wallet":1,
"currency":"USD",
"first_name":"Tay",
"last_name":"Suisin",
"date_of_birth":"2007-07-27",
"address_line_1":"Deriv HQ",
"address_city":"Cyberjaya",
"address_postcode":"63000",
"fatca_declaration":0,
"residence":"aq",
"non_pep_declaration":1,
"citizen":"aq",
"phone":"123123123",
"place_of_birth":"aq",
"account_opening_reason":"Savings",
"tax_residence":"aq",
"employment_status":"Unemployed",
"tnc_acceptance":1,
"loginid":"VRW1244",
"calling_country_code":"672",
"account_type":"doughflow",
"tin_skipped":1,
"financial_assessment":{
"financial_information_version":"v2"
},
"req_id":19
}
```

```text
{
"new_account_wallet":1,
"currency":"USD",
"first_name":"Tay",
"last_name":"Suisin",
"date_of_birth":"2007-07-27",
"address_line_1":"Deriv HQ",
"address_city":"Cyberjaya",
"address_postcode":"63000",
"fatca_declaration":0,
"residence":"aq",
"non_pep_declaration":1,
"citizen":"aq",
"phone":"123123123",
"place_of_birth":"aq",
"account_opening_reason":"Savings",
"tax_residence":"aq",
"employment_status":"Unemployed",
"tnc_acceptance":1,
"loginid":"VRW1244",
"calling_country_code":"672",
"account_type":"doughflow",
"tin_skipped":1,
"financial_assessment":{
"financial_information_version":"v2"
},
"req_id":19
}
```

```text
affiliate_token
```

```text
utm_campaign
```

```text
affiliate_token
```

```text
utm_campaign
```

**Details:**
Follow these simple steps to create demo and real accounts using the Deriv API:

Verify email
Make a call to the verify_email endpoint.
Set the type parameter to opening_account to indicate you‚Äôre opening a new account.
You will receive an email containing a verification code at the email address provided in the API call. This code is required for the next steps.


Create a Demo Account

To create a demo account:

Make a call to the new_account_virtual endpoint.
Provide the following information:
Residence: The 2-letter country code. Obtain this from the residence_list call or check the list here.
Verification Code: The email verification code you received from the verify_email call above.

A demo account will be created with a starting balance of USD 10,000.

Create a Real Account

To set up a real account, follow these steps after logging into your demo account:

For users in the EU: Use the new_account_maltainvest endpoint.

For users outside the EU: Use the new_account_real endpoin...

---

## ‚ö†Ô∏è 6. ERROR HANDLING

### WebSockets
**URL:** https://developers.deriv.com/docs/websockets

**Error Handling Examples:**
```text
wss://ws.derivws.com/websockets/v3?app_id={app_id}
```

```text
{app_id}
```

```text
api_call_limits
```

```text
{app_id}
```

```text
let socket = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id={app_id}');
```

```text
let socket = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id={app_id}');
```

```text
readyState
```

```text
1
```

```text
readyState
```

```text
socket.onopen = function (e) {
  console.log('[open] Connection established');
  console.log('Sending to server');
  const sendMessage = JSON.stringify({ ping: 1 });
  socket.send(sendMessage);
};
```

```text
socket.onopen = function (e) {
  console.log('[open] Connection established');
  console.log('Sending to server');
  const sendMessage = JSON.stringify({ ping: 1 });
  socket.send(sendMessage);
};
```

```text
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`);
};
```

```text
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`);
};
```

```text
Close()
```

```text
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
  } else {
    // e.g. server process killed or network down
    // event.code is usually 1006 in this case
    console.log('[close] Connection died');
  }
};
```

```text
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
  } else {
    // e.g. server process killed or network down
    // event.code is usually 1006 in this case
    console.log('[close] Connection died');
  }
};
```

```text
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`);
};
```

```text
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`);
};
```

```text
Open()
```

```text
OnOpen
```

```text
Send
```

```text
byte[]
```

```text
Close()
```

```text
const app_id = 'app_id'; // Replace with your app_id.
const socket = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`); // Create a new WebSocket connection using the app_id

// Event handler for when the WebSocket connection is opened
socket.onopen = function (e) {
  console.log('[open] Connection established'); // Log connection establishment
  console.log('Sending to server');

  const sendMessage = JSON.stringify({ ping: 1 }); // Create a ping message in JSON format
  socket.send(sendMessage); // Send the ping message to the server
};

// Event handler for when a message is received from the server
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`); // Log the message received from the server
};

// Event handler for when the WebSocket connection is closed
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`); // Log clean close with code and reason
  } else {
    console.log('[close] Connection died'); // Log an abrupt close
  }
};

// Event handler for when an error occurs with the WebSocket connection
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`); // Log the error that occurred
};

/*
Instructions to run this code:

1. Ensure Node.js is installed on your machine. You can download it from https://nodejs.org/.
2. Install the `ws` WebSocket library by running:
   npm install ws
3. Save this code to a file, e.g., `websocket_client.js`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   node websocket_client.js

Ensure that the `app_id` in the URL is replaced with your own if needed.
*/
```

```text
const app_id = 'app_id'; // Replace with your app_id.
const socket = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`); // Create a new WebSocket connection using the app_id

// Event handler for when the WebSocket connection is opened
socket.onopen = function (e) {
  console.log('[open] Connection established'); // Log connection establishment
  console.log('Sending to server');

  const sendMessage = JSON.stringify({ ping: 1 }); // Create a ping message in JSON format
  socket.send(sendMessage); // Send the ping message to the server
};

// Event handler for when a message is received from the server
socket.onmessage = function (event) {
  console.log(`[message] Data received from server: ${event.data}`); // Log the message received from the server
};

// Event handler for when the WebSocket connection is closed
socket.onclose = function (event) {
  if (event.wasClean) {
    console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`); // Log clean close with code and reason
  } else {
    console.log('[close] Connection died'); // Log an abrupt close
  }
};

// Event handler for when an error occurs with the WebSocket connection
socket.onerror = function (error) {
  console.log(`[error] ${error.message}`); // Log the error that occurred
};

/*
Instructions to run this code:

1. Ensure Node.js is installed on your machine. You can download it from https://nodejs.org/.
2. Install the `ws` WebSocket library by running:
   npm install ws
3. Save this code to a file, e.g., `websocket_client.js`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   node websocket_client.js

Ensure that the `app_id` in the URL is replaced with your own if needed.
*/
```

```text
import asyncio
import websockets
import json

async def connect_to_websocket():
    app_id = app_id  # Replace with your app_id
    uri = f"wss://ws.derivws.com/websockets/v3?app_id={app_id}"  # WebSocket URI with the app_id

    try:
        # Establish a connection to the WebSocket server
        async with websockets.connect(uri) as websocket:
            print("[open] Connection established")  # Connection opened
            print("Sending to server")

            # Prepare the message to send (ping message in JSON format)
            send_message = json.dumps({"ping": 1})
            await websocket.send(send_message)  # Send the ping message to the server

            # Wait for a response from the server
            response = await websocket.recv()
            print(f"[message] Data received from server: {response}")  # Log the server's response

    except websockets.ConnectionClosedError as e:
        # Handle the scenario where the connection is closed
        if e.code == 1000:
            print(f"[close] Connection closed cleanly, code={e.code} reason={e.reason}")  # Clean close
        else:
            print("[close] Connection died")  # Abrupt close, likely due to network or server issues

    except Exception as e:
        # Handle any other exceptions that may occur
        print(f"[error] {str(e)}")  # Log any errors that occur

# Run the WebSocket client
# asyncio.get_event_loop().run_until_complete() starts the coroutine connect_to_websocket()
asyncio.get_event_loop().run_until_complete(connect_to_websocket())

'''
Instructions to run this code:

1. Ensure Python 3 is installed on your machine. You can download it from https://www.python.org/.
2. Install the `websockets` library by running:
   pip install websockets
3. Save this code to a file, e.g., `websocket_client.py`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   python websocket_client.py

Replace `app_id` with your own application ID if needed.
'''
```

```text
import asyncio
import websockets
import json

async def connect_to_websocket():
    app_id = app_id  # Replace with your app_id
    uri = f"wss://ws.derivws.com/websockets/v3?app_id={app_id}"  # WebSocket URI with the app_id

    try:
        # Establish a connection to the WebSocket server
        async with websockets.connect(uri) as websocket:
            print("[open] Connection established")  # Connection opened
            print("Sending to server")

            # Prepare the message to send (ping message in JSON format)
            send_message = json.dumps({"ping": 1})
            await websocket.send(send_message)  # Send the ping message to the server

            # Wait for a response from the server
            response = await websocket.recv()
            print(f"[message] Data received from server: {response}")  # Log the server's response

    except websockets.ConnectionClosedError as e:
        # Handle the scenario where the connection is closed
        if e.code == 1000:
            print(f"[close] Connection closed cleanly, code={e.code} reason={e.reason}")  # Clean close
        else:
            print("[close] Connection died")  # Abrupt close, likely due to network or server issues

    except Exception as e:
        # Handle any other exceptions that may occur
        print(f"[error] {str(e)}")  # Log any errors that occur

# Run the WebSocket client
# asyncio.get_event_loop().run_until_complete() starts the coroutine connect_to_websocket()
asyncio.get_event_loop().run_until_complete(connect_to_websocket())

'''
Instructions to run this code:

1. Ensure Python 3 is installed on your machine. You can download it from https://www.python.org/.
2. Install the `websockets` library by running:
   pip install websockets
3. Save this code to a file, e.g., `websocket_client.py`.
4. Open a terminal and navigate to the directory where you saved the file.
5. Run the code using the following command:
   python websocket_client.py

Replace `app_id` with your own application ID if needed.
'''
```

```text
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.ByteBuffer;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id.
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {
                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");
                    System.out.println("Sending to server");

                    // Create a ping message in JSON format
                    String sendMessage = "{\"ping\": 1}";
                    this.send(sendMessage); // Send the ping message to the server
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Data received from server: " + message); // Log the received message
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    if (remote) {
                        System.out.println("[close] Connection closed by server, code=" + code + " reason=" + reason); // Remote close
                    } else {
                        System.out.println("[close] Connection closed by client, code=" + code + " reason=" + reason); // Client close
                    }
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage()); // Log any errors
                }
                
                @Override
                public void onMessage(ByteBuffer bytes) {
                    System.out.println("[message] ByteBuffer received from server"); // Handle binary message if necessary
                }
            };

            client.connect(); // Connect to the WebSocket server

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run this code:

1. Add the Java-WebSocket library to your project. You can do this by:
   - Using Maven: Add the following dependency to your `pom.xml`:
     <dependency>
         <groupId>org.java-websocket</groupId>
         <artifactId>Java-WebSocket</artifactId>
         <version>1.5.2</version>
     </dependency>
   - Using Gradle: Add the following to your `build.gradle`:
     implementation 'org.java-websocket:Java-WebSocket:1.5.2'

2. Save this code to a file, e.g., `WebSocketExample.java`.

3. Compile the program:
   javac WebSocketExample.java

4. Run the program:
   java WebSocketExample

Make sure to replace `app_id` with your actual application ID if needed.
*/
```

```text
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.ByteBuffer;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id.
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {
                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");
                    System.out.println("Sending to server");

                    // Create a ping message in JSON format
                    String sendMessage = "{\"ping\": 1}";
                    this.send(sendMessage); // Send the ping message to the server
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Data received from server: " + message); // Log the received message
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    if (remote) {
                        System.out.println("[close] Connection closed by server, code=" + code + " reason=" + reason); // Remote close
                    } else {
                        System.out.println("[close] Connection closed by client, code=" + code + " reason=" + reason); // Client close
                    }
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage()); // Log any errors
                }
                
                @Override
                public void onMessage(ByteBuffer bytes) {
                    System.out.println("[message] ByteBuffer received from server"); // Handle binary message if necessary
                }
            };

            client.connect(); // Connect to the WebSocket server

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run this code:

1. Add the Java-WebSocket library to your project. You can do this by:
   - Using Maven: Add the following dependency to your `pom.xml`:
     <dependency>
         <groupId>org.java-websocket</groupId>
         <artifactId>Java-WebSocket</artifactId>
         <version>1.5.2</version>
     </dependency>
   - Using Gradle: Add the following to your `build.gradle`:
     implementation 'org.java-websocket:Java-WebSocket:1.5.2'

2. Save this code to a file, e.g., `WebSocketExample.java`.

3. Compile the program:
   javac WebSocketExample.java

4. Run the program:
   java WebSocketExample

Make sure to replace `app_id` with your actual application ID if needed.
*/
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use AnyEvent;
use AnyEvent::WebSocket::Client 0.12;
use JSON;
use feature 'say';

# WebSocket URL and app_id
my $app_id = app_id; //Replace with your app_id
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging



# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        # handle error...
        warn $@;
        return;

    }
    say "WebSocket connection established.";


    $connection->send('{ ping => 1 }');
    say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";


    # Handle incoming messages
    $connection->on(each_message => sub {
        my($connection, $message) = @_;

        say "message received";
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use AnyEvent;
use AnyEvent::WebSocket::Client 0.12;
use JSON;
use feature 'say';

# WebSocket URL and app_id
my $app_id = app_id; //Replace with your app_id
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging



# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        # handle error...
        warn $@;
        return;

    }
    say "WebSocket connection established.";


    $connection->send('{ ping => 1 }');
    say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";
    # $connection->send(encode_json({ ping => 1 }));
    # say "Ping sent to keep connection alive.";


    # Handle incoming messages
    $connection->on(each_message => sub {
        my($connection, $message) = @_;

        say "message received";
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
<?php

// Include Composer's autoload file
require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your specific app ID
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] Connection established\n";
    echo "Sending to server\n";

    // Send a ping message
    $client->send(json_encode(["ping" => 1]));
    echo "[debug] Message sent: {\"ping\":1}\n";

    // Receive a response from the server
    $response = $client->receive();
    echo "[message] Received from WebSocket: '$response'\n";

    // Close the connection
    $client->close();
    echo "[close] Connection closed\n";

} catch (\WebSocket\ConnectionException $e) {
    echo "[error] Connection error: " . $e->getMessage() . "\n";
} catch (Exception $e) {
    echo "[error] General error: " . $e->getMessage() . "\n";
}

/*
Instructions to run this code:

1. Ensure PHP is installed on your machine. You can check by running `php -v` in your terminal.
2. Install Composer, the dependency manager for PHP, from https://getcomposer.org/.
3. Initialize a Composer project in the directory where this file is saved:
composer init
4. Install the `textalk/websocket` package by adding it to your `composer.json` file or by running:
composer require textalk/websocket
5. Save the PHP code above to a file, e.g., `websocket_client.php`.
6. Run the code in the terminal:
php websocket_client.php
Note: Replace the `app_id` in the URL with your own application ID if needed.
*/
```

```text
<?php

// Include Composer's autoload file
require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your specific app ID
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] Connection established\n";
    echo "Sending to server\n";

    // Send a ping message
    $client->send(json_encode(["ping" => 1]));
    echo "[debug] Message sent: {\"ping\":1}\n";

    // Receive a response from the server
    $response = $client->receive();
    echo "[message] Received from WebSocket: '$response'\n";

    // Close the connection
    $client->close();
    echo "[close] Connection closed\n";

} catch (\WebSocket\ConnectionException $e) {
    echo "[error] Connection error: " . $e->getMessage() . "\n";
} catch (Exception $e) {
    echo "[error] General error: " . $e->getMessage() . "\n";
}

/*
Instructions to run this code:

1. Ensure PHP is installed on your machine. You can check by running `php -v` in your terminal.
2. Install Composer, the dependency manager for PHP, from https://getcomposer.org/.
3. Initialize a Composer project in the directory where this file is saved:
composer init
4. Install the `textalk/websocket` package by adding it to your `composer.json` file or by running:
composer require textalk/websocket
5. Save the PHP code above to a file, e.g., `websocket_client.php`.
6. Run the code in the terminal:
php websocket_client.php
Note: Replace the `app_id` in the URL with your own application ID if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server
    let (mut socket, _response) = connect_async(url).await.expect("Failed to connect");

    println!("[open] Connection established");

    // Prepare the ping message
    let send_message = r#"{"ping": 1}"#;
    socket.send(Message::Text(send_message.into())).await.expect("Failed to send message");

    println!("Message sent to server");

    // Receive a message from the server
    if let Some(Ok(msg)) = socket.next().await {
        println!("[message] Data received from server: {:?}", msg);
    }

    // Close the connection
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed cleanly");
}

/*
Instructions to run this code:

1. Ensure that Rust and Cargo (Rust's package manager) are installed. You can install them from https://rustup.rs/.
2. Initialize a new Rust project if you haven‚Äôt already:
cargo new websocket_client
cd websocket_client
3. Add the following dependencies to your `Cargo.toml` file under `[dependencies]`:
tokio = { version = ‚Äú1‚Äù, features = [‚Äúfull‚Äù] }
tokio-tungstenite = ‚Äú0.15‚Äù
futures-util = ‚Äú0.3‚Äù
url = ‚Äú2.2‚Äù
4. Replace the contents of `src/main.rs` with the code above.
5. Compile and run the code using:
cargo run
Note: Replace `app_id` in the URL with your own application ID if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server
    let (mut socket, _response) = connect_async(url).await.expect("Failed to connect");

    println!("[open] Connection established");

    // Prepare the ping message
    let send_message = r#"{"ping": 1}"#;
    socket.send(Message::Text(send_message.into())).await.expect("Failed to send message");

    println!("Message sent to server");

    // Receive a message from the server
    if let Some(Ok(msg)) = socket.next().await {
        println!("[message] Data received from server: {:?}", msg);
    }

    // Close the connection
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed cleanly");
}

/*
Instructions to run this code:

1. Ensure that Rust and Cargo (Rust's package manager) are installed. You can install them from https://rustup.rs/.
2. Initialize a new Rust project if you haven‚Äôt already:
cargo new websocket_client
cd websocket_client
3. Add the following dependencies to your `Cargo.toml` file under `[dependencies]`:
tokio = { version = ‚Äú1‚Äù, features = [‚Äúfull‚Äù] }
tokio-tungstenite = ‚Äú0.15‚Äù
futures-util = ‚Äú0.3‚Äù
url = ‚Äú2.2‚Äù
4. Replace the contents of `src/main.rs` with the code above.
5. Compile and run the code using:
cargo run
Note: Replace `app_id` in the URL with your own application ID if needed.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a ping message to the server
    func sendPingMessage() {
        let message = URLSessionWebSocketTask.Message.string("{\"ping\": 1}") // Prepare the ping message in JSON format
        webSocketTask?.send(message) { error in
            if let error = error {
                print("[error] Failed to send message: \(error.localizedDescription)")
            } else {
                print("Sending to server")
            }
        }
    }
    
    // Send the ping message initially
    sendPingMessage()

    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    print("[message] Data received from server: \(text)")
                case .data(let data):
                    print("[message] Data received from server: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }

                // Continue to receive messages
                receiveMessage()

            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }

    // Start receiving messages
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    // Use this function when you need to close the connection
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Call the function to connect to the WebSocket
connectWebSocket()

// Example usage: Call closeWebSocketConnection() to close the connection when needed
// The following line will close the connection after 10 seconds for demonstration purposes
DispatchQueue.main.asyncAfter(deadline: .now() + 10) { closeWebSocketConnection() }

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run this code:

1. Ensure that Xcode is installed on your macOS system, or if you're using another platform, ensure Swift is set up correctly.
2. Create a new Swift file in Xcode or any text editor, and paste the above code into it.
3. In Xcode:
   - Go to `File` -> `New` -> `Project`, and select a macOS Command Line Tool.
   - In the project, create a new Swift file and paste this code.
4. Run the project in Xcode to execute the WebSocket client.
5. Alternatively, save the code to a file named `websocket_client.swift` and run it from the terminal using:
swift websocket_client.swift
Note: Replace `app_id` in the WebSocket URL with your own application ID if needed.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a ping message to the server
    func sendPingMessage() {
        let message = URLSessionWebSocketTask.Message.string("{\"ping\": 1}") // Prepare the ping message in JSON format
        webSocketTask?.send(message) { error in
            if let error = error {
                print("[error] Failed to send message: \(error.localizedDescription)")
            } else {
                print("Sending to server")
            }
        }
    }
    
    // Send the ping message initially
    sendPingMessage()

    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    print("[message] Data received from server: \(text)")
                case .data(let data):
                    print("[message] Data received from server: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }

                // Continue to receive messages
                receiveMessage()

            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }

    // Start receiving messages
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    // Use this function when you need to close the connection
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Call the function to connect to the WebSocket
connectWebSocket()

// Example usage: Call closeWebSocketConnection() to close the connection when needed
// The following line will close the connection after 10 seconds for demonstration purposes
DispatchQueue.main.asyncAfter(deadline: .now() + 10) { closeWebSocketConnection() }

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run this code:

1. Ensure that Xcode is installed on your macOS system, or if you're using another platform, ensure Swift is set up correctly.
2. Create a new Swift file in Xcode or any text editor, and paste the above code into it.
3. In Xcode:
   - Go to `File` -> `New` -> `Project`, and select a macOS Command Line Tool.
   - In the project, create a new Swift file and paste this code.
4. Run the project in Xcode to execute the WebSocket client.
5. Alternatively, save the code to a file named `websocket_client.swift` and run it from the terminal using:
swift websocket_client.swift
Note: Replace `app_id` in the WebSocket URL with your own application ID if needed.
*/
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE: {
        const char *ping_msg = "{\"ping\": 1}";
        unsigned char buf[LWS_PRE + 20];
        memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
        lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
        break;
    }

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE: {
        const char *ping_msg = "{\"ping\": 1}";
        unsigned char buf[LWS_PRE + 20];
        memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
        lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
        break;
    }

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    public static async Task Main(string[] args)
    {
        string app_id = "app_id"; // Replace with your app_id.
        string uri = $"wss://ws.derivws.com/websockets/v3?app_id={app_id}"; // WebSocket URI with the app_id

        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            try
            {
                // Connect to the WebSocket server
                await webSocket.ConnectAsync(new Uri(uri), CancellationToken.None);
                Console.WriteLine("[open] Connection established");

                // Send a ping message to the server
                string sendMessage = "{\"ping\": 1}"; // Prepare the ping message in JSON format
                ArraySegment<byte> bytesToSend = new ArraySegment<byte>(Encoding.UTF8.GetBytes(sendMessage));
                await webSocket.SendAsync(bytesToSend, WebSocketMessageType.Text, true, CancellationToken.None);
                Console.WriteLine("Sending to server");

                // Receive message from the server
                var buffer = new byte[1024];
                WebSocketReceiveResult result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
                string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
                Console.WriteLine("[message] Data received from server: " + response);

                // Close the WebSocket connection cleanly
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Close connection", CancellationToken.None);
                Console.WriteLine("[close] Connection closed cleanly");
            }
            catch (WebSocketException e)
            {
                Console.WriteLine("[error] WebSocket error: " + e.Message);
            }
            catch (Exception e)
            {
                Console.WriteLine("[error] " + e.Message);
            }
        }
    }
}

/*
 * Instructions:
 * 1. Ensure you have the .NET SDK installed on your machine. You can download it from https://dotnet.microsoft.com/download.
 * 2. Save this code in a file, e.g., WebSocketExample.cs.
 * 3. Open a terminal and navigate to the directory where you saved the file.
 * 4. Create a new .NET console project and add the required WebSocket package:
 *      dotnet new console -o WebSocketExampleApp
 *      mv WebSocketExample.cs WebSocketExampleApp/WebSocketExample.cs
 *      cd WebSocketExampleApp
 *      dotnet add package System.Net.WebSockets.Client --version 4.5.3
 * 5. Run the application with:
 *      dotnet run
 *
 * Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
 */
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    public static async Task Main(string[] args)
    {
        string app_id = "app_id"; // Replace with your app_id.
        string uri = $"wss://ws.derivws.com/websockets/v3?app_id={app_id}"; // WebSocket URI with the app_id

        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            try
            {
                // Connect to the WebSocket server
                await webSocket.ConnectAsync(new Uri(uri), CancellationToken.None);
                Console.WriteLine("[open] Connection established");

                // Send a ping message to the server
                string sendMessage = "{\"ping\": 1}"; // Prepare the ping message in JSON format
                ArraySegment<byte> bytesToSend = new ArraySegment<byte>(Encoding.UTF8.GetBytes(sendMessage));
                await webSocket.SendAsync(bytesToSend, WebSocketMessageType.Text, true, CancellationToken.None);
                Console.WriteLine("Sending to server");

                // Receive message from the server
                var buffer = new byte[1024];
                WebSocketReceiveResult result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
                string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
                Console.WriteLine("[message] Data received from server: " + response);

                // Close the WebSocket connection cleanly
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Close connection", CancellationToken.None);
                Console.WriteLine("[close] Connection closed cleanly");
            }
            catch (WebSocketException e)
            {
                Console.WriteLine("[error] WebSocket error: " + e.Message);
            }
            catch (Exception e)
            {
                Console.WriteLine("[error] " + e.Message);
            }
        }
    }
}

/*
 * Instructions:
 * 1. Ensure you have the .NET SDK installed on your machine. You can download it from https://dotnet.microsoft.com/download.
 * 2. Save this code in a file, e.g., WebSocketExample.cs.
 * 3. Open a terminal and navigate to the directory where you saved the file.
 * 4. Create a new .NET console project and add the required WebSocket package:
 *      dotnet new console -o WebSocketExampleApp
 *      mv WebSocketExample.cs WebSocketExampleApp/WebSocketExample.cs
 *      cd WebSocketExampleApp
 *      dotnet add package System.Net.WebSockets.Client --version 4.5.3
 * 5. Run the application with:
 *      dotnet run
 *
 * Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
 */
```

```text
package main

import (
    "fmt"
    "log"
    "net/url"
    "os"
    "os/signal"
    "time"

    "github.com/gorilla/websocket"
)

func main() {
    // Define the WebSocket server URL
    appID := "app_id" // Replace with your app_id.
    serverURL := url.URL{Scheme: "wss", Host: "ws.derivws.com", Path: "/websockets/v3", RawQuery: "app_id=" + appID}
    fmt.Printf("Connecting to %s\n", serverURL.String())

    // Connect to the WebSocket server
    c, _, err := websocket.DefaultDialer.Dial(serverURL.String(), nil)
    if err != nil {
        log.Fatal("Dial error:", err)
    }
    defer c.Close()

    done := make(chan struct{})

    // Goroutine to handle receiving messages from the server
    go func() {
        defer close(done)
        for {
            _, message, err := c.ReadMessage()
            if err != nil {
                log.Println("Read error:", err)
                return
            }
            fmt.Printf("[message] Data received from server: %s\n", message)
        }
    }()

    // Send a ping message to the server
    pingMessage := `{"ping": 1}` // Prepare the ping message in JSON format
    err = c.WriteMessage(websocket.TextMessage, []byte(pingMessage))
    if err != nil {
        log.Println("Write error:", err)
        return
    }
    fmt.Println("Sending to server")

    // Set up signal handling to gracefully close the connection
    interrupt := make(chan os.Signal, 1)
    signal.Notify(interrupt, os.Interrupt)

    // Loop to handle connection closure or interruptions
    for {
        select {
        case <-done:
            return
        case <-interrupt:
            fmt.Println("[close] Interrupt signal received. Closing connection.")
            // Close the WebSocket connection gracefully
            err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
            if err != nil {
                log.Println("Write close error:", err)
                return
            }
            select {
            case <-done:
            case <-time.After(time.Second):
            }
            return
        }
    }
}

/*
Instructions:
1. Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.
2. Install the Gorilla WebSocket package by running:
       go get github.com/gorilla/websocket
3. Save this code to a file, e.g., websocket_client.go.
4. Open a terminal, navigate to the directory where you saved the file, and run:
       go run websocket_client.go

Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
*/
```

```text
package main

import (
    "fmt"
    "log"
    "net/url"
    "os"
    "os/signal"
    "time"

    "github.com/gorilla/websocket"
)

func main() {
    // Define the WebSocket server URL
    appID := "app_id" // Replace with your app_id.
    serverURL := url.URL{Scheme: "wss", Host: "ws.derivws.com", Path: "/websockets/v3", RawQuery: "app_id=" + appID}
    fmt.Printf("Connecting to %s\n", serverURL.String())

    // Connect to the WebSocket server
    c, _, err := websocket.DefaultDialer.Dial(serverURL.String(), nil)
    if err != nil {
        log.Fatal("Dial error:", err)
    }
    defer c.Close()

    done := make(chan struct{})

    // Goroutine to handle receiving messages from the server
    go func() {
        defer close(done)
        for {
            _, message, err := c.ReadMessage()
            if err != nil {
                log.Println("Read error:", err)
                return
            }
            fmt.Printf("[message] Data received from server: %s\n", message)
        }
    }()

    // Send a ping message to the server
    pingMessage := `{"ping": 1}` // Prepare the ping message in JSON format
    err = c.WriteMessage(websocket.TextMessage, []byte(pingMessage))
    if err != nil {
        log.Println("Write error:", err)
        return
    }
    fmt.Println("Sending to server")

    // Set up signal handling to gracefully close the connection
    interrupt := make(chan os.Signal, 1)
    signal.Notify(interrupt, os.Interrupt)

    // Loop to handle connection closure or interruptions
    for {
        select {
        case <-done:
            return
        case <-interrupt:
            fmt.Println("[close] Interrupt signal received. Closing connection.")
            // Close the WebSocket connection gracefully
            err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
            if err != nil {
                log.Println("Write close error:", err)
                return
            }
            select {
            case <-done:
            case <-time.After(time.Second):
            }
            return
        }
    }
}

/*
Instructions:
1. Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.
2. Install the Gorilla WebSocket package by running:
       go get github.com/gorilla/websocket
3. Save this code to a file, e.g., websocket_client.go.
4. Open a terminal, navigate to the directory where you saved the file, and run:
       go run websocket_client.go

Note: Replace "app_id=1089" in the URL with your actual app_id if necessary.
*/
```

**Error Information:**
General information
Base endpoint

To connect to Deriv's WebSocket APIs, you'll need to use the following base endpoint:

wss://ws.derivws.com/websockets/v3?app_id={app_id}

Make sure to replace {app_id} with the unique ID of the application you registered.

Rate limits

The rate limits for API requests can change over time. To find out the current limit, you can make a server status call and check the api_call_limits field. This ensures you always have the most up-to-date information.

Session validity

Your WebSocket session will time out after 2 minutes of inactivity. If there are no requests or responses during this time, the server will close the connection. To prevent this, send requests periodically to keep the connection alive.

For example, you can send a ping request or another simple call like time at regular intervals.

Create WebSocket

To get started with WebSockets, you must first create a new WebSocket instance. Here‚Äôs how you can do it:

Create a WebSocket instance

Us...

---

### Error codes
**URL:** https://developers.deriv.com/docs/error-codes

**Error Information:**
General
Error Code	Message
AccountShouldBeReal	Only real accounts are allowed to open [_1] real accounts. Demo account cannot open real dxtrader.
AccountTypesMismatch	Transfer between real and virtual accounts is not allowed.
AccountWithDeposit	Change of currency is not allowed for an existing account with previous deposits.
AffiliateNotFound	N/A
AllowCopiersError	Copier can't be a trader.
AlreadyAgeVerified	Your age has already been verified.
AlreadyVerified	This account is already phone number verified.
AmountNotAllowed	The minimum amount for transfers is [_1] [_2] after conversion fees are deducted. Please adjust the amount.
AppGet	Not Found
AppRegister	Not Found
AppUpdate	N/A
AppropriatenessTestFailed	Failed to reach an acceptable trading experience score.
AuthenticateAccount	Please authenticate your [_1] account to proceed with the fund transfer.
AuthenticateAccountCreate	Please verify your [_1] account to proceed with account creation.
AuthorizationRequired	Please log in.
BadSess...

---

### Frequently Asked Questions
**URL:** https://developers.deriv.com/docs/frequently-asked-questions

**Error Handling Examples:**
```text
affiliate_token
```

```text
api_call_limits
```

```text
website_status
```

```text
api_call_limits
```

```text
website_status
```

```text
max_proposal_subscription
```

```text
max_requests_general
```

```text
max_requests_outcome
```

```text
max_requests_pricing
```

```text
website_status
```

**Error Information:**
How do you set up copy trading?

To set up copy trading on Deriv, follow these steps:

Log into your Deriv account: Ensure you‚Äôre logged into your Deriv account.
Access the Copy Trading feature: Read here to understand the developer API setup.
Choose a Trader to Copy: Review the list of available traders and their performance metrics to select a trader that aligns with your investment goals. You can use the Copy Trading Statistics API to view the performance of the selected trader.
Set Your Trading Parameters: Decide how much capital you want to allocate for copying trades and configure your risk management preferences.
Start Copying: Once set up, your account will automatically replicate the trades of your chosen trader. You can monitor and manage this at any time.

For more technical details on API setup for copy trading, Refer to the documentation here: Copy Trading.

How to add your affiliate token to your app and not miss any clients?

When creating new accounts, ensure to include...

---

### Keep connection live
**URL:** https://developers.deriv.com/docs/keep-connection-live

**Error Handling Examples:**
```text
DerivAPIBasic
```

```text
import DerivAPIBasic from 'https://cdn.skypack.dev/@deriv/deriv-api/dist/DerivAPIBasic';
```

```text
app_id
```

```text
wss://ws.derivws.com/websockets/v3?app_id=${app_id}
```

```text
const connection = new WebSocket(
```

```text
);
```

```text
DerivAPIBasic
```

```text
const api = new DerivAPIBasic({ connection });
```

```text
proposal()
```

```text
const proposal = () => {  
  api.subscribe({  
    proposal: 1,  
    subscribe: 1,  
    amount: 10,  
    basis: 'payout',  
    contract_type: 'CALL',  
    currency: 'USD',  
    duration: 1,  
    duration_unit: 'm',  
    symbol: 'R_100',  
    barrier: '+0.1',  
  });  
};
```

```text
const proposal = () => {  
  api.subscribe({  
    proposal: 1,  
    subscribe: 1,  
    amount: 10,  
    basis: 'payout',  
    contract_type: 'CALL',  
    currency: 'USD',  
    duration: 1,  
    duration_unit: 'm',  
    symbol: 'R_100',  
    barrier: '+0.1',  
  });  
};
```

```text
ping()
```

```text
ping
```

```text
setInterval
```

```text
const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000);
};
```

```text
const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000);
};
```

```text
wsResponse()
```

```text
const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error: %s ', data.error.message);
    connection.removeEventListener('message', wsResponse, false);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details: %s', data.proposal.longcode);
    console.log('Ask Price: %s', data.proposal.display_value);
    console.log('Payout: %f', data.proposal.payout);
    console.log('Spot: %f', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};
```

```text
const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error: %s ', data.error.message);
    connection.removeEventListener('message', wsResponse, false);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details: %s', data.proposal.longcode);
    console.log('Ask Price: %s', data.proposal.display_value);
    console.log('Payout: %f', data.proposal.payout);
    console.log('Spot: %f', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};
```

```text
checkSignal()
```

```text
proposal()
```

```text
ping()
```

```text
connection.addEventListener('message', wsResponse)
```

```text
wsResponse()
```

```text
const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};
```

```text
const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};
```

```text
endCall()
```

```text
unsubscribe()
```

```text
proposal()
```

```text
const endCall = () => {
  connection.removeEventListener('message', wsResponse, false);
  proposal().unsubscribe();
};
```

```text
const endCall = () => {
  connection.removeEventListener('message', wsResponse, false);
  proposal().unsubscribe();
};
```

```text
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

const app_id = app_id; // Replace with your app_id if different.
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
const api = new DerivAPIBasic({ connection });

const proposal = () => {
  api.subscribe({
    proposal: 1,
    subscribe: 1,
    amount: 10,
    basis: 'payout',
    contract_type: 'CALL',
    currency: 'USD',
    duration: 1,
    duration_unit: 'm',
    symbol: 'R_100',
    barrier: '+0.1',
  });
};

const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000); // Sends a ping message every 30 seconds
};

const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error:', data.error.message);
    connection.removeEventListener('message', wsResponse);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details:', data.proposal.longcode);
    console.log('Ask Price:', data.proposal.display_value);
    console.log('Payout:', data.proposal.payout);
    console.log('Spot:', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};

const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};

// Browser-specific functionality
if (typeof document !== 'undefined') {
  const keep_alive_button = document.querySelector('#keep_alive');
  const end_call_button = document.querySelector('#end_call');

  keep_alive_button.addEventListener('click', checkSignal);
  end_call_button.addEventListener('click', () => {
    connection.removeEventListener('message', wsResponse);
    proposal().unsubscribe();
  });
} else {
  // For Node.js environment: start the signal check immediately
  checkSignal();
}

/*
Instructions:

1. **Install Node.js**: Ensure you have Node.js installed from https://nodejs.org/.
2. **Install Deriv API Package**: Use npm to install the Deriv API package by running:
npm install @deriv/deriv-api
3. **Save the Code**: Save the code in a file, e.g., `websocket_example.js`.
4. **Run in Node.js**:
- In your terminal, navigate to the directory where you saved the file.
- Run the script using:
  ```
  node websocket_example.js
  ```
5. **Run in a Browser**:
- Include the script in your HTML page, and ensure there are two buttons with IDs `keep_alive` and `end_call`.
- Use the `keep_alive` button to start the signal check and the `end_call` button to unsubscribe from the proposal and stop receiving messages.

Replace the `app_id` in the URL if you have a different app ID.
*/
```

```text
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

const app_id = app_id; // Replace with your app_id if different.
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
const api = new DerivAPIBasic({ connection });

const proposal = () => {
  api.subscribe({
    proposal: 1,
    subscribe: 1,
    amount: 10,
    basis: 'payout',
    contract_type: 'CALL',
    currency: 'USD',
    duration: 1,
    duration_unit: 'm',
    symbol: 'R_100',
    barrier: '+0.1',
  });
};

const ping = () => {
  setInterval(() => {
    api.ping();
  }, 30000); // Sends a ping message every 30 seconds
};

const wsResponse = async (res) => {
  const data = JSON.parse(res.data);
  if (data.error !== undefined) {
    console.log('Error:', data.error.message);
    connection.removeEventListener('message', wsResponse);
    await api.disconnect();
  } else if (data.msg_type === 'proposal') {
    console.log('Details:', data.proposal.longcode);
    console.log('Ask Price:', data.proposal.display_value);
    console.log('Payout:', data.proposal.payout);
    console.log('Spot:', data.proposal.spot);
  } else if (data.msg_type === 'ping') {
    console.log('ping');
  }
};

const checkSignal = () => {
  proposal();
  ping();
  connection.addEventListener('message', wsResponse);
};

// Browser-specific functionality
if (typeof document !== 'undefined') {
  const keep_alive_button = document.querySelector('#keep_alive');
  const end_call_button = document.querySelector('#end_call');

  keep_alive_button.addEventListener('click', checkSignal);
  end_call_button.addEventListener('click', () => {
    connection.removeEventListener('message', wsResponse);
    proposal().unsubscribe();
  });
} else {
  // For Node.js environment: start the signal check immediately
  checkSignal();
}

/*
Instructions:

1. **Install Node.js**: Ensure you have Node.js installed from https://nodejs.org/.
2. **Install Deriv API Package**: Use npm to install the Deriv API package by running:
npm install @deriv/deriv-api
3. **Save the Code**: Save the code in a file, e.g., `websocket_example.js`.
4. **Run in Node.js**:
- In your terminal, navigate to the directory where you saved the file.
- Run the script using:
  ```
  node websocket_example.js
  ```
5. **Run in a Browser**:
- Include the script in your HTML page, and ensure there are two buttons with IDs `keep_alive` and `end_call`.
- Use the `keep_alive` button to start the signal check and the `end_call` button to unsubscribe from the proposal and stop receiving messages.

Replace the `app_id` in the URL if you have a different app ID.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a proposal subscription request
    func sendProposalSubscription() {
        let proposalRequest = [
            "proposal": 1,
            "subscribe": 1,
            "amount": 10,
            "basis": "payout",
            "contract_type": "CALL",
            "currency": "USD",
            "duration": 1,
            "duration_unit": "m",
            "symbol": "R_100",
            "barrier": "+0.1"
        ] as [String: Any]
        
        if let proposalData = try? JSONSerialization.data(withJSONObject: proposalRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(proposalData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send proposal subscription: \(error.localizedDescription)")
                } else {
                    print("Proposal subscription sent.")
                }
            }
        }
    }
    
    // Function to send a ping message every 30 seconds
    func startPing() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            let pingMessage = URLSessionWebSocketTask.Message.string("{\"ping\": 1}")
            webSocketTask?.send(pingMessage) { error in
                if let error = error {
                    print("[error] Failed to send ping: \(error.localizedDescription)")
                } else {
                    print("Ping sent to keep connection alive.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the proposal and ping response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "proposal", let proposal = data["proposal"] as? [String: Any] {
            print("Details: \(proposal["longcode"] ?? "")")
            print("Ask Price: \(proposal["display_value"] ?? "")")
            print("Payout: \(proposal["payout"] ?? "")")
            print("Spot: \(proposal["spot"] ?? "")")
        } else if data["msg_type"] as? String == "ping" {
            print("[Ping] Ping response received.")
        }
    }
    
    // Start sending the proposal subscription and pinging the server
    sendProposalSubscription()
    startPing()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
 * Instructions to Run:
 * 1. Ensure Swift is installed on your machine.
 * 2. Save this code in a file, for example, `WebSocketClient.swift`.
 * 3. Open a terminal, navigate to the directory where you saved the file, and run:
 *      swift WebSocketClient.swift
 * 4. The script connects to the WebSocket server, sends a proposal subscription, and sends a ping every 30 seconds to keep the connection alive.
 */
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[open] Connection established")
    
    // Function to send a proposal subscription request
    func sendProposalSubscription() {
        let proposalRequest = [
            "proposal": 1,
            "subscribe": 1,
            "amount": 10,
            "basis": "payout",
            "contract_type": "CALL",
            "currency": "USD",
            "duration": 1,
            "duration_unit": "m",
            "symbol": "R_100",
            "barrier": "+0.1"
        ] as [String: Any]
        
        if let proposalData = try? JSONSerialization.data(withJSONObject: proposalRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(proposalData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send proposal subscription: \(error.localizedDescription)")
                } else {
                    print("Proposal subscription sent.")
                }
            }
        }
    }
    
    // Function to send a ping message every 30 seconds
    func startPing() {
        Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
            let pingMessage = URLSessionWebSocketTask.Message.string("{\"ping\": 1}")
            webSocketTask?.send(pingMessage) { error in
                if let error = error {
                    print("[error] Failed to send ping: \(error.localizedDescription)")
                } else {
                    print("Ping sent to keep connection alive.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the proposal and ping response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "proposal", let proposal = data["proposal"] as? [String: Any] {
            print("Details: \(proposal["longcode"] ?? "")")
            print("Ask Price: \(proposal["display_value"] ?? "")")
            print("Payout: \(proposal["payout"] ?? "")")
            print("Spot: \(proposal["spot"] ?? "")")
        } else if data["msg_type"] as? String == "ping" {
            print("[Ping] Ping response received.")
        }
    }
    
    // Start sending the proposal subscription and pinging the server
    sendProposalSubscription()
    startPing()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
 * Instructions to Run:
 * 1. Ensure Swift is installed on your machine.
 * 2. Save this code in a file, for example, `WebSocketClient.swift`.
 * 3. Open a terminal, navigate to the directory where you saved the file, and run:
 *      swift WebSocketClient.swift
 * 4. The script connects to the WebSocket server, sends a proposal subscription, and sends a ping every 30 seconds to keep the connection alive.
 */
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{time::interval, sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[open] Connection established");

    // Proposal request JSON
    let proposal_request = json!({
        "proposal": 1,
        "subscribe": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    });

    // Clone `socket` for the ping task and start pinging every 30 seconds
    let ping_socket = Arc::clone(&socket);
    let ping_task = spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            let mut socket = ping_socket.lock().await;
            if socket.send(Message::Text(json!({ "ping": 1 }).to_string())).await.is_ok() {
                println!("[ping] Ping sent to keep connection alive.");
            }
        }
    });

    // Clone `socket` for sending the proposal
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(proposal_request.to_string())).await.is_ok() {
            println!("Proposal subscription sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if let Some(proposal) = data.get("proposal") {
                        println!("Details: {}", proposal["longcode"]);
                        println!("Ask Price: {}", proposal["display_value"]);
                        println!("Payout: {}", proposal["payout"]);
                        println!("Spot: {}", proposal["spot"]);
                    } else if data.get("msg_type").unwrap_or(&json!("")) == "ping" {
                        println!("[Ping] Ping response received.");
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(ping_task, send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{time::interval, sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;
use std::time::Duration;

#[tokio::main]
async fn main() {
    let app_id = app_id;//Replace with your app_id
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[open] Connection established");

    // Proposal request JSON
    let proposal_request = json!({
        "proposal": 1,
        "subscribe": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    });

    // Clone `socket` for the ping task and start pinging every 30 seconds
    let ping_socket = Arc::clone(&socket);
    let ping_task = spawn(async move {
        let mut interval = interval(Duration::from_secs(30));
        loop {
            interval.tick().await;
            let mut socket = ping_socket.lock().await;
            if socket.send(Message::Text(json!({ "ping": 1 }).to_string())).await.is_ok() {
                println!("[ping] Ping sent to keep connection alive.");
            }
        }
    });

    // Clone `socket` for sending the proposal
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(proposal_request.to_string())).await.is_ok() {
            println!("Proposal subscription sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if let Some(proposal) = data.get("proposal") {
                        println!("Details: {}", proposal["longcode"]);
                        println!("Ask Price: {}", proposal["display_value"]);
                        println!("Payout: {}", proposal["payout"]);
                        println!("Spot: {}", proposal["spot"]);
                    } else if data.get("msg_type").unwrap_or(&json!("")) == "ping" {
                        println!("[Ping] Ping response received.");
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(ping_task, send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a proposal subscription request
    $proposal_request = json_encode([
        "proposal" => 1,
        "subscribe" => 1,
        "amount" => 10,
        "basis" => "payout",
        "contract_type" => "CALL",
        "currency" => "USD",
        "duration" => 1,
        "duration_unit" => "m",
        "symbol" => "R_100",
        "barrier" => "+0.1"
    ]);
    $client->send($proposal_request);
    echo "[sent] Proposal subscription sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "proposal") {
            $proposal = $data["proposal"];
            echo "[proposal] Details: {$proposal['longcode']}\n";
            echo "[proposal] Ask Price: {$proposal['display_value']}\n";
            echo "[proposal] Payout: {$proposal['payout']}\n";
            echo "[proposal] Spot: {$proposal['spot']}\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `websocket_client.php`.
6. Run the code from the command line:

   php websocket_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a proposal subscription request
    $proposal_request = json_encode([
        "proposal" => 1,
        "subscribe" => 1,
        "amount" => 10,
        "basis" => "payout",
        "contract_type" => "CALL",
        "currency" => "USD",
        "duration" => 1,
        "duration_unit" => "m",
        "symbol" => "R_100",
        "barrier" => "+0.1"
    ]);
    $client->send($proposal_request);
    echo "[sent] Proposal subscription sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "proposal") {
            $proposal = $data["proposal"];
            echo "[proposal] Details: {$proposal['longcode']}\n";
            echo "[proposal] Ask Price: {$proposal['display_value']}\n";
            echo "[proposal] Payout: {$proposal['payout']}\n";
            echo "[proposal] Spot: {$proposal['spot']}\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `websocket_client.php`.
6. Run the code from the command line:

   php websocket_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// Define constants
const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//Replace with your app_id
)

// ProposalRequest defines the structure of the proposal subscription request
type ProposalRequest struct {
	Proposal      int    `json:"proposal"`
	Subscribe     int    `json:"subscribe"`
	Amount        int    `json:"amount"`
	Basis         string `json:"basis"`
	ContractType  string `json:"contract_type"`
	Currency      string `json:"currency"`
	Duration      int    `json:"duration"`
	DurationUnit  string `json:"duration_unit"`
	Symbol        string `json:"symbol"`
	Barrier       string `json:"barrier"`
}

func main() {
	// Set up WebSocket connection context
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish a WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("WebSocket connection established.")

	// Send initial proposal subscription request
	err = sendProposalRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send proposal request: %v", err)
	}

	// Start keep-alive ping
	go keepAlivePing(ctx, conn)

	// Handle incoming messages
	handleResponses(ctx, conn)
}

// sendProposalRequest sends a proposal subscription request to the WebSocket server
func sendProposalRequest(ctx context.Context, conn *websocket.Conn) error {
	// Construct proposal subscription request
	proposal := ProposalRequest{
		Proposal:     1,
		Subscribe:    1,
		Amount:       10,
		Basis:        "payout",
		ContractType: "CALL",
		Currency:     "USD",
		Duration:     1,
		DurationUnit: "m",
		Symbol:       "R_100",
		Barrier:      "+0.1",
	}
	fmt.Println("Sending proposal subscription...")

	return wsjson.Write(ctx, conn, proposal)
}

// keepAlivePing sends a ping message every 30 seconds to keep the connection alive
func keepAlivePing(ctx context.Context, conn *websocket.Conn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Send ping message
			pingMsg := map[string]int{"ping": 1}
			err := wsjson.Write(ctx, conn, pingMsg)
			if err != nil {
				log.Printf("Ping failed: %v", err)
				return
			}
			fmt.Println("Ping sent.")
		case <-ctx.Done():
			return
		}
	}
}

// handleResponses listens for and processes messages received from the WebSocket server
func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}
		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		// Process response messages
		msgType := response["msg_type"]
		switch msgType {
		case "proposal":
			// Print proposal details
			proposal := response["proposal"].(map[string]interface{})
			fmt.Printf("Details: %v\n", proposal["longcode"])
			fmt.Printf("Ask Price: %v\n", proposal["display_value"])
			fmt.Printf("Payout: %v\n", proposal["payout"])
			fmt.Printf("Spot: %v\n", proposal["spot"])
		case "ping":
			fmt.Println("[Ping] Ping response received.")
		default:
			fmt.Printf("Received message: %v\n", response)
		}
	}
}

/*
Instructions to run the code locally:

1. Install Go: Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.

2. Save the code:
   - Save this code into a file named `connect.go`.

3. Initialize a Go module:
   - Open a terminal in the directory containing `connect.go`.
   - Run `go mod init app` to initialize a new Go module.
   - Run `go get nhooyr.io/websocket` to install the WebSocket package dependency.

4. Run the code:
   - Execute the code using the command `go run connect.go`.
   - Alternatively, you can build and run the executable:
     ```
     go build -o connect connect.go
     ./connect
     ```
5. Replace `app_id=1089` with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

// Define constants
const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//Replace with your app_id
)

// ProposalRequest defines the structure of the proposal subscription request
type ProposalRequest struct {
	Proposal      int    `json:"proposal"`
	Subscribe     int    `json:"subscribe"`
	Amount        int    `json:"amount"`
	Basis         string `json:"basis"`
	ContractType  string `json:"contract_type"`
	Currency      string `json:"currency"`
	Duration      int    `json:"duration"`
	DurationUnit  string `json:"duration_unit"`
	Symbol        string `json:"symbol"`
	Barrier       string `json:"barrier"`
}

func main() {
	// Set up WebSocket connection context
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish a WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("WebSocket connection established.")

	// Send initial proposal subscription request
	err = sendProposalRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send proposal request: %v", err)
	}

	// Start keep-alive ping
	go keepAlivePing(ctx, conn)

	// Handle incoming messages
	handleResponses(ctx, conn)
}

// sendProposalRequest sends a proposal subscription request to the WebSocket server
func sendProposalRequest(ctx context.Context, conn *websocket.Conn) error {
	// Construct proposal subscription request
	proposal := ProposalRequest{
		Proposal:     1,
		Subscribe:    1,
		Amount:       10,
		Basis:        "payout",
		ContractType: "CALL",
		Currency:     "USD",
		Duration:     1,
		DurationUnit: "m",
		Symbol:       "R_100",
		Barrier:      "+0.1",
	}
	fmt.Println("Sending proposal subscription...")

	return wsjson.Write(ctx, conn, proposal)
}

// keepAlivePing sends a ping message every 30 seconds to keep the connection alive
func keepAlivePing(ctx context.Context, conn *websocket.Conn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Send ping message
			pingMsg := map[string]int{"ping": 1}
			err := wsjson.Write(ctx, conn, pingMsg)
			if err != nil {
				log.Printf("Ping failed: %v", err)
				return
			}
			fmt.Println("Ping sent.")
		case <-ctx.Done():
			return
		}
	}
}

// handleResponses listens for and processes messages received from the WebSocket server
func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}
		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		// Process response messages
		msgType := response["msg_type"]
		switch msgType {
		case "proposal":
			// Print proposal details
			proposal := response["proposal"].(map[string]interface{})
			fmt.Printf("Details: %v\n", proposal["longcode"])
			fmt.Printf("Ask Price: %v\n", proposal["display_value"])
			fmt.Printf("Payout: %v\n", proposal["payout"])
			fmt.Printf("Spot: %v\n", proposal["spot"])
		case "ping":
			fmt.Println("[Ping] Ping response received.")
		default:
			fmt.Printf("Received message: %v\n", response)
		}
	}
}

/*
Instructions to run the code locally:

1. Install Go: Ensure you have Go installed on your machine. You can download it from https://golang.org/dl/.

2. Save the code:
   - Save this code into a file named `connect.go`.

3. Initialize a Go module:
   - Open a terminal in the directory containing `connect.go`.
   - Run `go mod init app` to initialize a new Go module.
   - Run `go get nhooyr.io/websocket` to install the WebSocket package dependency.

4. Run the code:
   - Execute the code using the command `go run connect.go`.
   - Alternatively, you can build and run the executable:
     ```
     go build -o connect connect.go
     ./connect
     ```
5. Replace `app_id=1089` with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed
    private static readonly int pingInterval = 30000; // Ping every 30 seconds

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("WebSocket connection established.");

            // Send initial proposal subscription request
            await SendProposalSubscription(webSocket);

            // Start a task to send pings to keep connection alive
            Task keepAlivePingTask = KeepAlivePing(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);

            // Ensure the keep-alive ping task finishes
            await keepAlivePingTask;
        }
    }

    private static async Task SendProposalSubscription(ClientWebSocket webSocket)
    {
        var proposalRequest = new
        {
            proposal = 1,
            subscribe = 1,
            amount = 10,
            basis = "payout",
            contract_type = "CALL",
            currency = "USD",
            duration = 1,
            duration_unit = "m",
            symbol = "R_100",
            barrier = "+0.1"
        };

        string requestJson = JsonSerializer.Serialize(proposalRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("Proposal subscription sent.");
    }

    private static async Task KeepAlivePing(ClientWebSocket webSocket)
    {
        while (webSocket.State == WebSocketState.Open)
        {
            await Task.Delay(pingInterval);

            var pingRequest = new { ping = 1 };
            string pingJson = JsonSerializer.Serialize(pingRequest);
            var pingBytes = Encoding.UTF8.GetBytes(pingJson);
            await webSocket.SendAsync(new ArraySegment<byte>(pingBytes), WebSocketMessageType.Text, true, CancellationToken.None);
            Console.WriteLine("Ping sent to keep connection alive.");
        }
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[1024 * 4];

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        else
        {
            string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
            var data = JsonSerializer.Deserialize<JsonElement>(response);

            if (data.TryGetProperty("error", out var error))
            {
                Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                break;
            }

            if (data.TryGetProperty("msg_type", out var msgType))
            {
                if (msgType.GetString() == "proposal")
                {
                    var proposal = data.GetProperty("proposal");

                    // Extract proposal details with type-checking
                    string longcode = proposal.GetProperty("longcode").GetString();
                    Console.WriteLine($"Details: {longcode}");

                    string displayValue = proposal.GetProperty("display_value").GetRawText();
                    Console.WriteLine($"Ask Price: {displayValue}");

                    string payout = proposal.GetProperty("payout").GetRawText();
                    Console.WriteLine($"Payout: {payout}");

                    string spot = proposal.GetProperty("spot").GetRawText();
                    Console.WriteLine($"Spot: {spot}");
                }
                else if (msgType.GetString() == "ping")
                {
                    Console.WriteLine("[Ping] Ping response received.");
                }
            }
        }
    }
}
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed
    private static readonly int pingInterval = 30000; // Ping every 30 seconds

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("WebSocket connection established.");

            // Send initial proposal subscription request
            await SendProposalSubscription(webSocket);

            // Start a task to send pings to keep connection alive
            Task keepAlivePingTask = KeepAlivePing(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);

            // Ensure the keep-alive ping task finishes
            await keepAlivePingTask;
        }
    }

    private static async Task SendProposalSubscription(ClientWebSocket webSocket)
    {
        var proposalRequest = new
        {
            proposal = 1,
            subscribe = 1,
            amount = 10,
            basis = "payout",
            contract_type = "CALL",
            currency = "USD",
            duration = 1,
            duration_unit = "m",
            symbol = "R_100",
            barrier = "+0.1"
        };

        string requestJson = JsonSerializer.Serialize(proposalRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("Proposal subscription sent.");
    }

    private static async Task KeepAlivePing(ClientWebSocket webSocket)
    {
        while (webSocket.State == WebSocketState.Open)
        {
            await Task.Delay(pingInterval);

            var pingRequest = new { ping = 1 };
            string pingJson = JsonSerializer.Serialize(pingRequest);
            var pingBytes = Encoding.UTF8.GetBytes(pingJson);
            await webSocket.SendAsync(new ArraySegment<byte>(pingBytes), WebSocketMessageType.Text, true, CancellationToken.None);
            Console.WriteLine("Ping sent to keep connection alive.");
        }
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[1024 * 4];

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
        }
        else
        {
            string response = Encoding.UTF8.GetString(buffer, 0, result.Count);
            var data = JsonSerializer.Deserialize<JsonElement>(response);

            if (data.TryGetProperty("error", out var error))
            {
                Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                break;
            }

            if (data.TryGetProperty("msg_type", out var msgType))
            {
                if (msgType.GetString() == "proposal")
                {
                    var proposal = data.GetProperty("proposal");

                    // Extract proposal details with type-checking
                    string longcode = proposal.GetProperty("longcode").GetString();
                    Console.WriteLine($"Details: {longcode}");

                    string displayValue = proposal.GetProperty("display_value").GetRawText();
                    Console.WriteLine($"Ask Price: {displayValue}");

                    string payout = proposal.GetProperty("payout").GetRawText();
                    Console.WriteLine($"Payout: {payout}");

                    string spot = proposal.GetProperty("spot").GetRawText();
                    Console.WriteLine($"Spot: {spot}");
                }
                else if (msgType.GetString() == "ping")
                {
                    Console.WriteLine("[Ping] Ping response received.");
                }
            }
        }
    }
}
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>
#include <time.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a proposal subscription message
void send_proposal(struct lws *wsi) {
    const char *proposal_msg = "{\"proposal\": 1, \"subscribe\": 1, \"amount\": 10, \"basis\": \"payout\", \"contract_type\": \"CALL\", \"currency\": \"USD\", \"duration\": 1, \"duration_unit\": \"m\", \"symbol\": \"R_100\", \"barrier\": \"+0.1\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], proposal_msg, strlen(proposal_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(proposal_msg), LWS_WRITE_TEXT);
    lwsl_user("Proposal subscription sent\n");
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_proposal(wsi);  // Send proposal on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <string.h>
#include <signal.h>
#include <time.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a proposal subscription message
void send_proposal(struct lws *wsi) {
    const char *proposal_msg = "{\"proposal\": 1, \"subscribe\": 1, \"amount\": 10, \"basis\": \"payout\", \"contract_type\": \"CALL\", \"currency\": \"USD\", \"duration\": 1, \"duration_unit\": \"m\", \"symbol\": \"R_100\", \"barrier\": \"+0.1\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], proposal_msg, strlen(proposal_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(proposal_msg), LWS_WRITE_TEXT);
    lwsl_user("Proposal subscription sent\n");
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_proposal(wsi);  // Send proposal on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        lwsl_hexdump_notice(in, len); // Log received message
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("LWS Deriv ws client\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("Completed\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the libwebsockets library on your system if it's not already installed.
 *    - On Ubuntu, you can install it by running:
 *        sudo apt-get install libwebsockets-dev
 *    - On macOS, you can use Homebrew:
 *        brew install libwebsockets
 *    - For other operating systems, refer to the libwebsockets documentation for installation details.
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -lssl -lcrypto -lm
 *    - This command links the required libraries: `libwebsockets`, `ssl`, `crypto`, and `m`.
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
import asyncio
from deriv_api import DerivAPI
from deriv_api.subscription_manager import SubscriptionManager

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    # Initialize the SubscriptionManager
    subscription_manager = SubscriptionManager(api)

    # Define the proposal request
    proposal_request = {
        "proposal": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    }

    # Subscribe to the proposal stream
    try:
        proposal_stream = await subscription_manager.subscribe(proposal_request)
        print("Subscribed to proposal stream")

        # Handle incoming messages and print formatted proposal details
        proposal_stream.subscribe(
            on_next=lambda message: print_proposal_details(message),
            on_error=lambda e: print(f"Error: {e}"),
            on_completed=lambda: print("Subscription completed")
        )

        # Function to send a ping every 30 seconds
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop and proposal subscription concurrently
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print proposal details
def print_proposal_details(message):
    data = message.get("proposal", {})
    if data:
        print(f"Details: {data.get('longcode', 'N/A')}")
        print(f"Ask Price: {data.get('display_value', 'N/A')}")
        print(f"Payout: {data.get('payout', 'N/A')}")
        print(f"Spot: {data.get('spot', 'N/A')}")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

"""
Instructions to run this code:

1. **Install the Required Library**:
   - Ensure that `python-deriv-api` is installed. If not, install it using:
     ```
     pip install python-deriv-api
     ```
2. **Save and Run the Code**:
   - Save this code to a file, e.g., `connect.py`.
   - Run the script using:
     ```
     python connect.py
     ```
3. **Configuration**:
   - Replace the `app_id` variable with your actual Deriv app ID if needed.

This script will connect to the Deriv API WebSocket, subscribe to a proposal stream, print proposal details, and send a ping every 30 seconds to keep the connection active. 
"""
```

```text
import asyncio
from deriv_api import DerivAPI
from deriv_api.subscription_manager import SubscriptionManager

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    # Initialize the SubscriptionManager
    subscription_manager = SubscriptionManager(api)

    # Define the proposal request
    proposal_request = {
        "proposal": 1,
        "amount": 10,
        "basis": "payout",
        "contract_type": "CALL",
        "currency": "USD",
        "duration": 1,
        "duration_unit": "m",
        "symbol": "R_100",
        "barrier": "+0.1"
    }

    # Subscribe to the proposal stream
    try:
        proposal_stream = await subscription_manager.subscribe(proposal_request)
        print("Subscribed to proposal stream")

        # Handle incoming messages and print formatted proposal details
        proposal_stream.subscribe(
            on_next=lambda message: print_proposal_details(message),
            on_error=lambda e: print(f"Error: {e}"),
            on_completed=lambda: print("Subscription completed")
        )

        # Function to send a ping every 30 seconds
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop and proposal subscription concurrently
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print proposal details
def print_proposal_details(message):
    data = message.get("proposal", {})
    if data:
        print(f"Details: {data.get('longcode', 'N/A')}")
        print(f"Ask Price: {data.get('display_value', 'N/A')}")
        print(f"Payout: {data.get('payout', 'N/A')}")
        print(f"Spot: {data.get('spot', 'N/A')}")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

"""
Instructions to run this code:

1. **Install the Required Library**:
   - Ensure that `python-deriv-api` is installed. If not, install it using:
     ```
     pip install python-deriv-api
     ```
2. **Save and Run the Code**:
   - Save this code to a file, e.g., `connect.py`.
   - Run the script using:
     ```
     python connect.py
     ```
3. **Configuration**:
   - Replace the `app_id` variable with your actual Deriv app ID if needed.

This script will connect to the Deriv API WebSocket, subscribe to a proposal stream, print proposal details, and send a ping every 30 seconds to keep the connection active. 
"""
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Define a ping interval in seconds
my $ping_interval = 30;

# Function to send a proposal subscription request
sub send_proposal {
    my $connection = shift;
    my $proposal_request = encode_json({
        proposal       => 1,
        subscribe      => 1,
        amount         => 10,
        basis          => 'payout',
        contract_type  => 'CALL',
        currency       => 'USD',
        duration       => 1,
        duration_unit  => 'm',
        symbol         => 'R_100',
        barrier        => '+0.1'
    });
    $connection->send($proposal_request);
    say "Proposal subscription sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "WebSocket connection established.";

    # Set up a repeating timer to send ping every 30 seconds
    my $ping_timer = AnyEvent->timer(
        after    => $ping_interval,
        interval => $ping_interval,
        cb       => sub {
            $connection->send(encode_json({ ping => 1 }));
            say "Ping sent to keep connection alive.";
        }
    );

    # Send the initial proposal subscription
    send_proposal($connection);

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;
        my $data = decode_json($message->body);

        # Handle errors
        if ($data->{error}) {
            say "[Error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle proposal messages
        if ($data->{msg_type} && $data->{msg_type} eq 'proposal') {
            my $proposal = $data->{proposal};
            say "Details: $proposal->{longcode}";
            say "Ask Price: $proposal->{display_value}";
            say "Payout: $proposal->{payout}";
            say "Spot: $proposal->{spot}";
        } elsif ($data->{msg_type} && $data->{msg_type} eq 'ping') {
            say "[Ping] Ping response received.";
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
        $ping_timer = undef;  # Stop the ping timer
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Define a ping interval in seconds
my $ping_interval = 30;

# Function to send a proposal subscription request
sub send_proposal {
    my $connection = shift;
    my $proposal_request = encode_json({
        proposal       => 1,
        subscribe      => 1,
        amount         => 10,
        basis          => 'payout',
        contract_type  => 'CALL',
        currency       => 'USD',
        duration       => 1,
        duration_unit  => 'm',
        symbol         => 'R_100',
        barrier        => '+0.1'
    });
    $connection->send($proposal_request);
    say "Proposal subscription sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "WebSocket connection established.";

    # Set up a repeating timer to send ping every 30 seconds
    my $ping_timer = AnyEvent->timer(
        after    => $ping_interval,
        interval => $ping_interval,
        cb       => sub {
            $connection->send(encode_json({ ping => 1 }));
            say "Ping sent to keep connection alive.";
        }
    );

    # Send the initial proposal subscription
    send_proposal($connection);

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;
        my $data = decode_json($message->body);

        # Handle errors
        if ($data->{error}) {
            say "[Error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle proposal messages
        if ($data->{msg_type} && $data->{msg_type} eq 'proposal') {
            my $proposal = $data->{proposal};
            say "Details: $proposal->{longcode}";
            say "Ask Price: $proposal->{display_value}";
            say "Payout: $proposal->{payout}";
            say "Spot: $proposal->{spot}";
        } elsif ($data->{msg_type} && $data->{msg_type} eq 'ping') {
            say "[Ping] Ping response received.";
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "WebSocket connection closed.";
        $ping_timer = undef;  # Stop the ping timer
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, subscribe to a proposal, and send a ping every 30 seconds to keep the connection alive.
```

**Error Information:**
Follow these steps to maintain a live WebSocket connection with the Deriv API:

Import the Deriv API library

Import the DerivAPIBasic library, which provides an interface to interact with the Deriv WebSocket API:

import DerivAPIBasic from 'https://cdn.skypack.dev/@deriv/deriv-api/dist/DerivAPIBasic';

Establish a WebSocket connection

Create a WebSocket connection using your app_id and the API URL:

(wss://ws.derivws.com/websockets/v3?app_id=${app_id}).

This connection will be used to send and receive messages from the Deriv API.

const connection = new WebSocket(wss://ws.derivws.com/websockets/v3?app_id=${app_id});

Create an API object

Create an instance of DerivAPIBasic, passing the WebSocket connection as a parameter.

This object interacts with the API, such as subscribing to proposals and sending pings.

const api = new DerivAPIBasic({ connection });

Send a proposal subscription

The proposal() function subscribes to a proposal and sends details such as the trade amount, cur...

---

### Check website status
**URL:** https://developers.deriv.com/docs/check-website-status

**Error Handling Examples:**
```text
DerivAPIBasic
```

```text
app_id
```

```text
DerivAPIBasic
```

```text
websiteStatusResponse
```

```text
getWebsiteStatus
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication,replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the website status response
const handleWebsiteStatusResponse = async (response) => {
  const data = JSON.parse(response.data);

  // If there's an error in the response, log the error message and disconnect
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'website_status', log the relevant details
  if (data.msg_type === 'website_status') {
    const websiteStatus = data.website_status;
    console.log('Website Status:', websiteStatus.site_status);
    console.log('Available Languages:', websiteStatus.supported_languages);
    console.log('Terms & Conditions Version:', websiteStatus.terms_conditions_version);
    console.log('Broker Codes:', websiteStatus.broker_codes);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleWebsiteStatusResponse);
};

// Function to request website status from the API
const requestWebsiteStatus = async () => {
  connection.addEventListener('message', handleWebsiteStatusResponse); // Add the event listener for response
  await api.websiteStatus(); // Send the website status request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const website_status_button = document.querySelector('#websiteStatus');
  if (website_status_button) {
    website_status_button.addEventListener('click', requestWebsiteStatus);
  }
} else {
  // If running in Node.js, directly call the function
  requestWebsiteStatus();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `connect.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node connect.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="websiteStatus">Check Website Status</button>`
 * - Open the HTML file in a browser, and click the button to check the website status.
 */
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication,replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the website status response
const handleWebsiteStatusResponse = async (response) => {
  const data = JSON.parse(response.data);

  // If there's an error in the response, log the error message and disconnect
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'website_status', log the relevant details
  if (data.msg_type === 'website_status') {
    const websiteStatus = data.website_status;
    console.log('Website Status:', websiteStatus.site_status);
    console.log('Available Languages:', websiteStatus.supported_languages);
    console.log('Terms & Conditions Version:', websiteStatus.terms_conditions_version);
    console.log('Broker Codes:', websiteStatus.broker_codes);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleWebsiteStatusResponse);
};

// Function to request website status from the API
const requestWebsiteStatus = async () => {
  connection.addEventListener('message', handleWebsiteStatusResponse); // Add the event listener for response
  await api.websiteStatus(); // Send the website status request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const website_status_button = document.querySelector('#websiteStatus');
  if (website_status_button) {
    website_status_button.addEventListener('click', requestWebsiteStatus);
  }
} else {
  // If running in Node.js, directly call the function
  requestWebsiteStatus();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `connect.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node connect.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="websiteStatus">Check Website Status</button>`
 * - Open the HTML file in a browser, and click the button to check the website status.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send website status request
                    JsonObject websiteStatusRequest = new JsonObject();
                    websiteStatusRequest.addProperty("website_status", 1);
                    send(websiteStatusRequest.toString());
                    System.out.println("[sent] Website status request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("website_status".equals(data.get("msg_type").getAsString())) {
                        JsonObject websiteStatus = data.getAsJsonObject("website_status");
                        String siteStatus = websiteStatus.get("site_status").getAsString();
                        System.out.println("Website Status: " + siteStatus);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.


 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send website status request
                    JsonObject websiteStatusRequest = new JsonObject();
                    websiteStatusRequest.addProperty("website_status", 1);
                    send(websiteStatusRequest.toString());
                    System.out.println("[sent] Website status request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("website_status".equals(data.get("msg_type").getAsString())) {
                        JsonObject websiteStatus = data.getAsJsonObject("website_status");
                        String siteStatus = websiteStatus.get("site_status").getAsString();
                        System.out.println("Website Status: " + siteStatus);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.


 */
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a website status request
sub send_website_status {
    my $connection = shift;
    my $website_status_request = encode_json({ website_status => 1 });
    $connection->send($website_status_request);
    say "[status] Website status request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send website status request immediately
    send_website_status($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle website status response
        if ($data->{msg_type} && $data->{msg_type} eq 'website_status') {
            my $website_status = $data->{website_status};
            say "Site Status: " . ($website_status->{site_status} // 'Unknown');
            say "Supported Languages: " . join(", ", @{$website_status->{supported_languages}});
            $connection->close; # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, request the website status, and print the response.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a website status request
sub send_website_status {
    my $connection = shift;
    my $website_status_request = encode_json({ website_status => 1 });
    $connection->send($website_status_request);
    say "[status] Website status request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send website status request immediately
    send_website_status($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Handle website status response
        if ($data->{msg_type} && $data->{msg_type} eq 'website_status') {
            my $website_status = $data->{website_status};
            say "Site Status: " . ($website_status->{site_status} // 'Unknown');
            say "Supported Languages: " . join(", ", @{$website_status->{supported_languages}});
            $connection->close; # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `connect.pl`.
# 4. Run the script using the command:
#      perl connect.pl
# This script will connect to the Deriv WebSocket API, request the website status, and print the response.
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a website status request
    $website_status_request = json_encode(["website_status" => 1]);
    $client->send($website_status_request);
    echo "[sent] Website status request sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "website_status") {
            $website_status = $data["website_status"];

            // Print important information from the website status
            echo "[status] Website Status:\n";
            echo "  - Site Status: " . ($website_status["site_status"] ?? "N/A") . "\n";
            echo "  - Supported Languages: " . implode(", ", $website_status["supported_languages"] ?? []) . "\n";

            // Extract and print currency information
            echo "  - Currencies Config:\n";
            foreach ($website_status["currencies_config"] ?? [] as $currency => $config) {
                echo "    * {$currency} ({$config['name']}):\n";
                echo "      - Type: " . ($config["type"] ?? "N/A") . "\n";
                echo "      - Fractional Digits: " . ($config["fractional_digits"] ?? "N/A") . "\n";
                echo "      - Deposit Suspended: " . ($config["is_deposit_suspended"] ? "Yes" : "No") . "\n";
                echo "      - Withdrawal Suspended: " . ($config["is_withdrawal_suspended"] ? "Yes" : "No") . "\n";
            }

            echo "[status] End of Website Status Response.\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `website_status_client.php`.
6. Run the code from the command line:

   php website_status_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
<?php

require 'vendor/autoload.php';

use WebSocket\Client;

// Replace with your app_id
$app_id = app_id;
$uri = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

// Create a new WebSocket client
$client = new Client($uri);

try {
    echo "[open] WebSocket connection established.\n";

    // Send a website status request
    $website_status_request = json_encode(["website_status" => 1]);
    $client->send($website_status_request);
    echo "[sent] Website status request sent.\n";

    // Ping function to keep connection alive
    $ping_interval = 30; // in seconds
    $last_ping_time = time();

    // Main loop to handle responses and send ping messages
    while (true) {
        // Check if it's time to send a ping
        if (time() - $last_ping_time >= $ping_interval) {
            $client->send(json_encode(["ping" => 1]));
            echo "[ping] Ping sent to keep connection alive.\n";
            $last_ping_time = time();
        }

        // Receive response from WebSocket
        $response = $client->receive();
        $data = json_decode($response, true);

        if (isset($data["error"])) {
            echo "[error] " . $data["error"]["message"] . "\n";
            break;
        } elseif ($data["msg_type"] === "website_status") {
            $website_status = $data["website_status"];

            // Print important information from the website status
            echo "[status] Website Status:\n";
            echo "  - Site Status: " . ($website_status["site_status"] ?? "N/A") . "\n";
            echo "  - Supported Languages: " . implode(", ", $website_status["supported_languages"] ?? []) . "\n";

            // Extract and print currency information
            echo "  - Currencies Config:\n";
            foreach ($website_status["currencies_config"] ?? [] as $currency => $config) {
                echo "    * {$currency} ({$config['name']}):\n";
                echo "      - Type: " . ($config["type"] ?? "N/A") . "\n";
                echo "      - Fractional Digits: " . ($config["fractional_digits"] ?? "N/A") . "\n";
                echo "      - Deposit Suspended: " . ($config["is_deposit_suspended"] ? "Yes" : "No") . "\n";
                echo "      - Withdrawal Suspended: " . ($config["is_withdrawal_suspended"] ? "Yes" : "No") . "\n";
            }

            echo "[status] End of Website Status Response.\n";
        } elseif ($data["msg_type"] === "ping") {
            echo "[ping] Ping response received.\n";
        }

        // Sleep briefly to prevent continuous loop
        usleep(500000); // 500ms
    }

    // Close the WebSocket connection
    $client->close();
    echo "[close] WebSocket connection closed.\n";

} catch (Exception $e) {
    echo "[error] " . $e->getMessage() . "\n";
}

/*
Instructions to run the code:

1. Ensure PHP is installed on your machine. You can download it from https://www.php.net/.
2. Install Composer if you haven't already, by downloading it from https://getcomposer.org/.
3. Create a `composer.json` file in the same directory as your PHP script with the following content:

   {
     "require": {
       "textalk/websocket": "^1.5"
     }
   }

4. Run the following command to install the WebSocket library:

   composer install

5. Save the code above to a PHP file, e.g., `website_status_client.php`.
6. Run the code from the command line:

   php website_status_client.php

Note: Replace `app_id` with your actual app_id if needed.
*/
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a website status request
        website_status_request = {"website_status": 1}
        response = await api.send(website_status_request)
        print("Website status request sent")

        # Process the response and print important information
        print_website_status(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print website status details
def print_website_status(response):
    data = response.get("website_status", {})
    if data:
        print("[Website Status]")
        print(f"  - Site Status: {data.get('site_status', 'N/A')}")
        print("  - Supported Languages:", ", ".join(data.get("supported_languages", [])))

        # Display currency configurations
        currencies_config = data.get("currencies_config", {})
        print("  - Currencies Config:")
        for currency, config in currencies_config.items():
            print(f"    * {currency} ({config.get('name', 'N/A')}):")
            print(f"      - Type: {config.get('type', 'N/A')}")
            print(f"      - Fractional Digits: {config.get('fractional_digits', 'N/A')}")
            print(f"      - Deposit Suspended: {'Yes' if config.get('is_deposit_suspended') else 'No'}")
            print(f"      - Withdrawal Suspended: {'Yes' if config.get('is_withdrawal_suspended') else 'No'}")
        print("[End of Website Status Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `website_status_client.py`.
# 4. Run the code from the command line:
#      python website_status_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request the website status, and send pings every 30 seconds to keep the connection alive.
# The response includes important details about the website status and configuration for each currency.
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a website status request
        website_status_request = {"website_status": 1}
        response = await api.send(website_status_request)
        print("Website status request sent")

        # Process the response and print important information
        print_website_status(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print website status details
def print_website_status(response):
    data = response.get("website_status", {})
    if data:
        print("[Website Status]")
        print(f"  - Site Status: {data.get('site_status', 'N/A')}")
        print("  - Supported Languages:", ", ".join(data.get("supported_languages", [])))

        # Display currency configurations
        currencies_config = data.get("currencies_config", {})
        print("  - Currencies Config:")
        for currency, config in currencies_config.items():
            print(f"    * {currency} ({config.get('name', 'N/A')}):")
            print(f"      - Type: {config.get('type', 'N/A')}")
            print(f"      - Fractional Digits: {config.get('fractional_digits', 'N/A')}")
            print(f"      - Deposit Suspended: {'Yes' if config.get('is_deposit_suspended') else 'No'}")
            print(f"      - Withdrawal Suspended: {'Yes' if config.get('is_withdrawal_suspended') else 'No'}")
        print("[End of Website Status Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `website_status_client.py`.
# 4. Run the code from the command line:
#      python website_status_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request the website status, and send pings every 30 seconds to keep the connection alive.
# The response includes important details about the website status and configuration for each currency.
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Website status request JSON
    let website_status_request = json!({
        "website_status": 1
    });

    // Clone `socket` to send the website status request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(website_status_request.to_string())).await.is_ok() {
            println!("[status] Website status request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "website_status" {
                        println!("[Website Status] Site Status: {}", data["website_status"]["site_status"]);
                        let supported_languages: Vec<String> = data["website_status"]["supported_languages"]
                            .as_array()
                            .unwrap_or(&vec![])
                            .iter()
                            .filter_map(|lang| lang.as_str().map(|s| s.to_string()))
                            .collect();
                        println!("Supported Languages: {:?}", supported_languages);
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request the website status, print the website's status, supported languages, and handle any potential errors in the response.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Website status request JSON
    let website_status_request = json!({
        "website_status": 1
    });

    // Clone `socket` to send the website status request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(website_status_request.to_string())).await.is_ok() {
            println!("[status] Website status request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "website_status" {
                        println!("[Website Status] Site Status: {}", data["website_status"]["site_status"]);
                        let supported_languages: Vec<String> = data["website_status"]["supported_languages"]
                            .as_array()
                            .unwrap_or(&vec![])
                            .iter()
                            .filter_map(|lang| lang.as_str().map(|s| s.to_string()))
                            .collect();
                        println!("Supported Languages: {:?}", supported_languages);
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request the website status, print the website's status, supported languages, and handle any potential errors in the response.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run the code:

1. Ensure Swift is installed on your machine. You can use Xcode or install the Swift toolchain from https://swift.org/.
2. Create a new Swift file (e.g., `WebSocketClient.swift`) and paste the code above.
3. Open a terminal and navigate to the directory where the file is saved.
4. Run the code with the following command:

   swift WebSocketClient.swift

5. The program will connect to the Deriv WebSocket API, request the website status, and print the site's operational status and supported languages.
6. To stop the program, press `Ctrl+C` in the terminal.

Note: Replace `app_id` with your actual app_id if required.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()

/*
Instructions to run the code:

1. Ensure Swift is installed on your machine. You can use Xcode or install the Swift toolchain from https://swift.org/.
2. Create a new Swift file (e.g., `WebSocketClient.swift`) and paste the code above.
3. Open a terminal and navigate to the directory where the file is saved.
4. Run the code with the following command:

   swift WebSocketClient.swift

5. The program will connect to the Deriv WebSocket API, request the website status, and print the site's operational status and supported languages.
6. To stop the program, press `Ctrl+C` in the terminal.

Note: Replace `app_id` with your actual app_id if required.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send website status request
            await SendWebsiteStatusRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendWebsiteStatusRequest(ClientWebSocket webSocket)
    {
        var websiteStatusRequest = new { website_status = 1 };

        string requestJson = JsonSerializer.Serialize(websiteStatusRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[status] Website status request sent.");
    }

 private static async Task HandleResponses(ClientWebSocket webSocket)
 {
     var buffer = new byte[8192]; // Increased buffer size

     while (webSocket.State == WebSocketState.Open)
     {
         var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

         if (result.MessageType == WebSocketMessageType.Close)
         {
             Console.WriteLine("WebSocket connection closed by server.");
             await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
         }
         else
         {
             // Append received bytes to a string builder
             var response = Encoding.UTF8.GetString(buffer, 0, result.Count);
             var data = JsonDocument.Parse(response).RootElement;

             // Check for "error" in the response
             if (data.TryGetProperty("error", out var error))
             {
                 Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                 await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                 break;
             }

             // Process the "msg_type" property
             if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "website_status")
             {
                 var websiteStatus = data.GetProperty("website_status");
                 Console.WriteLine("Site Status: " + websiteStatus.GetProperty("site_status").GetString());
                 Console.WriteLine("Supported Languages: " + websiteStatus.GetProperty("supported_languages").ToString());
             }
         }
     }
 }
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send website status request
            await SendWebsiteStatusRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendWebsiteStatusRequest(ClientWebSocket webSocket)
    {
        var websiteStatusRequest = new { website_status = 1 };

        string requestJson = JsonSerializer.Serialize(websiteStatusRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[status] Website status request sent.");
    }

 private static async Task HandleResponses(ClientWebSocket webSocket)
 {
     var buffer = new byte[8192]; // Increased buffer size

     while (webSocket.State == WebSocketState.Open)
     {
         var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

         if (result.MessageType == WebSocketMessageType.Close)
         {
             Console.WriteLine("WebSocket connection closed by server.");
             await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
         }
         else
         {
             // Append received bytes to a string builder
             var response = Encoding.UTF8.GetString(buffer, 0, result.Count);
             var data = JsonDocument.Parse(response).RootElement;

             // Check for "error" in the response
             if (data.TryGetProperty("error", out var error))
             {
                 Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                 await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                 break;
             }

             // Process the "msg_type" property
             if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "website_status")
             {
                 var websiteStatus = data.GetProperty("website_status");
                 Console.WriteLine("Site Status: " + websiteStatus.GetProperty("site_status").GetString());
                 Console.WriteLine("Supported Languages: " + websiteStatus.GetProperty("supported_languages").ToString());
             }
         }
     }
 }
}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a website status request
void send_website_status_request(struct lws *wsi) {
    const char *website_status_msg = "{\"website_status\": 1}";
    unsigned char buf[LWS_PRE + 128];
    memcpy(&buf[LWS_PRE], website_status_msg, strlen(website_status_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(website_status_msg), LWS_WRITE_TEXT);
    lwsl_user("Website status request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_website_status_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "website_status"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "website_status") == 0) {
        json_t *website_status = json_object_get(root, "website_status");
        if (website_status) {
            const char *site_status = json_string_value(json_object_get(website_status, "site_status"));
            printf("Website Status: %s\n", site_status);
        }
    } else if (msg_type && strcmp(msg_type, "ping") == 0) {
        printf("Ping response received.\n");
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_website_status_request(wsi);  // Send website status request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_website_status_request(wsi);  // Periodically request website status
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_website_status_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app_id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a website status request
void send_website_status_request(struct lws *wsi) {
    const char *website_status_msg = "{\"website_status\": 1}";
    unsigned char buf[LWS_PRE + 128];
    memcpy(&buf[LWS_PRE], website_status_msg, strlen(website_status_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(website_status_msg), LWS_WRITE_TEXT);
    lwsl_user("Website status request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_website_status_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "website_status"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "website_status") == 0) {
        json_t *website_status = json_object_get(root, "website_status");
        if (website_status) {
            const char *site_status = json_string_value(json_object_get(website_status, "site_status"));
            printf("Website Status: %s\n", site_status);
        }
    } else if (msg_type && strcmp(msg_type, "ping") == 0) {
        printf("Ping response received.\n");
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_website_status_request(wsi);  // Send website status request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_website_status_request(wsi);  // Periodically request website status
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_website_status_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
 */
```

**Error Information:**
Follow these simple steps to look into general settings like call limits, currency information, supported languages and more using the Deriv API:

Import the API module: Load the DerivAPIBasic module to interact with the Deriv API.
Setup WebSocket: Establish a WebSocket connection using the app_id for authentication.
Initialize the API: Create an instance of DerivAPIBasic using the WebSocket connection.
Handle API response: Define websiteStatusResponse to process the response, handle errors, and log website status.
Request website status: Define getWebsiteStatus to send a request to the API for website status when called.
Button event listener: Attach an event listener to a button to trigger the website status request with a click.
JavaScript
Java
Perl
PHP
Python
Rust
Swift
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication,replace it with your app's ID.
const app_id = app_id;
...

---

### Get contracts for a symbol
**URL:** https://developers.deriv.com/docs/get-contracts-for-a-symbol

**Error Handling Examples:**
```text
DerivAPIBasic
```

```text
app_id
```

```text
DerivAPIBasic
```

```text
R_50
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the contracts for symbol response
const handleContractsForSymbolResponse = async (response) => {
  const data = JSON.parse(response.data);

  // Check for errors in the response
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'contracts_for', log the contracts information
  if (data.msg_type === 'contracts_for') {
    const contractsInfo = data.contracts_for;
    console.log('Contracts for Symbol:', contractsInfo);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleContractsForSymbolResponse);
};

// Function to request contracts for a specific symbol
const getContractsForSymbol = async () => {
  const contracts_for_symbol_request = {
    contracts_for: 'R_50',   // Specify the symbol
    currency: 'USD',
    landing_company: 'svg',
    product_type: 'basic',
  };

  connection.addEventListener('message', handleContractsForSymbolResponse); // Add event listener
  await api.contractsFor(contracts_for_symbol_request); // Send the contracts request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const contracts_for_symbol_button = document.querySelector('#contractsForSymbol');
  if (contracts_for_symbol_button) {
    contracts_for_symbol_button.addEventListener('click', getContractsForSymbol);
  }
} else {
  // If running in Node.js, directly call the function
  getContractsForSymbol();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `contracts_for_symbol.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node contracts_for_symbol.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="contractsForSymbol">Get Contracts for Symbol</button>`
 * - Open the HTML file in a browser, and click the button to retrieve contracts for the symbol.
 */
```

```text
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app ID for API authentication. Use 1089 for testing or replace it with your app's ID.
const app_id = app_id;

// Create a WebSocket connection to the Deriv server using the app_id for authentication
const connection = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);

// Initialize the API using the WebSocket connection
const api = new DerivAPIBasic({ connection });

// Function to handle the contracts for symbol response
const handleContractsForSymbolResponse = async (response) => {
  const data = JSON.parse(response.data);

  // Check for errors in the response
  if (data.error) {
    console.error('Error:', data.error.message);
    await api.disconnect();
    return;
  }

  // If the message type is 'contracts_for', log the contracts information
  if (data.msg_type === 'contracts_for') {
    const contractsInfo = data.contracts_for;
    console.log('Contracts for Symbol:', contractsInfo);
  }

  // Remove the event listener after processing the response
  connection.removeEventListener('message', handleContractsForSymbolResponse);
};

// Function to request contracts for a specific symbol
const getContractsForSymbol = async () => {
  const contracts_for_symbol_request = {
    contracts_for: 'R_50',   // Specify the symbol
    currency: 'USD',
    landing_company: 'svg',
    product_type: 'basic',
  };

  connection.addEventListener('message', handleContractsForSymbolResponse); // Add event listener
  await api.contractsFor(contracts_for_symbol_request); // Send the contracts request
};

// Check if running in a browser or Node.js environment
if (typeof document !== 'undefined') {
  // Add a button event listener in the browser environment
  const contracts_for_symbol_button = document.querySelector('#contractsForSymbol');
  if (contracts_for_symbol_button) {
    contracts_for_symbol_button.addEventListener('click', getContractsForSymbol);
  }
} else {
  // If running in Node.js, directly call the function
  getContractsForSymbol();
}

/*
 * Instructions to Run the Code on a Local Machine:
 * 1. Ensure Node.js is installed on your machine. Download it from https://nodejs.org/ if needed.
 * 2. Install required dependencies:
 *      - Run: `npm install @deriv/deriv-api ws`
 * 3. Save this code to a file, e.g., `contracts_for_symbol.js`.
 * 4. Open a terminal and navigate to the directory where the file is saved.
 * 5. Run the code using Node.js:
 *      - Run: `node contracts_for_symbol.js`
 *
 * In a browser environment:
 * - Save this code to a JavaScript file and link it to an HTML page with a button element:
 *   `<button id="contractsForSymbol">Get Contracts for Symbol</button>`
 * - Open the HTML file in a browser, and click the button to retrieve contracts for the symbol.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send contracts for symbol request
                    JsonObject contractsForSymbolRequest = new JsonObject();
                    contractsForSymbolRequest.addProperty("contracts_for", "R_50"); // Specify symbol here
                    contractsForSymbolRequest.addProperty("currency", "USD");
                    contractsForSymbolRequest.addProperty("landing_company", "svg");
                    contractsForSymbolRequest.addProperty("product_type", "basic");
                    send(contractsForSymbolRequest.toString());
                    System.out.println("[sent] Contracts for symbol request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("contracts_for".equals(data.get("msg_type").getAsString())) {
                        JsonObject contractsFor = data.getAsJsonObject("contracts_for");
                        System.out.println("Contracts for Symbol: " + contractsFor);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.
 */
```

```text
package src.main.java;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Timer;
import java.util.TimerTask;
import com.google.gson.JsonObject;

public class WebSocketExample {

    public static void main(String[] args) {
        try {
            // Replace with your app_id
            int app_id = app_id;
            String serverUri = "wss://ws.derivws.com/websockets/v3?app_id=" + app_id;

            // Initialize the WebSocket client
            WebSocketClient client = new WebSocketClient(new URI(serverUri)) {

                @Override
                public void onOpen(ServerHandshake handshakedata) {
                    System.out.println("[open] Connection established");

                    // Send contracts for symbol request
                    JsonObject contractsForSymbolRequest = new JsonObject();
                    contractsForSymbolRequest.addProperty("contracts_for", "R_50"); // Specify symbol here
                    contractsForSymbolRequest.addProperty("currency", "USD");
                    contractsForSymbolRequest.addProperty("landing_company", "svg");
                    contractsForSymbolRequest.addProperty("product_type", "basic");
                    send(contractsForSymbolRequest.toString());
                    System.out.println("[sent] Contracts for symbol request sent");

                    // Schedule a ping every 30 seconds
                    Timer timer = new Timer();
                    timer.scheduleAtFixedRate(new TimerTask() {
                        @Override
                        public void run() {
                            JsonObject pingMessage = new JsonObject();
                            pingMessage.addProperty("ping", 1);
                            send(pingMessage.toString());
                            System.out.println("[ping] Ping sent to keep connection alive");
                        }
                    }, 0, 30000);
                }

                @Override
                public void onMessage(String message) {
                    System.out.println("[message] Received: " + message);

                    JsonObject data = new com.google.gson.JsonParser().parse(message).getAsJsonObject();
                    if (data.has("error")) {
                        System.out.println("[error] " + data.getAsJsonObject("error").get("message").getAsString());
                    } else if ("contracts_for".equals(data.get("msg_type").getAsString())) {
                        JsonObject contractsFor = data.getAsJsonObject("contracts_for");
                        System.out.println("Contracts for Symbol: " + contractsFor);
                    } else if ("ping".equals(data.get("msg_type").getAsString())) {
                        System.out.println("[ping] Ping response received.");
                    }
                }

                @Override
                public void onClose(int code, String reason, boolean remote) {
                    System.out.println("[close] Connection closed by " + (remote ? "server" : "client") + ": " + reason);
                }

                @Override
                public void onError(Exception ex) {
                    System.out.println("[error] " + ex.getMessage());
                }
            };

            client.connect();

        } catch (URISyntaxException e) {
            System.out.println("[error] Invalid URI: " + e.getMessage());
        }
    }
}

/*
Instructions to run the code:

1. Ensure that Java is installed on your machine. You can download it from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html.
2. Add the following dependencies to your project:
   - `java-websocket` for WebSocket functionality
   - `gson` for JSON handling

   If you are using Maven, add these dependencies to your `pom.xml`:

   <dependency>
       <groupId>org.java-websocket</groupId>
       <artifactId>Java-WebSocket</artifactId>
       <version>1.5.2</version>
   </dependency>
   <dependency>
       <groupId>com.google.code.gson</groupId>
       <artifactId>gson</artifactId>
       <version>2.8.8</version>
   </dependency>

3. Compile the code:
   javac WebSocketExample.java

4. Run the code:
   java WebSocketExample

Note: Replace `app_id` with your actual app_id if needed.
 */
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a contracts for symbol request
sub send_contracts_for_symbol {
    my $connection = shift;
    my $contracts_for_request = encode_json({
        contracts_for => 'R_50',    # Symbol for which contracts are requested
        currency => 'USD',          # Set currency to USD
        landing_company => 'svg',   # Landing company (e.g., svg)
        product_type => 'basic'     # Product type is set to 'basic'
    });
    $connection->send($contracts_for_request);
    say "[request] Contracts for symbol request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send the contracts for symbol request
    send_contracts_for_symbol($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Process contracts_for response
        if ($data->{msg_type} && $data->{msg_type} eq 'contracts_for') {
            say "[contracts] Contracts for Symbol (R_50):";
            foreach my $contract (@{$data->{contracts_for}{available}}) {
                my $contract_type            = $contract->{contract_type} // "N/A";
                my $contract_display         = $contract->{contract_display} // "N/A";
                my $contract_category_display = $contract->{contract_category_display} // "N/A";
                my $market                   = $contract->{market} // "N/A";
                my $submarket                = $contract->{submarket} // "N/A";
                my $expiry_type              = $contract->{expiry_type} // "N/A";
                my $min_duration             = $contract->{min_contract_duration} // "N/A";
                my $max_duration             = $contract->{max_contract_duration} // "N/A";
                my $barrier                  = $contract->{barrier} // "N/A";
                my $sentiment                = $contract->{sentiment} // "N/A";

                # Print contract details
                say "  - Contract Type: $contract_type";
                say "    - Display Name: $contract_display";
                say "    - Category: $contract_category_display";
                say "    - Market: $market";
                say "    - Submarket: $submarket";
                say "    - Expiry Type: $expiry_type";
                say "    - Min Duration: $min_duration";
                say "    - Max Duration: $max_duration";
                say "    - Barrier: $barrier";
                say "    - Sentiment: $sentiment";
                say "    --------------------";
            }
            say "[contracts] End of Contracts Response.";
            $connection->close;  # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `contracts_for_symbol.pl`.
# 4. Run the script using the command:
#      perl contracts_for_symbol.pl
# This script will connect to the Deriv WebSocket API, request contracts for a specific symbol, and print the details.
```

```text
#!/usr/bin/env perl
use strict;
use warnings;
use v5.014;
use AnyEvent;
use AnyEvent::WebSocket::Client;
use JSON;

# WebSocket URL and app_id
my $app_id = app_id;
my $url = "wss://ws.derivws.com/websockets/v3?app_id=$app_id";

# Create WebSocket client and connection
my $client = AnyEvent::WebSocket::Client->new;
$| = 1;  # Flush output immediately for real-time logging

# Function to send a contracts for symbol request
sub send_contracts_for_symbol {
    my $connection = shift;
    my $contracts_for_request = encode_json({
        contracts_for => 'R_50',    # Symbol for which contracts are requested
        currency => 'USD',          # Set currency to USD
        landing_company => 'svg',   # Landing company (e.g., svg)
        product_type => 'basic'     # Product type is set to 'basic'
    });
    $connection->send($contracts_for_request);
    say "[request] Contracts for symbol request sent.";
}

# Establish WebSocket connection
$client->connect($url)->cb(sub {
    my $connection = eval { shift->recv };
    if (!$connection) {
        die "Connection error: $@";
    }
    say "[status] WebSocket connection established.";

    # Send the contracts for symbol request
    send_contracts_for_symbol($connection);

    # Set a timeout for receiving a response
    my $timeout = AnyEvent->timer(
        after => 10,
        cb    => sub {
            say "[error] No response received within 10 seconds. Closing connection.";
            $connection->close;
        }
    );

    # Handle incoming messages
    $connection->on(each_message => sub {
        my ($connection, $message) = @_;

        # Cancel timeout upon receiving a message
        undef $timeout;

        my $data = eval { decode_json($message->body) };
        if ($@) {
            say "[error] Failed to decode JSON: $@";
            return;
        }

        # Handle errors
        if ($data->{error}) {
            say "[error] " . $data->{error}{message};
            $connection->close;
            return;
        }

        # Process contracts_for response
        if ($data->{msg_type} && $data->{msg_type} eq 'contracts_for') {
            say "[contracts] Contracts for Symbol (R_50):";
            foreach my $contract (@{$data->{contracts_for}{available}}) {
                my $contract_type            = $contract->{contract_type} // "N/A";
                my $contract_display         = $contract->{contract_display} // "N/A";
                my $contract_category_display = $contract->{contract_category_display} // "N/A";
                my $market                   = $contract->{market} // "N/A";
                my $submarket                = $contract->{submarket} // "N/A";
                my $expiry_type              = $contract->{expiry_type} // "N/A";
                my $min_duration             = $contract->{min_contract_duration} // "N/A";
                my $max_duration             = $contract->{max_contract_duration} // "N/A";
                my $barrier                  = $contract->{barrier} // "N/A";
                my $sentiment                = $contract->{sentiment} // "N/A";

                # Print contract details
                say "  - Contract Type: $contract_type";
                say "    - Display Name: $contract_display";
                say "    - Category: $contract_category_display";
                say "    - Market: $market";
                say "    - Submarket: $submarket";
                say "    - Expiry Type: $expiry_type";
                say "    - Min Duration: $min_duration";
                say "    - Max Duration: $max_duration";
                say "    - Barrier: $barrier";
                say "    - Sentiment: $sentiment";
                say "    --------------------";
            }
            say "[contracts] End of Contracts Response.";
            $connection->close;  # Close connection after processing the response
        }
    });

    # Handle connection close
    $connection->on(finish => sub {
        say "[status] WebSocket connection closed.";
    });
});

# Start the AnyEvent event loop
AnyEvent->condvar->recv;

# Instructions to run the code on a local machine:
# 1. Ensure you have Perl installed on your machine.
# 2. Install the necessary Perl modules using the following commands:
#      cpanm AnyEvent AnyEvent::WebSocket::Client JSON
#    If `cpanm` is not installed, install it using `cpan App::cpanminus`.
# 3. Save this script to a file, e.g., `contracts_for_symbol.pl`.
# 4. Run the script using the command:
#      perl contracts_for_symbol.pl
# This script will connect to the Deriv WebSocket API, request contracts for a specific symbol, and print the details.
```

```text
<?php
// Include necessary libraries (you may need to install Ratchet via Composer)
require 'vendor/autoload.php';

use Ratchet\Client\WebSocket;
use Ratchet\Client\Connector;
use React\EventLoop\Factory as LoopFactory;
use React\Socket\Connector as ReactConnector;

// Define the app_id (replace 'your_app_id' with your actual app_id)
$app_id = 'your_app_id';

// Create an event loop to handle WebSocket events
$loop = LoopFactory::create();
$reactConnector = new ReactConnector($loop);
$connector = new Connector($loop, $reactConnector);

// Define the request object for contracts_for API call
$contracts_for_symbol_request = [
    'contracts_for'   => 'R_50',  // Symbol for which contracts are requested
    'currency'        => 'USD',   // Set currency to USD
    'landing_company' => 'svg',   // Landing company
    'product_type'    => 'basic', // Product type is set to 'basic'
];

// Connect to the Deriv WebSocket API
$connector("wss://ws.derivws.com/websockets/v3?app_id=$app_id")
    ->then(function(WebSocket $conn) use ($contracts_for_symbol_request, $loop) {
        // Send the contracts_for request to the WebSocket server
        $conn->send(json_encode($contracts_for_symbol_request));
        echo "Request sent: " . json_encode($contracts_for_symbol_request) . PHP_EOL;

        // Handle messages received from the server
        $conn->on('message', function($message) use ($conn, $loop) {
            // Decode the received message (JSON format)
            $data = json_decode($message, true);

            // Check if there is an error in the response
            if (isset($data['error'])) {
                echo "Error: " . $data['error']['message'] . PHP_EOL;
                $conn->close();
                $loop->stop(); // Stop the event loop
            }

            // If the response is for 'contracts_for', print the contract information
            if (isset($data['msg_type']) && $data['msg_type'] === 'contracts_for') {
                echo "Contracts for symbol: " . json_encode($data['contracts_for'], JSON_PRETTY_PRINT) . PHP_EOL;
                $conn->close(); // Close the WebSocket connection
                $loop->stop();  // Stop the event loop
            }
        });

        // Handle WebSocket connection closing
        $conn->on('close', function($code = null, $reason = null) use ($loop) {
            echo "Connection closed ({$code} - {$reason})" . PHP_EOL;
            $loop->stop(); // Stop the event loop when the connection is closed
        });
    }, function($e) use ($loop) {
        // Handle connection errors
        echo "Could not connect: {$e->getMessage()}" . PHP_EOL;
        $loop->stop();
    });

// Run the event loop to keep the connection alive
$loop->run();
```

```text
<?php
// Include necessary libraries (you may need to install Ratchet via Composer)
require 'vendor/autoload.php';

use Ratchet\Client\WebSocket;
use Ratchet\Client\Connector;
use React\EventLoop\Factory as LoopFactory;
use React\Socket\Connector as ReactConnector;

// Define the app_id (replace 'your_app_id' with your actual app_id)
$app_id = 'your_app_id';

// Create an event loop to handle WebSocket events
$loop = LoopFactory::create();
$reactConnector = new ReactConnector($loop);
$connector = new Connector($loop, $reactConnector);

// Define the request object for contracts_for API call
$contracts_for_symbol_request = [
    'contracts_for'   => 'R_50',  // Symbol for which contracts are requested
    'currency'        => 'USD',   // Set currency to USD
    'landing_company' => 'svg',   // Landing company
    'product_type'    => 'basic', // Product type is set to 'basic'
];

// Connect to the Deriv WebSocket API
$connector("wss://ws.derivws.com/websockets/v3?app_id=$app_id")
    ->then(function(WebSocket $conn) use ($contracts_for_symbol_request, $loop) {
        // Send the contracts_for request to the WebSocket server
        $conn->send(json_encode($contracts_for_symbol_request));
        echo "Request sent: " . json_encode($contracts_for_symbol_request) . PHP_EOL;

        // Handle messages received from the server
        $conn->on('message', function($message) use ($conn, $loop) {
            // Decode the received message (JSON format)
            $data = json_decode($message, true);

            // Check if there is an error in the response
            if (isset($data['error'])) {
                echo "Error: " . $data['error']['message'] . PHP_EOL;
                $conn->close();
                $loop->stop(); // Stop the event loop
            }

            // If the response is for 'contracts_for', print the contract information
            if (isset($data['msg_type']) && $data['msg_type'] === 'contracts_for') {
                echo "Contracts for symbol: " . json_encode($data['contracts_for'], JSON_PRETTY_PRINT) . PHP_EOL;
                $conn->close(); // Close the WebSocket connection
                $loop->stop();  // Stop the event loop
            }
        });

        // Handle WebSocket connection closing
        $conn->on('close', function($code = null, $reason = null) use ($loop) {
            echo "Connection closed ({$code} - {$reason})" . PHP_EOL;
            $loop->stop(); // Stop the event loop when the connection is closed
        });
    }, function($e) use ($loop) {
        // Handle connection errors
        echo "Could not connect: {$e->getMessage()}" . PHP_EOL;
        $loop->stop();
    });

// Run the event loop to keep the connection alive
$loop->run();
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a contracts for symbol request
        contracts_for_symbol_request = {
            "contracts_for": "R_50",
            "currency": "USD",
            "landing_company": "svg",
            "product_type": "basic"
        }
        response = await api.send(contracts_for_symbol_request)
        print("Contracts for symbol request sent")

        # Process the response and print contract details
        print_contracts_for_symbol(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print contract details for a symbol
def print_contracts_for_symbol(response):
    data = response.get("contracts_for", {})
    if data:
        print("Contracts for Symbol (R_50):")
        contracts = data.get("available", [])
        for contract in contracts:
            print(f"  - Contract Type: {contract.get('contract_type')}")
            print(f"    - Display Name: {contract.get('contract_display')}")
            print(f"    - Category: {contract.get('contract_category_display')}")
            print(f"    - Market: {contract.get('market')}")
            print(f"    - Submarket: {contract.get('submarket')}")
            print(f"    - Expiry Type: {contract.get('expiry_type')}")
            print(f"    - Min Duration: {contract.get('min_contract_duration')}")
            print(f"    - Max Duration: {contract.get('max_contract_duration')}")
            print(f"    - Barrier: {contract.get('barrier')}")
            print(f"    - Sentiment: {contract.get('sentiment')}")
            print("    --------------------")
    print("[End of Contracts for Symbol Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `contracts_for_symbol_client.py`.
# 4. Run the code from the command line:
#      python contracts_for_symbol_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request contract details for the symbol "R_50", and send pings every 30 seconds to keep the connection alive.
# The response includes important contract details such as contract type, category, market, durations, and barriers.
```

```text
import asyncio
from deriv_api import DerivAPI

# Replace with your actual app_id
app_id = app_id

async def main():
    # Initialize the DerivAPI instance
    api = DerivAPI(app_id=app_id)

    try:
        # Send a contracts for symbol request
        contracts_for_symbol_request = {
            "contracts_for": "R_50",
            "currency": "USD",
            "landing_company": "svg",
            "product_type": "basic"
        }
        response = await api.send(contracts_for_symbol_request)
        print("Contracts for symbol request sent")

        # Process the response and print contract details
        print_contracts_for_symbol(response)

        # Function to send a ping every 30 seconds to keep the connection alive
        async def keep_alive():
            while True:
                await api.ping()  # Send a ping message
                print("Sent ping to keep connection alive")
                await asyncio.sleep(30)  # Ping every 30 seconds

        # Run the keep-alive ping loop
        await asyncio.gather(keep_alive())

    except Exception as e:
        print(f"An error occurred: {e}")

    finally:
        # Disconnect from the API
        await api.disconnect()
        print("Disconnected from Deriv API")

# Helper function to format and print contract details for a symbol
def print_contracts_for_symbol(response):
    data = response.get("contracts_for", {})
    if data:
        print("Contracts for Symbol (R_50):")
        contracts = data.get("available", [])
        for contract in contracts:
            print(f"  - Contract Type: {contract.get('contract_type')}")
            print(f"    - Display Name: {contract.get('contract_display')}")
            print(f"    - Category: {contract.get('contract_category_display')}")
            print(f"    - Market: {contract.get('market')}")
            print(f"    - Submarket: {contract.get('submarket')}")
            print(f"    - Expiry Type: {contract.get('expiry_type')}")
            print(f"    - Min Duration: {contract.get('min_contract_duration')}")
            print(f"    - Max Duration: {contract.get('max_contract_duration')}")
            print(f"    - Barrier: {contract.get('barrier')}")
            print(f"    - Sentiment: {contract.get('sentiment')}")
            print("    --------------------")
    print("[End of Contracts for Symbol Response]")

# Run the main function
if __name__ == "__main__":
    asyncio.run(main())

# Instructions to run the code:
# 1. Ensure Python is installed on your machine (https://www.python.org/downloads/).
# 2. Install the Deriv API package by running:
#      pip install deriv_api
# 3. Save this code to a file, e.g., `contracts_for_symbol_client.py`.
# 4. Run the code from the command line:
#      python contracts_for_symbol_client.py
#
# This script will connect to Deriv‚Äôs WebSocket API, request contract details for the symbol "R_50", and send pings every 30 seconds to keep the connection alive.
# The response includes important contract details such as contract type, category, market, durations, and barriers.
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Contracts for symbol request JSON
    let contracts_for_symbol_request = json!({
        "contracts_for": "R_50",
        "currency": "USD",
        "landing_company": "svg",
        "product_type": "basic"
    });

    // Clone `socket` to send the contracts for symbol request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(contracts_for_symbol_request.to_string())).await.is_ok() {
            println!("[request] Contracts for symbol request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "contracts_for" {
                        println!("Contracts for Symbol (R_50):");
                        if let Some(contracts) = data["contracts_for"]["available"].as_array() {
                            for contract in contracts {
                                println!("  - Contract Type: {}", contract["contract_type"]);
                                println!("    - Display Name: {}", contract["contract_display"]);
                                println!("    - Category: {}", contract["contract_category_display"]);
                                println!("    - Market: {}", contract["market"]);
                                println!("    - Submarket: {}", contract["submarket"]);
                                println!("    - Expiry Type: {}", contract["expiry_type"]);
                                println!("    - Min Duration: {}", contract["min_contract_duration"]);
                                println!("    - Max Duration: {}", contract["max_contract_duration"]);
                                println!("    - Barrier: {}", contract["barrier"]);
                                println!("    - Sentiment: {}", contract["sentiment"]);
                                println!("    --------------------");
                            }
                        }
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request contract details for the symbol "R_50", and print out important contract details such as type, category, market, submarket, expiry type, duration, and barrier information.
*/
```

```text
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use tokio::{sync::Mutex, task::spawn};
use std::sync::Arc;
use serde_json::json;
use url::Url;

#[tokio::main]
async fn main() {
    let app_id = app_id;
    let url = format!("wss://ws.derivws.com/websockets/v3?app_id={}", app_id);
    let url = Url::parse(&url).expect("Invalid URL");

    // Connect to the WebSocket server and wrap `socket` in Arc<Mutex<_>>
    let (socket, _) = connect_async(url).await.expect("Failed to connect");
    let socket = Arc::new(Mutex::new(socket));

    println!("[status] WebSocket connection established");

    // Contracts for symbol request JSON
    let contracts_for_symbol_request = json!({
        "contracts_for": "R_50",
        "currency": "USD",
        "landing_company": "svg",
        "product_type": "basic"
    });

    // Clone `socket` to send the contracts for symbol request
    let send_socket = Arc::clone(&socket);
    let send_task = spawn(async move {
        let mut socket = send_socket.lock().await;
        if socket.send(Message::Text(contracts_for_symbol_request.to_string())).await.is_ok() {
            println!("[request] Contracts for symbol request sent.");
        }
    });

    // Task to handle incoming messages
    let receive_socket = Arc::clone(&socket);
    let receive_task = spawn(async move {
        let mut socket = receive_socket.lock().await;
        while let Some(Ok(msg)) = socket.next().await {
            match msg {
                Message::Text(text) => {
                    let data: serde_json::Value = serde_json::from_str(&text).unwrap_or_else(|_| json!({}));
                    if data.get("msg_type").unwrap_or(&json!("")) == "contracts_for" {
                        println!("Contracts for Symbol (R_50):");
                        if let Some(contracts) = data["contracts_for"]["available"].as_array() {
                            for contract in contracts {
                                println!("  - Contract Type: {}", contract["contract_type"]);
                                println!("    - Display Name: {}", contract["contract_display"]);
                                println!("    - Category: {}", contract["contract_category_display"]);
                                println!("    - Market: {}", contract["market"]);
                                println!("    - Submarket: {}", contract["submarket"]);
                                println!("    - Expiry Type: {}", contract["expiry_type"]);
                                println!("    - Min Duration: {}", contract["min_contract_duration"]);
                                println!("    - Max Duration: {}", contract["max_contract_duration"]);
                                println!("    - Barrier: {}", contract["barrier"]);
                                println!("    - Sentiment: {}", contract["sentiment"]);
                                println!("    --------------------");
                            }
                        }
                    } else if let Some(error) = data.get("error") {
                        println!("[Error] {}", error["message"]);
                    }
                }
                _ => {}
            }
        }
    });

    // Await all tasks to complete
    let _ = tokio::try_join!(send_task, receive_task);

    // Close the WebSocket connection
    let mut socket = socket.lock().await;
    socket.close(None).await.expect("Failed to close connection");
    println!("[close] Connection closed.");
}

/*
Instructions to run the code:

1. Ensure Rust and Cargo are installed on your machine. You can download them from https://www.rust-lang.org/.
2. Add the necessary dependencies to `Cargo.toml`:

   [dependencies]
   tokio = { version = "1", features = ["full"] }
   tokio-tungstenite = "0.16"
   futures-util = "0.3"
   serde_json = "1.0"
   url = "2.2"

3. Build the project:

   cargo build --release

4. Run the project:

   cargo run --release

This code will connect to the Deriv WebSocket API, request contract details for the symbol "R_50", and print out important contract details such as type, category, market, submarket, expiry type, duration, and barrier information.
*/
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()
```

```text
import Foundation

// Make webSocketTask a global variable to keep the connection open
var webSocketTask: URLSessionWebSocketTask?

// Function to create and handle WebSocket connection
func connectWebSocket() {
    let appID = app_id // Replace with your app_id.
    let url = URL(string: "wss://ws.derivws.com/websockets/v3?app_id=\(appID)")! // WebSocket URL with the app_id
    let request = URLRequest(url: url)
    
    // Initialize webSocketTask with URLSession
    webSocketTask = URLSession.shared.webSocketTask(with: request)
    
    // Start the WebSocket connection
    webSocketTask?.resume()
    print("[status] WebSocket connection established.")
    
    // Function to send website status request
    func sendWebsiteStatusRequest() {
        let websiteStatusRequest = ["website_status": 1] as [String: Any]
        
        if let requestData = try? JSONSerialization.data(withJSONObject: websiteStatusRequest, options: []) {
            let message = URLSessionWebSocketTask.Message.data(requestData)
            webSocketTask?.send(message) { error in
                if let error = error {
                    print("[error] Failed to send website status request: \(error.localizedDescription)")
                } else {
                    print("[status] Website status request sent.")
                }
            }
        }
    }
    
    // Function to receive messages from the server
    func receiveMessage() {
        webSocketTask?.receive { result in
            switch result {
            case .success(let message):
                switch message {
                case .string(let text):
                    if let data = text.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        handleServerMessage(json)
                    }
                case .data(let data):
                    print("[message] Binary data received: \(data)")
                @unknown default:
                    print("[message] Received unknown message type")
                }
                
                // Continue to receive messages
                receiveMessage()
                
            case .failure(let error):
                print("[error] Failed to receive message: \(error.localizedDescription)")
            }
        }
    }
    
    // Function to handle the website status response from server
    func handleServerMessage(_ data: [String: Any]) {
        if let error = data["error"] as? [String: Any], let message = error["message"] as? String {
            print("[Error] \(message)")
        } else if data["msg_type"] as? String == "website_status", let websiteStatus = data["website_status"] as? [String: Any] {
            let siteStatus = websiteStatus["site_status"] as? String ?? "Unknown"
            let supportedLanguages = websiteStatus["supported_languages"] as? [String] ?? []
            
            print("[Website Status] Site Status: \(siteStatus)")
            print("[Website Status] Supported Languages: \(supportedLanguages.joined(separator: ", "))")
        }
    }
    
    // Send the website status request and start receiving messages
    sendWebsiteStatusRequest()
    receiveMessage()
}

// Function to close the WebSocket connection
func closeWebSocketConnection() {
    webSocketTask?.cancel(with: .normalClosure, reason: nil)
    print("[close] Connection closed cleanly")
}

// Start WebSocket connection
connectWebSocket()

// Keep the program running to wait for messages
RunLoop.main.run()
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a contracts for symbol request
void send_contracts_for_symbol_request(struct lws *wsi) {
    const char *contracts_for_symbol_msg = "{\"contracts_for\": \"R_50\", \"currency\": \"USD\", \"landing_company\": \"svg\", \"product_type\": \"basic\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], contracts_for_symbol_msg, strlen(contracts_for_symbol_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(contracts_for_symbol_msg), LWS_WRITE_TEXT);
    lwsl_user("Contracts for symbol request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_contracts_for_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "contracts_for"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "contracts_for") == 0) {
        json_t *contracts_for = json_object_get(root, "contracts_for");
        json_t *available_contracts = json_object_get(contracts_for, "available");

        printf("Contracts for Symbol (R_50):\n");
        size_t index;
        json_t *contract;
        json_array_foreach(available_contracts, index, contract) {
            const char *contract_type = json_string_value(json_object_get(contract, "contract_type"));
            const char *display_name = json_string_value(json_object_get(contract, "contract_display"));
            const char *category = json_string_value(json_object_get(contract, "contract_category_display"));
            const char *market = json_string_value(json_object_get(contract, "market"));
            const char *submarket = json_string_value(json_object_get(contract, "submarket"));
            const char *expiry_type = json_string_value(json_object_get(contract, "expiry_type"));
            const char *min_duration = json_string_value(json_object_get(contract, "min_contract_duration"));
            const char *max_duration = json_string_value(json_object_get(contract, "max_contract_duration"));

            printf("  - Contract Type: %s\n", contract_type);
            printf("    - Display Name: %s\n", display_name);
            printf("    - Category: %s\n", category);
            printf("    - Market: %s\n", market);
            printf("    - Submarket: %s\n", submarket);
            printf("    - Expiry Type: %s\n", expiry_type);
            printf("    - Min Duration: %s\n", min_duration);
            printf("    - Max Duration: %s\n", max_duration);
            printf("    --------------------\n");
        }
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_contracts_for_symbol_request(wsi);  // Send contracts for symbol request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_contracts_for_symbol_request(wsi);  // Periodically request contracts
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_contracts_for_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
```

```text
#include <libwebsockets.h>
#include <jansson.h>  // For JSON parsing
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>

// Set up WebSocket context and connection details
static struct lws_context *context;
static int interrupted = 0, port = 443, ssl_connection = LCCSCF_USE_SSL;
static const char *server_address = "ws.derivws.com";
static const char *path = "/websockets/v3?app_id=app_id";//replace with your app id
static const char *pro = "lws-minimal-client";

// Interval for the ping in seconds
static const int ping_interval = 30;
static time_t last_ping_time = 0;

// Buffer to accumulate received message fragments
static char message_buffer[16384];
static size_t message_length = 0;

// Signal handler for graceful shutdown
static void sigint_handler(int sig) {
    interrupted = 1;
}

// Function to send a ping message
void send_ping(struct lws *wsi) {
    const char *ping_msg = "{\"ping\": 1}";
    unsigned char buf[LWS_PRE + 20];
    memcpy(&buf[LWS_PRE], ping_msg, strlen(ping_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(ping_msg), LWS_WRITE_TEXT);
    lwsl_user("Ping sent\n");
}

// Function to send a contracts for symbol request
void send_contracts_for_symbol_request(struct lws *wsi) {
    const char *contracts_for_symbol_msg = "{\"contracts_for\": \"R_50\", \"currency\": \"USD\", \"landing_company\": \"svg\", \"product_type\": \"basic\"}";
    unsigned char buf[LWS_PRE + 256];
    memcpy(&buf[LWS_PRE], contracts_for_symbol_msg, strlen(contracts_for_symbol_msg));
    lws_write(wsi, &buf[LWS_PRE], strlen(contracts_for_symbol_msg), LWS_WRITE_TEXT);
    lwsl_user("Contracts for symbol request sent\n");
}

// Function to check if JSON is complete based on braces balance
int is_json_complete(const char *json) {
    int brace_count = 0;
    for (size_t i = 0; json[i] != '\0'; i++) {
        if (json[i] == '{') brace_count++;
        else if (json[i] == '}') brace_count--;
    }
    return brace_count == 0;
}

// Function to handle the JSON response once fully received
static void handle_contracts_for_response(const char *response) {
    json_t *root;
    json_error_t error;

    // Parse the JSON response
    root = json_loads(response, 0, &error);
    if (!root) {
        printf("Error parsing JSON: %s at line %d, column %d\n", error.text, error.line, error.column);
        return;
    }

    // Check if the response contains an error
    json_t *error_obj = json_object_get(root, "error");
    if (error_obj) {
        const char *error_message = json_string_value(json_object_get(error_obj, "message"));
        printf("Error: %s\n", error_message);
        json_decref(root);
        return;
    }

    // Check if the message type is "contracts_for"
    const char *msg_type = json_string_value(json_object_get(root, "msg_type"));
    if (msg_type && strcmp(msg_type, "contracts_for") == 0) {
        json_t *contracts_for = json_object_get(root, "contracts_for");
        json_t *available_contracts = json_object_get(contracts_for, "available");

        printf("Contracts for Symbol (R_50):\n");
        size_t index;
        json_t *contract;
        json_array_foreach(available_contracts, index, contract) {
            const char *contract_type = json_string_value(json_object_get(contract, "contract_type"));
            const char *display_name = json_string_value(json_object_get(contract, "contract_display"));
            const char *category = json_string_value(json_object_get(contract, "contract_category_display"));
            const char *market = json_string_value(json_object_get(contract, "market"));
            const char *submarket = json_string_value(json_object_get(contract, "submarket"));
            const char *expiry_type = json_string_value(json_object_get(contract, "expiry_type"));
            const char *min_duration = json_string_value(json_object_get(contract, "min_contract_duration"));
            const char *max_duration = json_string_value(json_object_get(contract, "max_contract_duration"));

            printf("  - Contract Type: %s\n", contract_type);
            printf("    - Display Name: %s\n", display_name);
            printf("    - Category: %s\n", category);
            printf("    - Market: %s\n", market);
            printf("    - Submarket: %s\n", submarket);
            printf("    - Expiry Type: %s\n", expiry_type);
            printf("    - Min Duration: %s\n", min_duration);
            printf("    - Max Duration: %s\n", max_duration);
            printf("    --------------------\n");
        }
    }

    json_decref(root);
}

// Callback function for WebSocket events
static int callback_minimal(struct lws *wsi, enum lws_callback_reasons reason,
                            void *user, void *in, size_t len) {
    switch (reason) {
    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        lwsl_err("CLIENT_CONNECTION_ERROR: %s\n", in ? (char *)in : "(null)");
        interrupted = 1;
        break;

    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connection established\n");
        send_contracts_for_symbol_request(wsi);  // Send contracts for symbol request on connection
        lws_callback_on_writable(wsi); // Request writable callback
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        if (time(NULL) - last_ping_time >= ping_interval) {
            send_ping(wsi);  // Send periodic ping
            last_ping_time = time(NULL);
            send_contracts_for_symbol_request(wsi);  // Periodically request contracts
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
        // Accumulate incoming message chunks into the buffer
        if (message_length + len < sizeof(message_buffer) - 1) {
            memcpy(&message_buffer[message_length], in, len);
            message_length += len;
            message_buffer[message_length] = '\0';  // Null-terminate

            // Check if we have a complete JSON message
            if (is_json_complete(message_buffer)) {
                printf("Received complete JSON message: %s\n", message_buffer);
                handle_contracts_for_response(message_buffer); // Process JSON response
                message_length = 0;  // Reset the buffer after parsing
            }
        } else {
            printf("Warning: Message buffer overflow. Clearing buffer.\n");
            message_length = 0;  // Clear the buffer on overflow
        }
        break;

    case LWS_CALLBACK_CLIENT_CLOSED:
        lwsl_user("Connection closed\n");
        interrupted = 1;
        break;

    default:
        break;
    }

    return 0;
}

// Define supported protocols for the WebSocket
static const struct lws_protocols protocols[] = {
    { "lws-minimal-client", callback_minimal, 0, 0, 0, NULL, 0 },
    LWS_PROTOCOL_LIST_TERM
};

// Main function to set up and manage the WebSocket client
int main(int argc, const char **argv) {
    struct lws_context_creation_info info;
    struct lws_client_connect_info i;

    // Handle Ctrl+C interrupt for graceful shutdown
    signal(SIGINT, sigint_handler);
    memset(&info, 0, sizeof info);
    memset(&i, 0, sizeof(i));

    lwsl_user("Initializing Deriv WebSocket client...\n");

    info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.fd_limit_per_thread = 1 + 1 + 1;

    context = lws_create_context(&info);
    if (!context) {
        lwsl_err("lws init failed\n");
        return 1;
    }

    i.context = context;
    i.port = port;
    i.address = server_address;
    i.path = path;
    i.host = i.address;
    i.origin = i.address;
    i.ssl_connection = ssl_connection;
    i.protocol = pro;
    i.local_protocol_name = "lws-minimal-client";

    if (!lws_client_connect_via_info(&i)) {
        lwsl_err("Failed to initiate connection\n");
        return 1;
    }

    // Run the WebSocket client event loop
    while (!interrupted)
        lws_service(context, 0);

    lws_context_destroy(context);
    lwsl_user("WebSocket client terminated.\n");

    return 0;
}

/*
 * Instructions:
 * 1. Install the required libraries if they are not already installed:
 *    - On Ubuntu:
 *        sudo apt-get install libwebsockets-dev libjansson-dev
 *    - On macOS:
 *        brew install libwebsockets jansson
 * 2. Compile the code using the following command:
 *      gcc -o connect connect.c -lwebsockets -ljansson -lssl -lcrypto -lm
 * 3. Run the compiled executable:
 *      ./connect
 * 4. Ensure you have internet connectivity as the WebSocket will attempt to connect to `ws.derivws.com`.
 * 5. Replace "app_id=1089" in the `path` variable with your actual app_id if required.
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send contracts for symbol request
            await SendContractsForSymbolRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendContractsForSymbolRequest(ClientWebSocket webSocket)
    {
        var contractsForSymbolRequest = new
        {
            contracts_for = "R_50",
            currency = "USD",
            landing_company = "svg",
            product_type = "basic"
        };

        string requestJson = JsonSerializer.Serialize(contractsForSymbolRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[request] Contracts for symbol request sent.");
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[8192];
    var messageBuilder = new StringBuilder();

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            break;
        }

        messageBuilder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));

        if (result.EndOfMessage)
        {
            try
            {
                var data = JsonDocument.Parse(messageBuilder.ToString()).RootElement;
                if (data.TryGetProperty("error", out var error))
                {
                    Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                    break;
                }

                if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "contracts_for")
                {
                    Console.WriteLine("Contracts for Symbol (R_50):");
                    foreach (var contract in data.GetProperty("contracts_for").GetProperty("available").EnumerateArray())
                    {
                        Console.WriteLine($"  - Contract Type: {contract.GetProperty("contract_type").GetString()}");
                        Console.WriteLine($"    - Display Name: {contract.GetProperty("contract_display").GetString()}");
                        Console.WriteLine($"    - Category: {contract.GetProperty("contract_category_display").GetString()}");
                        Console.WriteLine($"    - Market: {contract.GetProperty("market").GetString()}");
                        Console.WriteLine($"    - Submarket: {contract.GetProperty("submarket").GetString()}");
                        Console.WriteLine($"    - Expiry Type: {contract.GetProperty("expiry_type").GetString()}");

                        // Check for optional properties with safe access
                        Console.WriteLine($"    - Min Duration: {(contract.TryGetProperty("min_contract_duration", out var minDuration) ? minDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Max Duration: {(contract.TryGetProperty("max_contract_duration", out var maxDuration) ? maxDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Barrier: {(contract.TryGetProperty("barrier", out var barrier) ? barrier.GetString() : "N/A")}");
                        Console.WriteLine($"    - Sentiment: {(contract.TryGetProperty("sentiment", out var sentiment) ? sentiment.GetString() : "N/A")}");
                        Console.WriteLine("    --------------------");
                    }
                }

                messageBuilder.Clear();
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"[Error] Failed to parse JSON message: {ex.Message}");
            }
        }
    }
}


}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
using System;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

class WebSocketExample
{
    private static readonly Uri uri = new Uri("wss://ws.derivws.com/websockets/v3?app_id=app_id"); // Replace with your app_id if needed

    public static async Task Main(string[] args)
    {
        using (ClientWebSocket webSocket = new ClientWebSocket())
        {
            Console.WriteLine("Attempting to connect to WebSocket...");

            await webSocket.ConnectAsync(uri, CancellationToken.None);
            Console.WriteLine("[status] WebSocket connection established.");

            // Send contracts for symbol request
            await SendContractsForSymbolRequest(webSocket);

            // Handle responses from the server
            await HandleResponses(webSocket);
        }
    }

    private static async Task SendContractsForSymbolRequest(ClientWebSocket webSocket)
    {
        var contractsForSymbolRequest = new
        {
            contracts_for = "R_50",
            currency = "USD",
            landing_company = "svg",
            product_type = "basic"
        };

        string requestJson = JsonSerializer.Serialize(contractsForSymbolRequest);
        var bytes = Encoding.UTF8.GetBytes(requestJson);
        await webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
        Console.WriteLine("[request] Contracts for symbol request sent.");
    }

private static async Task HandleResponses(ClientWebSocket webSocket)
{
    var buffer = new byte[8192];
    var messageBuilder = new StringBuilder();

    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

        if (result.MessageType == WebSocketMessageType.Close)
        {
            Console.WriteLine("WebSocket connection closed by server.");
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            break;
        }

        messageBuilder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));

        if (result.EndOfMessage)
        {
            try
            {
                var data = JsonDocument.Parse(messageBuilder.ToString()).RootElement;
                if (data.TryGetProperty("error", out var error))
                {
                    Console.WriteLine($"[Error] {error.GetProperty("message").GetString()}");
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing due to error", CancellationToken.None);
                    break;
                }

                if (data.TryGetProperty("msg_type", out var msgType) && msgType.GetString() == "contracts_for")
                {
                    Console.WriteLine("Contracts for Symbol (R_50):");
                    foreach (var contract in data.GetProperty("contracts_for").GetProperty("available").EnumerateArray())
                    {
                        Console.WriteLine($"  - Contract Type: {contract.GetProperty("contract_type").GetString()}");
                        Console.WriteLine($"    - Display Name: {contract.GetProperty("contract_display").GetString()}");
                        Console.WriteLine($"    - Category: {contract.GetProperty("contract_category_display").GetString()}");
                        Console.WriteLine($"    - Market: {contract.GetProperty("market").GetString()}");
                        Console.WriteLine($"    - Submarket: {contract.GetProperty("submarket").GetString()}");
                        Console.WriteLine($"    - Expiry Type: {contract.GetProperty("expiry_type").GetString()}");

                        // Check for optional properties with safe access
                        Console.WriteLine($"    - Min Duration: {(contract.TryGetProperty("min_contract_duration", out var minDuration) ? minDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Max Duration: {(contract.TryGetProperty("max_contract_duration", out var maxDuration) ? maxDuration.GetString() : "N/A")}");
                        Console.WriteLine($"    - Barrier: {(contract.TryGetProperty("barrier", out var barrier) ? barrier.GetString() : "N/A")}");
                        Console.WriteLine($"    - Sentiment: {(contract.TryGetProperty("sentiment", out var sentiment) ? sentiment.GetString() : "N/A")}");
                        Console.WriteLine("    --------------------");
                    }
                }

                messageBuilder.Clear();
            }
            catch (JsonException ex)
            {
                Console.WriteLine($"[Error] Failed to parse JSON message: {ex.Message}");
            }
        }
    }
}


}

/*
Instructions to run the code locally:

1. Ensure you have .NET SDK installed. You can download it from https://dotnet.microsoft.com/download.

2. Save the code to a file named `WebSocketExample.cs`.

3. Open a terminal in the directory containing `WebSocketExample.cs`.

4. If using the .NET CLI, you can run the code with:
   - `dotnet new console -o WebSocketExample` (if creating a new project)
   - Move `WebSocketExample.cs` into the project directory `WebSocketExample`.
   - Navigate to the project directory: `cd WebSocketExample`.
   - Run `dotnet add package System.Net.WebSockets.Client` to add the WebSocket client dependency.
   - Run the code: `dotnet run`.

5. Alternatively, you can use an IDE like Visual Studio to create a console application, add the `System.Net.WebSockets.Client` package, and then run the application.

6. Replace `app_id=1089` in the URL with your actual app_id if needed.
*/
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//replace with your app_id
	readLimit    = 65536 // Set a higher read limit, e.g., 64 KB
)

type ContractsForRequest struct {
	ContractsFor   string `json:"contracts_for"`
	Currency       string `json:"currency"`
	LandingCompany string `json:"landing_company"`
	ProductType    string `json:"product_type"`
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("[status] WebSocket connection established.")

	// Set a higher read limit
	conn.SetReadLimit(readLimit)

	// Send contracts for symbol request
	err = sendContractsForSymbolRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send contracts for symbol request: %v", err)
	}

	// Handle incoming messages
	handleResponses(ctx, conn)
}

func sendContractsForSymbolRequest(ctx context.Context, conn *websocket.Conn) error {
	contractsRequest := ContractsForRequest{
		ContractsFor:   "R_50",
		Currency:       "USD",
		LandingCompany: "svg",
		ProductType:    "basic",
	}
	fmt.Println("[request] Sending contracts for symbol request...")
	return wsjson.Write(ctx, conn, contractsRequest)
}

func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}

		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		msgType := response["msg_type"]
		if msgType == "contracts_for" {
			contracts := response["contracts_for"].(map[string]interface{})["available"].([]interface{})
			fmt.Println("Contracts for Symbol (R_50):")
			for _, contract := range contracts {
				contractMap := contract.(map[string]interface{})
				fmt.Printf("  - Contract Type: %v\n", contractMap["contract_type"])
				fmt.Printf("    - Display Name: %v\n", contractMap["contract_display"])
				fmt.Printf("    - Category: %v\n", contractMap["contract_category_display"])
				fmt.Printf("    - Market: %v\n", contractMap["market"])
				fmt.Printf("    - Submarket: %v\n", contractMap["submarket"])
				fmt.Printf("    - Expiry Type: %v\n", contractMap["expiry_type"])
				fmt.Printf("    - Min Duration: %v\n", contractMap["min_contract_duration"])
				fmt.Printf("    - Max Duration: %v\n", contractMap["max_contract_duration"])
				fmt.Printf("    - Barrier: %v\n", contractMap["barrier"])
				fmt.Printf("    - Sentiment: %v\n", contractMap["sentiment"])
				fmt.Println("    --------------------")
			}
		} else {
			fmt.Printf("Received message: %v\n", response)
		}
	}
}
```

```text
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"nhooyr.io/websocket"
	"nhooyr.io/websocket/wsjson"
)

const (
	webSocketURL = "wss://ws.derivws.com/websockets/v3?app_id=app_id"//replace with your app_id
	readLimit    = 65536 // Set a higher read limit, e.g., 64 KB
)

type ContractsForRequest struct {
	ContractsFor   string `json:"contracts_for"`
	Currency       string `json:"currency"`
	LandingCompany string `json:"landing_company"`
	ProductType    string `json:"product_type"`
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Establish WebSocket connection
	conn, _, err := websocket.Dial(ctx, webSocketURL, nil)
	if err != nil {
		log.Fatalf("Failed to connect to WebSocket: %v", err)
	}
	defer conn.Close(websocket.StatusNormalClosure, "normal closure")
	fmt.Println("[status] WebSocket connection established.")

	// Set a higher read limit
	conn.SetReadLimit(readLimit)

	// Send contracts for symbol request
	err = sendContractsForSymbolRequest(ctx, conn)
	if err != nil {
		log.Fatalf("Failed to send contracts for symbol request: %v", err)
	}

	// Handle incoming messages
	handleResponses(ctx, conn)
}

func sendContractsForSymbolRequest(ctx context.Context, conn *websocket.Conn) error {
	contractsRequest := ContractsForRequest{
		ContractsFor:   "R_50",
		Currency:       "USD",
		LandingCompany: "svg",
		ProductType:    "basic",
	}
	fmt.Println("[request] Sending contracts for symbol request...")
	return wsjson.Write(ctx, conn, contractsRequest)
}

func handleResponses(ctx context.Context, conn *websocket.Conn) {
	for {
		var response map[string]interface{}

		err := wsjson.Read(ctx, conn, &response)
		if err != nil {
			log.Fatalf("Error reading message: %v", err)
		}

		msgType := response["msg_type"]
		if msgType == "contracts_for" {
			contracts := response["contracts_for"].(map[string]interface{})["available"].([]interface{})
			fmt.Println("Contracts for Symbol (R_50):")
			for _, contract := range contracts {
				contractMap := contract.(map[string]interface{})
				fmt.Printf("  - Contract Type: %v\n", contractMap["contract_type"])
				fmt.Printf("    - Display Name: %v\n", contractMap["contract_display"])
				fmt.Printf("    - Category: %v\n", contractMap["contract_category_display"])
				fmt.Printf("    - Market: %v\n", contractMap["market"])
				fmt.Printf("    - Submarket: %v\n", contractMap["submarket"])
				fmt.Printf("    - Expiry Type: %v\n", contractMap["expiry_type"])
				fmt.Printf("    - Min Duration: %v\n", contractMap["min_contract_duration"])
				fmt.Printf("    - Max Duration: %v\n", contractMap["max_contract_duration"])
				fmt.Printf("    - Barrier: %v\n", contractMap["barrier"])
				fmt.Printf("    - Sentiment: %v\n", contractMap["sentiment"])
				fmt.Println("    --------------------")
			}
		} else {
			fmt.Printf("Received message: %v\n", response)
		}
	}
}
```

**Error Information:**
Follow these steps to retrieve the list of available contracts, along with the latest barrier and duration limits for each contract, for a given symbol using the Deriv API:

Import Deriv API: Import the DerivAPIBasic library from Skypack CDN.
WebSocket connection: Create a WebSocket connection to the Deriv API using your app_id.
API initialization: Initialize the DerivAPIBasic instance with the WebSocket connection.
Request object: Define a request object to fetch contracts for a specific symbol (e.g., R_50).
Response handling: Handle the API response:
Parse the data and log any errors.
If the response contains contract data, log it.
Remove the event listener after the response is received.
Trigger request: On a button click, the function sends the request to the API to get the contracts for the symbol.
JavaScript
Java
Perl
PHP
Python
Rust
Swift
C
C#
Go
// Import DerivAPIBasic from the Deriv API package
import DerivAPIBasic from '@deriv/deriv-api/dist/DerivAPIBasic.js';

// Set the app...

---


## üìà IMPLEMENTATION STATISTICS

- **AUTHENTICATION:** 30 relevant pages found
- **TRADING:** 34 relevant pages found
- **WEBSOCKETS:** 22 relevant pages found
- **CONTRACTS:** 23 relevant pages found
- **MARKETDATA:** 29 relevant pages found
- **ACCOUNTMANAGEMENT:** 9 relevant pages found
- **ERRORHANDLING:** 6 relevant pages found

## üéØ NEXT STEPS FOR BOT IMPLEMENTATION

1. **Setup Authentication:** Implement OAuth or API token authentication
2. **Establish WebSocket Connection:** Create persistent connection for real-time data
3. **Implement Trading Logic:** Add buy/sell functionality with proper contract handling
4. **Add Market Data Streaming:** Subscribe to real-time price feeds
5. **Account Management:** Implement balance tracking and portfolio management
6. **Error Handling:** Add comprehensive error handling and logging
7. **Testing:** Implement thorough testing with demo accounts
8. **Risk Management:** Add position sizing and stop-loss functionality

## üîó CRITICAL API ENDPOINTS DISCOVERED

- `active_symbols`
- `authorize`
- `balance`
- `buy`
- `portfolio`
- `proposal`
- `sell`
- `statement`
- `ticks`

---

**Total comprehensive documentation extracted and analyzed!**
**Ready for bot implementation with complete API knowledge.**
